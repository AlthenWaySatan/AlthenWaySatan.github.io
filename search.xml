<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【CF438E】 The Child and Binary Tree 简易题解</title>
    <url>/2019/02/23/CF438E-The-Child-and-Binary-Tree-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/CF438E">【CF438E】 The Child and Binary Tree</a></p>
<span id="more"></span>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>$\ \ \ \ \ \ \,$给你 $n$ 和 $m$，和大小为 $n$ 的集合 $C$。</p>
<p>$\ \ \ \ \ \ \,$需要你统计点权在集合 $C$ 内，且点权之和分别为 $[1,m]$ 的二叉树个数。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>$\ \ \ \ \ \ \,$根据题目，我们可以想到$DP$公式求解：</p>
<p>$<br> f(n)=<br> \begin{cases}<br> 1, &amp; \text {$(n=0)$} \\<br>\sum_{i=1}^{n}g(i)\sum_{j=0}^{n-i}f(j)\cdot f(n-i-j), &amp; \text{$(n &gt; 0)$}<br>  \end{cases}<br> $</p>
<p>$\ \ \ \ \ \ \,$其中：</p>
<ul>
<li>$f(i)$意思是且点权之和 $i$ 的二叉树个数。</li>
<li>$g(i)$意思是集合 $C$ 中是否含有元素 $i$，既 $g(i)=[i\in C]$ 。</li>
</ul>
<p>$\ \ \ \ \ \ \,$怎么得到这个公式的就不说了，还是比较显然的 <del>（雾</del> 。但是很明显复杂度过不去。我们把它们写成生成函数会好一些 <del>（计数题套路？）</del>：</p>
<p>$\ \ \ \ \ \ \,$令函数 $F$ 为序列 $f(x)$ 的生成函数，函数 $G$ 为序列 $g(x)$的生成函数。</p>
<p>$\ \ \ \ \ \ \,$可以得到：</p>
<p>$F=G*F^2+1$</p>
<p>$\ \ \ \ \ \ \,$解得：</p>
<p>$F=\frac{2}{1\pm\sqrt{1-4G}}$</p>
<p>$\ \ \ \ \ \ \,$那么是加号还是减号啊？已知$F_0=1$。而题目保证 $(1\leq c_i \leq 10^5)$，所以有$G_0=0$。那么带入可以得到应该是取加号。</p>
<p>$\ \ \ \ \ \ \,$所以说只需要求出多项式$\frac{2}{1+\sqrt{1-4G}}$的$[1,m]$项就好了。</p>
<p>$\ \ \ \ \ \ \,$格式挺清新的，需要求逆和开根，模板直接往上套就好了呢：<a href="4000/2019/04/03/多项式全家桶/">【多项式的操作大赏】</a>。我写的开根比较麻烦，还要写 $\ln$ 和 $\exp$，然后 $\ln$ 还要写求积分和求导。所以说……基本上……所有模板都用到了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>,mod_g=<span class="number">3</span>,N=<span class="number">1600000</span>;</span><br><span class="line"><span class="type">int</span> R[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="number">1ll</span>*a*a%mod)</span><br><span class="line">	<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=<span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">  	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Inv(x) power(x,mod-2)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Polynomial_init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len;<span class="keyword">for</span>(len=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> f,<span class="type">int</span> la)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=la;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;R[i])<span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="type">int</span> gn=<span class="built_in">power</span>(mod_g,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">      		<span class="type">int</span> g=<span class="number">1</span>;</span><br><span class="line">      		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++,g=<span class="number">1ll</span>*g*gn%mod)&#123;</span><br><span class="line">	        	<span class="type">int</span> x=a[j+k],y=<span class="number">1ll</span>*g*a[i+j+k]%mod;</span><br><span class="line">	        	a[j+k]=(x+y)%mod;a[i+j+k]=(x-y+mod)%mod;</span><br><span class="line">	      	&#125;</span><br><span class="line">    	&#125; </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span>(f==<span class="number">-1</span>)&#123;</span><br><span class="line">   		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    	<span class="type">int</span> inv=<span class="built_in">Inv</span>(n);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=<span class="number">1ll</span>*a[i]*inv%mod;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Convolution</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> la,<span class="type">int</span> lb)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=la,m=lb;</span><br><span class="line">	<span class="type">int</span> L=<span class="number">0</span>;<span class="keyword">for</span>(m+=n,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>)L++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">1</span>,n);<span class="built_in">NTT</span>(b,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">-1</span>,n);</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> C[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inverse</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(len==<span class="number">1</span>)&#123;b[<span class="number">0</span>]=<span class="built_in">Inv</span>(a[<span class="number">0</span>]);<span class="keyword">return</span>;&#125;</span><br><span class="line">  	<span class="built_in">Inverse</span>(a,b,(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  	<span class="type">int</span> L=<span class="number">0</span>,n=<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(;n&lt;(len&lt;&lt;<span class="number">1</span>);n&lt;&lt;=<span class="number">1</span>)L++;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)C[i]=a[i];</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;n;i++)C[i]=<span class="number">0</span>;</span><br><span class="line">  	<span class="built_in">NTT</span>(C,<span class="number">1</span>,n);<span class="built_in">NTT</span>(b,<span class="number">1</span>,n);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)b[i]=<span class="number">1ll</span>*(<span class="number">2ll</span><span class="number">-1ll</span>*C[i]*b[i]%mod+mod)%mod*b[i]%mod;</span><br><span class="line">  	<span class="built_in">NTT</span>(b,<span class="number">-1</span>,n);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;n;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derivation</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">  	b[i<span class="number">-1</span>]=<span class="number">1ll</span>*i*a[i]%mod;</span><br><span class="line">	b[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Integral</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">  	b[i]=<span class="number">1ll</span>*<span class="built_in">Inv</span>(i)*a[i<span class="number">-1</span>]%mod;</span><br><span class="line">	b[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A[N],B[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logarithmic</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="built_in">sizeof</span>(A));</span><br><span class="line">	<span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="built_in">sizeof</span>(B));</span><br><span class="line">  	<span class="built_in">Derivation</span>(a,A,len);</span><br><span class="line">  	<span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="built_in">sizeof</span>(C));</span><br><span class="line">  	<span class="built_in">Inverse</span>(a,B,len);</span><br><span class="line">  	<span class="built_in">Convolution</span>(A,B,len,len);</span><br><span class="line">  	<span class="built_in">Integral</span>(A,b,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> D[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exponential</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(len==<span class="number">1</span>)&#123;b[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">  	<span class="built_in">Exponential</span>(a,b,len&gt;&gt;<span class="number">1</span>),<span class="built_in">Logarithmic</span>(b,D,len);</span><br><span class="line">  	D[<span class="number">0</span>]=(<span class="number">1ll</span>*a[<span class="number">0</span>]+<span class="number">1ll</span>-D[<span class="number">0</span>]+mod)%mod;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;++i) D[i]=(<span class="number">1ll</span>*a[i]-D[i]+mod)%mod;</span><br><span class="line">  	<span class="built_in">Convolution</span>(b,D,len&lt;&lt;<span class="number">1</span>,len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;(len&lt;&lt;<span class="number">1</span>);++i) b[i]=D[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> E[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kth_root</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="built_in">Logarithmic</span>(a,E,len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)E[i]=<span class="number">499122177ll</span>*E[i]%mod;</span><br><span class="line">	<span class="built_in">Exponential</span>(E,b,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,F[N],G[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)++G[<span class="built_in">read</span>()];</span><br><span class="line">  	<span class="type">int</span> len=<span class="built_in">Polynomial_init</span>(m);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)G[i]=(mod-(<span class="number">4ll</span>*G[i]%mod))%mod;</span><br><span class="line">  	++G[<span class="number">0</span>];</span><br><span class="line">  	<span class="built_in">Kth_root</span>(G,F,len,<span class="number">2</span>);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)G[i]=<span class="number">0</span>;</span><br><span class="line">  	F[<span class="number">0</span>]=(F[<span class="number">0</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">  	<span class="built_in">Inverse</span>(F,G,len);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;++i)G[i]=(<span class="number">2ll</span>*G[i])%mod;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,G[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>DP</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>【CF888G】 Xor-MST 简易题解</title>
    <url>/2019/02/26/CF888G-Xor-MST-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/CF888G">【CF888G】 Xor-MST</a></p>
<span id="more"></span>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>$\ \ \ \ \ \ \,$给你一个 $n$ 个节点的完全图，第 $i$ 个点的权值为 $a_i$ ，两点的之间边权为这两个点权值的异或值，求最小生成树的权值。</p>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>$\ \ \ \ \ \ \,$其实这道题没有那么复杂，还是好想的。</p>
<p>$\ \ \ \ \ \ \,$最小生成树的话，我们显然有一个基于贪心的$Kruskal$ 算法，复杂度 $O(n^2\log n)$，想想还是算了吧。</p>
<p>$\ \ \ \ \ \ \,$而遇到关于异或的题呢，我们一般会有两种想法：整形异或线性基，$Trie$ 树。</p>
<p>$\ \ \ \ \ \ \,$容易想到的，这道题当然和线性基没有关系了，我们思考一下 $Trie$ 树，首先，我们先把第一个样例从高位到低位插入线性基看看：</p>
<p><img src="https://img-blog.csdnimg.cn/20190226084314824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3Mzk2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>$\ \ \ \ \ \ \,$容易发现，对于每个叶子节点，既每个点值之间，要是需要互相连边，那么求 <strong>他们 $Lca$ 以后的边的亦或值</strong> 即可。</p>
<p>$\ \ \ \ \ \ \,$由此可得，若是 $Lca$ 的深度越深，便约优。因为我们是从高位到低位插入的，所以浅的点权值较大，要尽量避免选择浅的点。</p>
<p>$\ \ \ \ \ \ \,$我们不妨把可能是 $Lca$ 的点拉出来瞅瞅：</p>
<p><img src="https://img-blog.csdnimg.cn/20190226085043371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3Mzk2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>$\ \ \ \ \ \ \,$惊喜地发现，刚好有 $4$ 个点，也就是所有拥有两个儿子的点一共有 $4$ 个，可以证明，如果 $a_i$ 两两不等的话，那么这种点一共有 $n-1$ 个，那么答案就呼之欲出了：</p>
<p>$\ \ \ \ \ \ \,$我们每找到这样的点，就暴力贪心 $DFS$ 下去：</p>
<ul>
<li>每次尽量同时走左儿子或右儿子；</li>
<li>如果两个都有，就两个都走，然后返回值取 $min$ 。</li>
<li>如果两个只有不一样的儿子，就在返回值加上这一深度$bit$的值，然后继续走</li>
</ul>
<p>$\ \ \ \ \ \ \,$最终答案就是他们的 $DFS$ 值的和。</p>
<p>$\ \ \ \ \ \ \,$那如果 $a_i$ 不是两两不等的话怎么办呢，如果 $a_u=a_v$ 的话，我们当然首先建一条边连接 $u$，$v$，权值为 $0$，对答案完全没有影响，所以我们正常建，正常搜，是不会有问题的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">2</span>][<span class="number">200000</span>*<span class="number">30</span>+<span class="number">10</span>],tot;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> now=<span class="number">0</span>,id;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">	    	id=(a&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">	    	<span class="keyword">if</span>(!son[id][now])son[id][now]=++tot;</span><br><span class="line">	    	now=son[id][now];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> r1,<span class="type">int</span> r2,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> a1=<span class="number">-1</span>,a2=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(son[<span class="number">0</span>][r1]&amp;&amp;son[<span class="number">0</span>][r2]) a1=<span class="built_in">Find</span>(son[<span class="number">0</span>][r1],son[<span class="number">0</span>][r2],b<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(son[<span class="number">1</span>][r1]&amp;&amp;son[<span class="number">1</span>][r2]) a2=<span class="built_in">Find</span>(son[<span class="number">1</span>][r1],son[<span class="number">1</span>][r2],b<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(~a1&amp;&amp;~a2) <span class="keyword">return</span> <span class="built_in">min</span>(a1,a2);</span><br><span class="line">		<span class="keyword">if</span>(~a1) <span class="keyword">return</span> a1;<span class="keyword">if</span>(~a2) <span class="keyword">return</span> a2;</span><br><span class="line">		<span class="keyword">if</span>(son[<span class="number">1</span>][r1]&amp;&amp;son[<span class="number">0</span>][r2]) a1=<span class="built_in">Find</span>(son[<span class="number">1</span>][r1],son[<span class="number">0</span>][r2],b<span class="number">-1</span>)+(<span class="number">1</span>&lt;&lt;b);</span><br><span class="line">		<span class="keyword">if</span>(son[<span class="number">0</span>][r1]&amp;&amp;son[<span class="number">1</span>][r2]) a2=<span class="built_in">Find</span>(son[<span class="number">0</span>][r1],son[<span class="number">1</span>][r2],b<span class="number">-1</span>)+(<span class="number">1</span>&lt;&lt;b);</span><br><span class="line">		<span class="keyword">if</span>(~a1&amp;&amp;~a2) <span class="keyword">return</span> <span class="built_in">min</span>(a1,a2);</span><br><span class="line">		<span class="keyword">if</span>(~a1) <span class="keyword">return</span> a1;<span class="keyword">if</span>(~a2) <span class="keyword">return</span> a2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(T.son[<span class="number">0</span>][a]&amp;&amp;T.son[<span class="number">1</span>][a]) ans+=<span class="number">1ll</span>*T.<span class="built_in">Find</span>(T.son[<span class="number">0</span>][a],T.son[<span class="number">1</span>][a],b<span class="number">-1</span>)+(<span class="number">1ll</span>&lt;&lt;b);</span><br><span class="line">	<span class="keyword">if</span>(T.son[<span class="number">0</span>][a]) <span class="built_in">dfs</span>(T.son[<span class="number">0</span>][a],b<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(T.son[<span class="number">1</span>][a]) <span class="built_in">dfs</span>(T.son[<span class="number">1</span>][a],b<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)T.<span class="built_in">Insert</span>(<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>异或</tag>
        <tag>Trie树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【CF487E】 Tourists 简易题解</title>
    <url>/2019/03/20/CF487E-Tourists-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/CF487E">【CF487E】 Tourists</a></p>
<span id="more"></span>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>$\ \ \ \ \ \ \,$ 给你 $n$ 个点和 $m$条边的无向图，没有自环，没有重边，每个点上面有点权。</p>
<p>$\ \ \ \ \ \ \,$ 每次可能有两种操作：修改一个点的点权，或者询问两个点之间的路径上最小可能的点权是多少。</p>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>$\ \ \ \ \ \ \,$有一个很显然的贪心想法，询问的时候肯定优先走较小权值路径，也就是在有分叉（点双）的时候走较小权值的那一侧，而只有可能最小的会造成贡献。</p>
<p>$\ \ \ \ \ \ \,$所以说我们可以尝试将每个点双之间建一个堆，记录最小的点权。</p>
<p>$\ \ \ \ \ \ \,$也就是建出一棵圆方树，方点上面一个堆，记录与他向连的圆点的权值最小值。</p>
<p>$\ \ \ \ \ \ \,$每次询问就只需要考虑经过唯一路径上面 <strong>圆点点权</strong> 和 <strong>方点堆顶</strong> 的最小值就行了，这个可以用树链剖分搞。</p>
<p>$\ \ \ \ \ \ \,$然后考虑修改，便是修改与这个 <strong>圆点</strong> 相连的方点上面的堆就好了，删除原来的点权，加入新点权。但是这样子我们不能保证其复杂度，要是圆方树建成一个菊花图就会 $T$ 飞了。</p>
<p>$\ \ \ \ \ \ \,$我们再考虑一下，我们树链剖分往上跳的时候，其实已经计算过  <strong>走过的方点</strong> 的父亲了（圆点），会有计算重复的地方。所以说 <strong>方点的堆</strong> 里面不需要记录其父亲的权值，换句话说，对于一个圆点，他的值只需要被他的 <strong>方点父亲</strong> 的堆记录，这样子每次修改，只需要修改他父亲的，加上线段树和堆的复杂度也不过一次 $O(\log n)$。</p>
<p>$\ \ \ \ \ \ \,$但是每次询问的是两个圆点，其$LCA$有可能是方点，这个时候少计算了一个 <strong>方点$LCA$</strong> 的父亲，需要注意加入判断一下。<del>（第一个样第一次例询问输出为2有可能就是这样死的）</del></p>
<p>$\ \ \ \ \ \ \,$然后就是 <strong>圆方树+树链剖分+线段树+可删堆</strong> 套模板了，可删堆我是用 $fhq_Treap$ 实现的，所以说代码比较丑。</p>
<p>$\ \ \ \ \ \ \,$预处理复杂度$O(n\log n)$，修改操作复杂度$O(\log n)$，询问操作复杂度$O(\log^2 n)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">200</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],E[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_E</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;E[x].<span class="built_in">push_back</span>(y);E[y].<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_G</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;G[x].<span class="built_in">push_back</span>(y);G[y].<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"><span class="type">int</span> sta[N],top,Size;</span><br><span class="line"><span class="type">int</span> tim,dfn[N],low[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  	dfn[u]=low[u]=++tim;</span><br><span class="line">  	sta[++top]=u;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])&#123;</span><br><span class="line">    	<span class="keyword">if</span>(dfn[v]) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    	<span class="keyword">else</span>&#123;</span><br><span class="line">      		<span class="built_in">tarjan</span>(v),low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">      		<span class="keyword">if</span>(low[v]&gt;=dfn[u])&#123;</span><br><span class="line">        		++Size;<span class="type">int</span> p;</span><br><span class="line">        		<span class="keyword">while</span>((p=sta[top])!=v)<span class="built_in">add_G</span>(p,Size),top--;</span><br><span class="line">        		p=sta[top],<span class="built_in">add_G</span>(p,Size),top--;</span><br><span class="line">        		<span class="built_in">add_G</span>(u,Size);</span><br><span class="line">      		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> ls,rs,key,size,val;&#125;T[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson T[rt].ls</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson T[rt].rs</span></span><br><span class="line"><span class="type">int</span> node_cnt;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;Rub;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> rt;</span><br><span class="line">	<span class="keyword">if</span>(!Rub.<span class="built_in">empty</span>())rt=Rub.<span class="built_in">front</span>(),Rub.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">else</span> rt=++node_cnt;</span><br><span class="line">	lson=rson=<span class="number">0</span>;</span><br><span class="line">	T[rt].key=<span class="built_in">rand</span>();T[rt].val=x;T[rt].size=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_Treap</span>&#123;</span><br><span class="line">	<span class="type">int</span> root;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;T[rt].size=T[lson].size+T[rson].size+<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!a||!b)<span class="keyword">return</span> a|b;</span><br><span class="line">		<span class="keyword">if</span>(T[a].key&lt;T[b].key)&#123;T[a].rs=<span class="built_in">merge</span>(T[a].rs,b);<span class="built_in">pushup</span>(a);<span class="keyword">return</span> a;&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;T[b].ls=<span class="built_in">merge</span>(a,T[b].ls);<span class="built_in">pushup</span>(b);<span class="keyword">return</span> b;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!rt)&#123;a=b=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(T[rt].val&lt;=x)&#123;a=rt;<span class="built_in">split</span>(rson,x,rson,b);&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;b=rt;<span class="built_in">split</span>(lson,x,a,lson);&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">		<span class="type">int</span> rt=<span class="built_in">newnode</span>(x);</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,rt),b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">split</span>(root,x,a,c);</span><br><span class="line">		<span class="built_in">split</span>(a,x<span class="number">-1</span>,a,b);</span><br><span class="line">		b=<span class="built_in">merge</span>(T[b].ls,T[b].rs);</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Min</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> rt=root;</span><br><span class="line">		<span class="keyword">while</span>(lson)rt=lson;</span><br><span class="line">		<span class="keyword">return</span> T[rt].val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Treap[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos[N],w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment_Tree</span>&#123;</span><br><span class="line">  	<span class="meta">#<span class="keyword">define</span> Lson l,mid,rt&lt;&lt;1</span></span><br><span class="line">  	<span class="meta">#<span class="keyword">define</span> Rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line">  	<span class="type">int</span> sum[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;sum[rt]=<span class="built_in">min</span>(sum[rt&lt;&lt;<span class="number">1</span>],sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">if</span>(l==r)&#123;sum[rt]=w[pos[l]];<span class="keyword">return</span>;&#125;</span><br><span class="line">  		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  		<span class="built_in">build</span>(Lson);<span class="built_in">build</span>(Rson);</span><br><span class="line">  		<span class="built_in">pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> c,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(l==r)&#123;sum[rt]=c;<span class="keyword">return</span>;&#125;</span><br><span class="line">    	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(id&lt;=mid)<span class="built_in">Update</span>(id,c,Lson);</span><br><span class="line">    	<span class="keyword">else</span> <span class="built_in">Update</span>(id,c,Rson);</span><br><span class="line">		<span class="built_in">pushup</span>(rt);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)<span class="keyword">return</span> sum[rt];</span><br><span class="line">    	<span class="type">int</span> ret=<span class="number">1e9</span>,mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(L&lt;=mid)ret=<span class="built_in">min</span>(ret,<span class="built_in">Query</span>(L,R,Lson));</span><br><span class="line">    	<span class="keyword">if</span>(R&gt;mid)ret=<span class="built_in">min</span>(ret,<span class="built_in">Query</span>(L,R,Rson));</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;Seg;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree_Chain_Dissection</span>&#123;</span><br><span class="line">	<span class="type">int</span> idx[N];</span><br><span class="line">	<span class="type">int</span> deep[N],fa[N],son[N],size[N];</span><br><span class="line">	<span class="type">int</span> cnt,top[N];</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">		deep[u]=dep;fa[u]=f;size[u]=<span class="number">1</span>;</span><br><span class="line">		Treap[fa[u]].<span class="built_in">Insert</span>(w[u]);</span><br><span class="line">		<span class="type">int</span> maxson=<span class="number">-1</span>;</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])<span class="keyword">if</span>(v!=f)&#123;</span><br><span class="line">		  	size[u]+=<span class="built_in">dfs1</span>(v,u,dep+<span class="number">1</span>);</span><br><span class="line">		  	<span class="keyword">if</span>(size[v]&gt;maxson)maxson=size[v],son[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> size[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">		idx[u]=++cnt;top[u]=topf;</span><br><span class="line">		pos[cnt]=u;</span><br><span class="line">		<span class="keyword">if</span>(!son[u])<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])<span class="keyword">if</span>(!idx[v])<span class="built_in">dfs2</span>(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=Size;++i)w[i]=Treap[i].<span class="built_in">Min</span>();</span><br><span class="line">		Seg.<span class="built_in">build</span>(<span class="number">1</span>,Size,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">if</span>(fa[u])&#123;</span><br><span class="line">	    	Treap[fa[u]].<span class="built_in">Delete</span>(w[u]);</span><br><span class="line">	    	Treap[fa[u]].<span class="built_in">Insert</span>(val);</span><br><span class="line">	    	Seg.<span class="built_in">Update</span>(idx[fa[u]],Treap[fa[u]].<span class="built_in">Min</span>(),<span class="number">1</span>,Size,<span class="number">1</span>);</span><br><span class="line">	  	&#125;</span><br><span class="line">	  	w[u]=val;</span><br><span class="line">		Seg.<span class="built_in">Update</span>(idx[u],val,<span class="number">1</span>,Size,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	  	<span class="type">int</span> ans=inf;</span><br><span class="line">	  	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">	    	<span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">	    	ans=<span class="built_in">min</span>(ans,Seg.<span class="built_in">Query</span>(idx[top[x]],idx[x],<span class="number">1</span>,Size,<span class="number">1</span>));</span><br><span class="line">	    	x=fa[top[x]];</span><br><span class="line">	  	&#125;</span><br><span class="line">	 	<span class="keyword">if</span>(deep[x]&gt;deep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">	  	ans=<span class="built_in">min</span>(ans,Seg.<span class="built_in">Query</span>(idx[x],idx[y],<span class="number">1</span>,Size,<span class="number">1</span>));</span><br><span class="line">    	<span class="keyword">if</span>(x&lt;=n)<span class="keyword">return</span> ans;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(ans,w[fa[x]]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;TCD;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	Size=n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();Q=<span class="built_in">read</span>();w[<span class="number">0</span>]=inf;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">read</span>();</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;++i)</span><br><span class="line">	a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),<span class="built_in">add_E</span>(a,b);</span><br><span class="line">  	<span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">  	TCD.<span class="built_in">init</span>();</span><br><span class="line">  	<span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();</span><br><span class="line">    	<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)TCD.<span class="built_in">Update</span>(a,b);</span><br><span class="line">    	<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,TCD.<span class="built_in">Query</span>(a,b));</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>图论</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title>FhqTreap各种操作模板大赏</title>
    <url>/2019/01/06/FhqTreap%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%E5%A4%A7%E8%B5%8F/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于Splay操作的复习笔记：</p>
<p>$\ \ \ \ \ \ \ \,$一些平衡树操作和都是一样的，详见<a href="/2019/01/05/Splay各种操作模板大赏/">【Splay各种操作模板大赏】</a>。</p>
<span id="more"></span>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_Treap</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">  	<span class="type">int</span> size[N],key[N],sum[N],val[N];</span><br><span class="line">  	<span class="type">int</span> ls[N],rs[N],cnt;</span><br><span class="line">  	<span class="type">int</span> root;</span><br><span class="line">  	<span class="type">bool</span> lazy[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>$\tt root$ ：根；</li>
<li>$\tt cnt$ ：下标大小；</li>
<li>$\tt key[]$ ：关键值；</li>
<li>$\tt ls[]\&amp;rs[]$ ：左右儿子；</li>
<li>$\tt sum[]$ ：子树权值；</li>
<li>$\tt val[]$ ：节点权值；</li>
<li>$\tt size[]$ ：节点大小；</li>
<li>$\tt lazy[]$ ：下传标记。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>手写随机($Rand$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> seed=<span class="number">233</span>;</span><br><span class="line">    <span class="keyword">return</span> seed=<span class="built_in">int</span>(seed*<span class="number">48271LL</span>%<span class="number">20020207</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>标记上传 ($pushup$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">	sum[rt]=sum[lson]+sum[rson]+val[rt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>标记下传 ($pushdown$)，根据情况会不一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(lson,rson);</span><br><span class="line">    lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">    lazy[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分裂($split$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//权值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      	<span class="keyword">if</span>(val[rt]&lt;=x)a=rt,<span class="built_in">split</span>(rson,x,rs[a],b);</span><br><span class="line">      	<span class="keyword">else</span> b=rt,<span class="built_in">split</span>(lson,x,a,ls[b]);</span><br><span class="line">      	<span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(size[ls[rt]]&lt;x)a=rt,<span class="built_in">split</span>(rson,x-size[ls[rt]]<span class="number">-1</span>,rs[a],b);</span><br><span class="line">      	<span class="keyword">else</span> b=rt,<span class="built_in">split</span>(lson,x,a,ls[b]);</span><br><span class="line">      	<span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>合并($merge$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(key[x]&lt;key[y])&#123;<span class="built_in">pushdown</span>(x);rs[x]=<span class="built_in">merge</span>(rs[x],y);<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">pushdown</span>(y);ls[y]=<span class="built_in">merge</span>(x,ls[y]);<span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li>新建节点 ($newnode$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  	sum[++cnt]=val[cnt]=v;size[cnt]=<span class="number">1</span>;key[cnt]=<span class="built_in">Rand</span>();</span><br><span class="line">  	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>插入($Insert$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">    <span class="type">int</span> rt=<span class="built_in">newnode</span>(v);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,rt),b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除($Delete$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);<span class="built_in">split</span>(a,x<span class="number">-1</span>,a,c);</span><br><span class="line">    c=<span class="built_in">merge</span>(ls[c],rs[c]);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,c),b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>区间修改（翻转）($revse$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    lazy[y]^=<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h2><ul>
<li><p>查找排名第k的值($QueryRank$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueryRank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(x==size[lson]+<span class="number">1</span>)<span class="keyword">return</span> val[rt];</span><br><span class="line">      	<span class="keyword">if</span>(size[lson]&gt;=x)rt=lson;</span><br><span class="line">      	<span class="keyword">else</span> x-=size[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找某个值的排名($Rank$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]&gt;=x)rt=lson;</span><br><span class="line">    	<span class="keyword">else</span> res+=size[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>前驱($Numpre$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Numpre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">QueryRank</span>(<span class="built_in">Rank</span>(x)<span class="number">-1</span>);&#125;</span><br></pre></td></tr></table></figure></li>
<li>后继($Numnex$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Numnex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">QueryRank</span>(<span class="built_in">Rank</span>(x+<span class="number">1</span>));&#125;</span><br></pre></td></tr></table></figure></li>
<li>区间查询（权值和）($Numnex$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=sum[y];</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="两个模板题："><a href="#两个模板题：" class="headerlink" title="两个模板题："></a>两个模板题：</h2><ul>
<li><a href="https://www.luogu.org/problemnew/show/P3369">P3369 【模板】普通平衡树</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_Treap</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Rand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> seed=<span class="number">233</span>;</span><br><span class="line">    <span class="keyword">return</span> seed=<span class="built_in">int</span>(seed*<span class="number">48271LL</span>%<span class="number">20020207</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> size[N],key[N],val[N];</span><br><span class="line">  <span class="type">int</span> ls[N],rs[N],cnt,sum[N];</span><br><span class="line">  <span class="type">int</span> root;</span><br><span class="line">  <span class="type">bool</span> lazy[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">        sum[rt]=sum[lson]+sum[rson]+val[rt];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  	++cnt;</span><br><span class="line">    size[cnt]=size[b];key[cnt]=key[b];val[cnt]=val[b];</span><br><span class="line">    ls[cnt]=ls[b];rs[cnt]=rs[b],lazy[cnt]=lazy[b];sum[cnt]=sum[b];</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(lson,rson);</span><br><span class="line">    lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">    lazy[rt]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(key[x]&lt;key[y])&#123;<span class="built_in">pushdown</span>(x);rs[x]=<span class="built_in">merge</span>(rs[x],y);<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">pushdown</span>(y);ls[y]=<span class="built_in">merge</span>(x,ls[y]);<span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//权值</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      <span class="keyword">if</span>(val[rt]&lt;=x)a=rt,<span class="built_in">split</span>(rson,x,rs[a],b);</span><br><span class="line">      <span class="keyword">else</span> b=rt,<span class="built_in">split</span>(lson,x,a,ls[b]);</span><br><span class="line">      <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">    val[++cnt]=x;size[cnt]=<span class="number">1</span>;key[cnt]=<span class="built_in">Rand</span>();</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,cnt),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);<span class="built_in">split</span>(a,x<span class="number">-1</span>,a,c);</span><br><span class="line">    c=<span class="built_in">merge</span>(ls[c],rs[c]);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,c),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Rank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]&gt;=x)rt=lson;</span><br><span class="line">    	<span class="keyword">else</span> res+=size[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QueryRank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x==size[lson]+<span class="number">1</span>)<span class="keyword">return</span> val[rt];</span><br><span class="line">      <span class="keyword">if</span>(size[lson]&gt;=x)rt=lson;</span><br><span class="line">      <span class="keyword">else</span> x-=size[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Numpre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">QueryRank</span>(<span class="built_in">Rank</span>(x)<span class="number">-1</span>);&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Numnex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">QueryRank</span>(<span class="built_in">Rank</span>(x+<span class="number">1</span>));&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    lazy[y]^=<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=sum[y];</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Fhq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    <span class="type">int</span> opt=<span class="built_in">read</span>(),x=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;Fhq.<span class="built_in">Insert</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;Fhq.<span class="built_in">Delete</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Fhq.<span class="built_in">Rank</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">4</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Fhq.<span class="built_in">QueryRank</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">5</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Fhq.<span class="built_in">Numpre</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">6</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Fhq.<span class="built_in">Numnex</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://www.luogu.org/problemnew/show/P3391">P3391 【模板】文艺平衡树（Splay）</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_Treap</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Rand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> seed=<span class="number">233</span>;</span><br><span class="line">    <span class="keyword">return</span> seed=<span class="built_in">int</span>(seed*<span class="number">48271LL</span>%<span class="number">20020207</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> size[N],key[N],val[N],w[N];</span><br><span class="line">  <span class="type">int</span> ls[N],rs[N],cnt;</span><br><span class="line">  <span class="type">int</span> root;</span><br><span class="line">  <span class="type">bool</span> lazy[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(lson,rson);</span><br><span class="line">    lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">    lazy[rt]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(key[x]&lt;key[y])&#123;<span class="built_in">pushdown</span>(x);rs[x]=<span class="built_in">merge</span>(rs[x],y);<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">pushdown</span>(y);ls[y]=<span class="built_in">merge</span>(x,ls[y]);<span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//位置</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(size[ls[rt]]&lt;x)a=rt,<span class="built_in">split</span>(rson,x-size[ls[rt]]<span class="number">-1</span>,rs[a],b);</span><br><span class="line">      <span class="keyword">else</span> b=rt,<span class="built_in">split</span>(lson,x,a,ls[b]);</span><br><span class="line">      <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);++cnt;</span><br><span class="line">    val[cnt]=v;size[cnt]=<span class="number">1</span>;key[cnt]=<span class="built_in">Rand</span>();</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,cnt),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    lazy[y]^=<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Fhq;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  Fhq.<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  <span class="keyword">if</span>(Fhq.lson)<span class="built_in">write</span>(Fhq.lson);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Fhq.val[rt]);</span><br><span class="line">  <span class="keyword">if</span>(Fhq.rson)<span class="built_in">write</span>(Fhq.rson); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)Fhq.<span class="built_in">Insert</span>(i<span class="number">-1</span>,i);</span><br><span class="line"> 	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">  	Fhq.<span class="built_in">Reverse</span>(l,r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write</span>(Fhq.root);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>平衡树</tag>
        <tag>Fhq_Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>【SCOI2016】Day2初略题解</title>
    <url>/2019/02/15/SCOI2016-Day2%E5%88%9D%E7%95%A5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \,$做一套省选题来练练手（Day2）。</p>
<span id="more"></span>
<h2 id="【T1-妖怪】"><a href="#【T1-妖怪】" class="headerlink" title="【T1 妖怪】"></a><a href="https://www.luogu.org/problemnew/show/P3291">【T1 妖怪】</a></h2><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$ 对于一个妖怪的两个属性，为了方便我们把它定义为 $x$，$y$，而要求的一个妖怪的战斗力应该为：</p>
<p>$(\frac{b}{a}+1)x+(\frac{a}{b}+1)y$</p>
<p>$\ \ \ \ \ \,$ 既：</p>
<p>$\frac{b}{a}x+\frac{a}{b}y+x+y$</p>
<p>$\ \ \ \ \ \,$ 由于 $x$，$y$ 已经确定，所以我们需要找的是 $\frac{b}{a}x+\frac{a}{b}y$ 最大的最小。</p>
<p>$\ \ \ \ \ \,$容易得到这是个<strong>对勾函数</strong>，对于一个怪物，当$\frac{b}{a}=\sqrt{\frac{y}{x}}$ 时，战斗力最小。</p>
<p>$\ \ \ \ \ \,$所以我们以 $x$，$y$ 为横纵坐标做个上凸壳，那么答案就一定是在凸壳上面，就会存在下面两种情况：</p>
<ul>
<li>在点上：$\frac{b}{a}=\sqrt{\frac{y}{x}}$</li>
<li>在边上：需要满足：<br>$(\frac{b}{a}+1)x_1+(\frac{a}{b}+1)y_1=(\frac{b}{a}+1)x_2+(\frac{a}{b}+1)y_2$<br>解得：$\frac{b}{a}=\frac{y_1-y_2}{x_2-x_1}$</li>
</ul>
<p>$\ \ \ \ \ \,$就这样扫一遍过去就行了，复杂度 $O(n \log n)$。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;<span class="type">long</span> <span class="type">long</span> x,y;&#125;p[N],f[N];</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> (Point)&#123;a.x+b.x,a.y+b.y&#125;;&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> (Point)&#123;a.x-b.x,a.y-b.y&#125;;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Cross</span><span class="params">(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Solve</span><span class="params">(Point *P,<span class="type">int</span> n,Point *F)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(P+<span class="number">1</span>,P+n+<span class="number">1</span>);<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(;top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">Cross</span>(F[top]-F[top<span class="number">-1</span>],P[i]-F[top<span class="number">-1</span>])&gt;=<span class="number">0</span>;top--);</span><br><span class="line">    	F[++top]=P[i];</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">const</span> Point &amp;a,<span class="type">double</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> k&lt;=<span class="number">0</span>?inf:(<span class="type">double</span>)a.x+a.y+k*a.x+a.y/k;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Getval_point</span><span class="params">(<span class="type">const</span> Point &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="type">double</span>)a.y/a.x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Getval_line</span><span class="params">(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a.x==b.x?-inf:((<span class="type">double</span>)(a.y-b.y)/(<span class="type">double</span>)(b.x-a.x));&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;monster.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;monster.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)p[i].x=<span class="number">1ll</span>*<span class="built_in">read</span>(),p[i].y=<span class="number">1ll</span>*<span class="built_in">read</span>();</span><br><span class="line">	m=<span class="built_in">Solve</span>(p,n,f);</span><br><span class="line">	<span class="keyword">if</span>(m&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.4lf&quot;</span>,<span class="built_in">solve</span>(f[<span class="number">1</span>],<span class="built_in">Getval_point</span>(f[<span class="number">1</span>])));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">double</span> k1,k2,k3,ans=inf;</span><br><span class="line">		k1=<span class="built_in">Getval_point</span>(f[<span class="number">1</span>]),k2=<span class="built_in">Getval_line</span>(f[<span class="number">1</span>],f[<span class="number">2</span>]);</span><br><span class="line">		<span class="keyword">if</span>(k1&lt;=k2)ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[<span class="number">1</span>],k1));</span><br><span class="line">		k1=<span class="built_in">Getval_point</span>(f[m]),k2=<span class="built_in">Getval_line</span>(f[m<span class="number">-1</span>],f[m]);</span><br><span class="line">		<span class="keyword">if</span>(k1&gt;=k2)ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[m],k1));</span><br><span class="line">  		ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[m],k2));</span><br><span class="line">  		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">2</span>;i&lt;m;++i)&#123;</span><br><span class="line">  			k1=<span class="built_in">Getval_line</span>(f[i<span class="number">-1</span>],f[i]);</span><br><span class="line">  			k2=<span class="built_in">Getval_line</span>(f[i],f[i+<span class="number">1</span>]);</span><br><span class="line">  			k3=<span class="built_in">Getval_point</span>(f[i]);</span><br><span class="line">  			ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[i],k1));</span><br><span class="line">  			<span class="keyword">if</span>(k1&lt;=k3&amp;&amp;k3&lt;=k2)</span><br><span class="line">  			ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[i],k3));</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="【T2-美味】"><a href="#【T2-美味】" class="headerlink" title="【T2 美味】"></a><a href="https://www.luogu.org/problemnew/show/P3293">【T2 美味】</a></h2><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$又是异或最大呢，不是线性基就是贪心了，day1才搞了线性基，可以排除，我们看看怎么贪心。</p>
<p>$\ \ \ \ \ \,$首先可以看到他有一个取值范围的限制，我们可以用到可持久化数据结构维护。</p>
<p>$\ \ \ \ \ \,$然后我们可以贪心地想，从高位到低为维护 $a_i$ 的存在性。这个可持久化数据结构需要满足下面的操作：</p>
<ul>
<li>插入一个数；</li>
<li>删除一个数；</li>
<li>统计某个取值范围的数数量是多少。</li>
</ul>
<p>$\ \ \ \ \ \,$我最后选择了权值主席树。</p>
<p>$\ \ \ \ \ \,$现在对于每一次询问，我们贪心一下，从高位到低位枚举，如果$b$这一位为$1$，我们就找 $0$ ，反之找 $1$。</p>
<p>$\ \ \ \ \ \,$怎么找呢？我们令当前找到第$i$位， $ans$ 等于当前最优的 $a_i+x$，那么我们就找当前 $[l,r]$ 范围内，是否存在有数次在区间（$1/0$为当前要找的数）：</p>
<p>$[ans+(1/0&lt;&lt;i)-x,ans+(1/0&lt;&lt;i)-x+(1&lt;&lt;i)-1]$</p>
<p>$\ \ \ \ \ \,$存在的话就更新$ans$为 $ans+(1/0&lt;&lt;i)$，不然退而求其次，取 $ans+(0/1&lt;&lt;i)$。</p>
<p>$\ \ \ \ \ \,$这样我们可以保证在完成贪心，取到第0位之时，$ans$ 等于最优的 $a_i+x$。（并不关心是哪个$a_i$，反正是拼出来了。</p>
<p>$\ \ \ \ \ \,$复杂度$O(n \log a_{max}+m\log^2 a_{max})$</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N],root[N];</span><br><span class="line"><span class="type">int</span> n,m,nn;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CM_Tree</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson l,mid,ls[rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson mid+1,r,rs[rt]</span></span><br><span class="line">	<span class="type">int</span> ls[N*<span class="number">20</span>],rs[N*<span class="number">20</span>],sum[N*<span class="number">20</span>],size;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">copy</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		ls[++size]=ls[rt];</span><br><span class="line">		rs[size]=rs[rt];</span><br><span class="line">		sum[size]=sum[rt];</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt)</span></span>&#123;</span><br><span class="line">    	rt=<span class="built_in">copy</span>(rt);sum[rt]++;</span><br><span class="line">    	<span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(id&lt;=mid)<span class="built_in">update</span>(id,lson);</span><br><span class="line">    	<span class="keyword">else</span> <span class="built_in">update</span>(id,rson);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> rt2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)<span class="keyword">return</span> sum[rt2]-sum[rt];</span><br><span class="line">    	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ret=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span>(L&lt;=mid)ret+=<span class="built_in">query</span>(L,R,lson,ls[rt2]);</span><br><span class="line">    	<span class="keyword">if</span>(mid&lt;R)ret+=<span class="built_in">query</span>(L,R,rson,rs[rt2]);</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	L=<span class="built_in">max</span>(<span class="number">0</span>,L);R=<span class="built_in">min</span>(R,nn);</span><br><span class="line">	<span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> tree.<span class="built_in">query</span>(L,R,<span class="number">0</span>,nn,root[i],root[j])&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getbit(a,i) ((a&gt;&gt;i)&amp;1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;food.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;food.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>(),nn=<span class="built_in">max</span>(nn,a[i]);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)root[i]=root[i<span class="number">-1</span>],tree.<span class="built_in">update</span>(a[i],<span class="number">0</span>,nn,root[i]);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    	<span class="type">int</span> b=<span class="built_in">read</span>(),x=<span class="built_in">read</span>(),l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(),ans=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">17</span>,ls;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(!<span class="built_in">getbit</span>(b,i))ls=ans+(<span class="number">1</span>&lt;&lt;i)-x;</span><br><span class="line">    		<span class="keyword">else</span> ls=ans-x;</span><br><span class="line">      		<span class="keyword">if</span>(<span class="built_in">check</span>(l<span class="number">-1</span>,r,ls,ls+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>))ans=ls+x;</span><br><span class="line">      		<span class="keyword">else</span> ans+=<span class="built_in">getbit</span>(b,i)&lt;&lt;i;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans^b);</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="【T3-围棋】"><a href="#【T3-围棋】" class="headerlink" title="【T3 围棋】"></a><a href="https://www.luogu.org/problemnew/show/P3290">【T3 围棋】</a></h2><p>$\ \ \ \ \ \,$插头dp是不会做插头dp的，这辈子不可能做插头dp的。写起来又怪麻烦，就是打打傻逼暴力，才能骗得了分这样子。</p>
<p>$\ \ \ \ \ \,$（逃</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>计算几何</tag>
        <tag>凸壳</tag>
        <tag>数形结合</tag>
        <tag>主席树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #536 (Div. 2)【己亥年农历新年赛】简略题解</title>
    <url>/2019/02/15/Codeforces-Round-536-Div-2-%E5%B7%B1%E4%BA%A5%E5%B9%B4%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%E8%B5%9B-%E7%AE%80%E7%95%A5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="【题目地址】"><a href="#【题目地址】" class="headerlink" title="【题目地址】"></a><a href="https://codeforces.com/contest/1106">【题目地址】</a></h2><hr>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>$\ \ \ \ \ \ \,$这场比赛是wc2019回家那天晚上举办的，从8点到10点刚好在动车上，饥寒交迫，还拉肚子（吃不惯粤菜），就没有参加，是后面写的。</p>
<p>$\ \ \ \ \ \ \,$这套题在洛谷上面五颜六色的，很有意思啊（除了没有红的），题目也算可做，感觉很过年很快乐呢（<del>嘤嘤</del></p>
<span id="more"></span>
<p><img src="https://img-blog.csdnimg.cn/20190215201821828.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3Mzk2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h2 id="A-Lunar-New-Year-and-Cross-Counting"><a href="#A-Lunar-New-Year-and-Cross-Counting" class="headerlink" title="A. Lunar New Year and Cross Counting"></a><a href="https://codeforces.com/contest/1106/problem/A">A. Lunar New Year and Cross Counting</a></h2><p>$\ \ \ \ \ \ \,$模拟？暴力？可以不解释吗……</p>
<p><img src="https://img-blog.csdnimg.cn/20190215202145632.jpg" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> mp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x+<span class="number">2</span>&gt;n||y+<span class="number">2</span>&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mp[x][y]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">if</span>(mp[x][y+<span class="number">2</span>]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mp[x+<span class="number">1</span>][y+<span class="number">1</span>]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mp[x+<span class="number">2</span>][y]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">if</span>(mp[x+<span class="number">2</span>][y+<span class="number">2</span>]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	ans+=<span class="built_in">check</span>(i,j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="B-Lunar-New-Year-and-Food-Ordering"><a href="#B-Lunar-New-Year-and-Food-Ordering" class="headerlink" title="B. Lunar New Year and Food Ordering"></a><a href="https://codeforces.com/contest/1106/problem/B">B. Lunar New Year and Food Ordering</a></h2><p>$\ \ \ \ \ \ \,$这个也是模拟吧，我们把菜品排个序，用一个指针跳就好了吧……（敷衍<br><img src="https://img-blog.csdnimg.cn/20190215203257557.jpg" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,z=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> rk[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> a,c,id;&#125;di[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.c&lt;b.c||(a.c==b.c&amp;&amp;a.id&lt;b.id);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)di[i].a=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)di[i].c=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)di[i].id=i;</span><br><span class="line">	<span class="built_in">sort</span>(di+<span class="number">1</span>,di+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rk[di[i].id]=i;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> kind=<span class="built_in">read</span>(),cnt=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(di[rk[kind]].a&gt;=cnt)&#123;</span><br><span class="line">			di[rk[kind]].a-=cnt;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*di[rk[kind]].c*cnt);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> ls=<span class="number">0ll</span>;</span><br><span class="line">		<span class="keyword">if</span>(di[rk[kind]].a)&#123;</span><br><span class="line">			cnt-=di[rk[kind]].a;</span><br><span class="line">			ls+=<span class="number">1ll</span>*di[rk[kind]].c*di[rk[kind]].a;</span><br><span class="line">			di[rk[kind]].a=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(cnt)&#123;</span><br><span class="line">			<span class="keyword">if</span>((!di[z].a)&amp;&amp;z&lt;=n)z++;</span><br><span class="line">			<span class="keyword">if</span>(z&gt;n)&#123;ls=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(di[z].a&gt;=cnt)&#123;</span><br><span class="line">					di[z].a-=cnt;</span><br><span class="line">					ls+=<span class="number">1ll</span>*di[z].c*cnt;</span><br><span class="line">					cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					cnt-=di[z].a;</span><br><span class="line">					ls+=<span class="number">1ll</span>*di[z].c*di[z].a;</span><br><span class="line">					di[z].a=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ls);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="C-Lunar-New-Year-and-Number-Division"><a href="#C-Lunar-New-Year-and-Number-Division" class="headerlink" title="C. Lunar New Year and Number Division"></a><a href="https://codeforces.com/contest/1106/problem/C">C. Lunar New Year and Number Division</a></h2><p>$\ \ \ \ \ \ \,$根据二项式定理，当然是两个两个分为一组最合算了（$n$ 范围明示</p>
<p>$\ \ \ \ \ \ \,$我们展开可得：</p>
<p>$(a+b)^2=a^2+b^2+2ab$</p>
<p>$\ \ \ \ \ \ \,$那么我们就想要两个成积较小的分一组最好，就是排序过后，最小的和最大的分一组好了呀。</p>
<p><img src="https://img-blog.csdnimg.cn/20190215204003943.jpg" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=n;i&lt;=j;i++,j--)</span><br><span class="line">	ans+=<span class="number">1ll</span>*(a[i]+a[j])*(a[i]+a[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="D-Lunar-New-Year-and-a-Wander"><a href="#D-Lunar-New-Year-and-a-Wander" class="headerlink" title="D. Lunar New Year and a Wander"></a><a href="https://codeforces.com/contest/1106/problem/D">D. Lunar New Year and a Wander</a></h2><p>$\ \ \ \ \ \ \,$BFS……</p>
<p>$\ \ \ \ \ \ \,$并不是，其实也差不多吧，当前可以走到的点，我们把他放进堆里面，然后每次走堆里最小的这个样子。</p>
<p>$\ \ \ \ \ \ \,$（因为题意没看懂翻车了几次</p>
<p><img src="https://img-blog.csdnimg.cn/20190215204454189.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3Mzk2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();</span><br><span class="line">		G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		G[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(),G[i].<span class="built_in">end</span>());</span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="number">-1</span>);used[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=-Q.<span class="built_in">top</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])<span class="keyword">if</span>(!used[v])</span><br><span class="line">		Q.<span class="built_in">push</span>(-v),used[v]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="E-Lunar-New-Year-and-Red-Envelopes"><a href="#E-Lunar-New-Year-and-Red-Envelopes" class="headerlink" title="E. Lunar New Year and Red Envelopes"></a><a href="https://codeforces.com/contest/1106/problem/E">E. Lunar New Year and Red Envelopes</a></h2><p>$\ \ \ \ \ \ \,$后面两道题就开始有讲的意思了，反正这道题我并没有独自写出来（我怀疑题都没有怎么读懂（我好菜呀<br><img src="https://img-blog.csdnimg.cn/20190215204926766.jpg" alt="在这里插入图片描述"></p>
<p>$\ \ \ \ \ \ \,$题目做法是DP，我们定义$f_{i,j}$，表示被打扰了 $i$ 次，现在时间是 $j$ 的最小收益。转移方程呢就是：</p>
<p>$f_{i,j+1}=f_{i-1,j}$</p>
<p>$f_{i,a_l.d+1}=f_{i-1,k}+a_l.w$</p>
<p>$\ \ \ \ \ \ \,$我们预处理数当前时间用那个红包好，就可以降低复杂度到$O(nm)$，具体来说，就是哪个钱多哪个好，钱一样多的话就是哪个冷却时间长哪个好。具体操作看的<a href="https://blog.csdn.net/g21glf/article/details/86743023"><strong>这里</strong></a>，其实很多地方没有必要这么麻烦，但是自己确实是太菜了，没有自己独立做出来。<br><img src="https://img-blog.csdnimg.cn/20190215210921828.jpg" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> d,w,t;&#125;sta[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.w&gt;b.w||(a.w==b.w&amp;&amp;a.d&gt;b.d);&#125;</span><br><span class="line">vector&lt;node&gt; e[N];</span><br><span class="line">map&lt;node,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(node a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mp.<span class="built_in">count</span>(a))mp[a]++;</span><br><span class="line">	<span class="keyword">else</span> mp[a]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(node a)</span></span>&#123;</span><br><span class="line">	mp[a]--;</span><br><span class="line">	<span class="keyword">if</span>(!mp[a])mp.<span class="built_in">erase</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">2</span>][N],ans=(<span class="number">1ll</span>&lt;&lt;<span class="number">62</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,s,t,d,w;i&lt;=k;i++)&#123;</span><br><span class="line">		s=<span class="built_in">read</span>(),t=<span class="built_in">read</span>(),d=<span class="built_in">read</span>(),w=<span class="built_in">read</span>();</span><br><span class="line">		e[s].<span class="built_in">push_back</span>((node)&#123;d,w,<span class="number">1</span>&#125;);</span><br><span class="line">		e[t+<span class="number">1</span>].<span class="built_in">push_back</span>((node)&#123;d,w,<span class="number">-1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> p:e[i])</span><br><span class="line">			<span class="keyword">if</span>(~p.t)<span class="built_in">Insert</span>(p);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">Delete</span>(p);</span><br><span class="line">		<span class="keyword">if</span>(mp.<span class="built_in">size</span>())sta[i]=(*mp.<span class="built_in">begin</span>()).first;</span><br><span class="line">		<span class="keyword">else</span> sta[i]=(node)&#123;i,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> cas=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f[cas],<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f[cas]));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			f[cas][i+<span class="number">1</span>]=<span class="built_in">min</span>(f[cas][i+<span class="number">1</span>],f[cas^<span class="number">1</span>][i]);</span><br><span class="line">			f[cas^<span class="number">1</span>][sta[i].d+<span class="number">1</span>]=<span class="built_in">min</span>(f[cas^<span class="number">1</span>][sta[i].d+<span class="number">1</span>],f[cas^<span class="number">1</span>][i]+sta[i].w);</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,f[cas^<span class="number">1</span>][n+<span class="number">1</span>]);cas^=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F-Lunar-New-Year-and-a-Recursive-Sequence"><a href="#F-Lunar-New-Year-and-a-Recursive-Sequence" class="headerlink" title="F. Lunar New Year and a Recursive Sequence"></a><a href="https://codeforces.com/contest/1106/problem/F">F. Lunar New Year and a Recursive Sequence</a></h2><p>$\ \ \ \ \ \ \,$感觉这道题操作比E题麻烦一点，但是确实比E题好想呢。</p>
<p><img src="https://img-blog.csdnimg.cn/20190215213423624.jpg" alt="在这里插入图片描述"></p>
<p>$\ \ \ \ \ \ \,$看到是一个有 $k$ 项的递推式，马上就可以想到矩乘，而前 $k-1$ 项已经确定了是 $1$，我们不妨设要求的 $f_k$ 为 $a$ 。根据他给的式子啊，我们就容易发现，这个递推式的每一项都应该是 $a^x$ 的形式，知道第 $n$ 项是 $a$ 的多少次方就要好处理一些了。</p>
<p>$\ \ \ \ \ \ \,$这样子稍微观察一下矩阵乘法就定义好了：</p>
<p>$\ \ \ \ \ \ \,$转移矩阵：$A=$</p>
<p>$<br>\begin{bmatrix}0&amp;0&amp;\cdots&amp;0&amp;b_k\\ 1&amp;0&amp;\cdots&amp;0&amp;b_{k-1}\\0&amp;1&amp;\cdots&amp;0&amp;b_{k-2}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\0&amp;0&amp;\cdots&amp;1&amp;b_1\end{bmatrix}<br>$</p>
<p>$\ \ \ \ \ \ \,$初始矩阵：$S=$</p>
<p>$<br>\begin{bmatrix}0,0,\cdots,0,1\end{bmatrix}<br>$</p>
<p>$\ \ \ \ \ \ \,$那么第 $n$ 项的指数，就是 $S\cdot A^{n-k}$ 的第 $k$ 项，矩阵乘法取模的时候，根据欧拉定理，因为模数是素数，直接每次模 $mod-1$ 就好了。</p>
<p>$\ \ \ \ \ \ \,$现在问题是，我们知道 $x$，$m$，$mod$，$a^x\%mod=m$，如何求 $a$ 呢？</p>
<p>$\ \ \ \ \ \ \,$好在他给我们的模数很特殊，我们很清楚他的原根为 $3$ ，那么我们可以重新把 $a$ 定义为 $3^s\%mod$，所以原式化为:</p>
<p>$3^{sx}\%mod=m$</p>
<p>$\ \ \ \ \ \ \,$我们可以很轻松用 BSGS 算法知道 $sx\%(mod-1)$的取值，而我们又知道 $x\%(mod-1)$ 的取值，扩展GCD处理一下就好咯~</p>
<p><img src="https://img-blog.csdnimg.cn/20190215213335919.jpg" alt="在这里插入图片描述"></p>
<p>$\ \ \ \ \ \ \,$然后我们就知道 $s$ 的取值了（也有可能无解），那么答案也就出来了：$f_k=3^s$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> K,m,n;</span><br><span class="line">matrix S,A,T;</span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix m1,matrix m2)&#123;</span><br><span class="line">	matrix t;t.x=m1.x;t.y=m2.y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m1.x;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m2.y;j++)&#123;</span><br><span class="line">	  	t.a[i][j]=<span class="number">0</span>;</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m1.y;k++)</span><br><span class="line">	  	t.a[i][j]=(<span class="number">1ll</span>*t.a[i][j]+<span class="number">1ll</span>*m1.a[i][k]*m2.a[k][j])%(mod<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">power</span><span class="params">(matrix a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	matrix ans=a;b--;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a;</span><br><span class="line">		a=a*a;b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(<span class="number">1ll</span>*ans*a)%mod;</span><br><span class="line">		a=(<span class="number">1ll</span>*a*a)%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">BSGS</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c)</span></span>&#123;</span><br><span class="line">  	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;hash.<span class="built_in">clear</span>();b%=c;</span><br><span class="line">  	<span class="type">int</span> t=(<span class="type">int</span>)<span class="built_in">sqrt</span>(c)+<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">    	<span class="type">int</span> val=(<span class="type">int</span>)(b*<span class="built_in">power</span>(a,j,c)%c);</span><br><span class="line">    	hash[val]=j;</span><br><span class="line">  	&#125;</span><br><span class="line">  	a=<span class="built_in">power</span>(a,t,c);</span><br><span class="line">  	<span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;i++)&#123;</span><br><span class="line">    	<span class="type">int</span> val=<span class="built_in">power</span>(a,i,c);</span><br><span class="line">    	<span class="type">int</span> j=hash.<span class="built_in">find</span>(val)==hash.<span class="built_in">end</span>()?<span class="number">-1</span>:hash[val];</span><br><span class="line">    	<span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;i*t-j&gt;=<span class="number">0</span>)<span class="keyword">return</span> i*t-j;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> &amp;d,<span class="type">long</span> <span class="type">long</span> &amp;x,<span class="type">long</span> <span class="type">long</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)&#123;d=a;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">exgcd</span>(b,a%b,d,y,x);y-=x*(a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	K=<span class="built_in">read</span>();S.x=<span class="number">1</span>;</span><br><span class="line">	A.x=A.y=S.y=K;S.a[<span class="number">1</span>][K]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=K;i++)A.a[i][i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=K;i&gt;=<span class="number">1</span>;i--)A.a[i][K]=<span class="built_in">read</span>();</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	T=S*<span class="built_in">power</span>(A,n-K);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> t=<span class="built_in">BSGS</span>(<span class="number">3ll</span>,<span class="number">1ll</span>*m,mod);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> g,x,y;</span><br><span class="line">	<span class="built_in">exgcd</span>(T.a[<span class="number">1</span>][K],mod<span class="number">-1</span>,g,x,y);</span><br><span class="line">  	<span class="keyword">if</span>(t%g)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  	<span class="keyword">else</span>&#123;</span><br><span class="line">   		x=(t/g*x%(mod<span class="number">-1</span>)+mod<span class="number">-1</span>)%(mod<span class="number">-1</span>);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">power</span>(<span class="number">3</span>,x,mod));</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p><img src="https://img-blog.csdnimg.cn/20190215213506253.gif" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>贪心</tag>
        <tag>修勾勾</tag>
        <tag>暴力模拟</tag>
        <tag>动态规划</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>OI中常见的线性代数矩阵问题</title>
    <url>/2018/12/29/OI%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于OI中常见的线性代数矩阵问题的复习笔记：</p>
<span id="more"></span>
<p>$\ \ \ \ \ \ \,$对于一个 $n\times m$ 的矩阵 $A$，我们这样定义：</p>
<p>$ A=\begin{bmatrix} a_{(1,1)} &amp;  a_{(1,2)} &amp;\cdots &amp;a_{(1,n)} \\  a_{(2,1)}&amp;  a_{(2,2)} &amp;\cdots &amp;a_{(2,n)} \\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\\  a_{(m,1)}&amp;  a_{(m,2)} &amp;\cdots &amp;a_{(m,n)}  \end{bmatrix} $</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;	</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="type">double</span> a[N][N];</span><br><span class="line">&#125;A;</span><br></pre></td></tr></table></figure>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p>$\ \ \ \ \ \ \,$回忆初中学的多元一次方程（线性方程），我们可以把它当做一个矩阵，然后等号的后面为 $n\times 1$ 的增广矩阵。</p>
<p>$\ \ \ \ \ \ \,$我们解答的过程，就是用方程之间的加减，或者乘一个常数，来消去一些未知数，直到可以直接解出答案。这个消元过程，就是高斯消元。</p>
<p>$\ \ \ \ \ \ \,$变换到矩阵上面，就是通过一些行与行之间的加减，或者乘一个常数，来使得一些位置的值变为 $0$ 。</p>
<p>$\ \ \ \ \ \ \,$我们一般会画成下面两种形态：</p>
<ol>
<li><p>行阶梯式</p>
<p>$ \begin{bmatrix} a &amp;  a &amp;a \\  0&amp;  a &amp;a \\0&amp;  0 &amp;a  \end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$代码如下，复杂度$O(n^3)$</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gauss</span><span class="params">(matrix &amp;A)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A.n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=A.m;j++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(A.a[j][i]))&#123;<span class="built_in">swap</span>(A.a[j],A.a[i]);<span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=A.m;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(A.a[i][i])&lt;eps)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">double</span> f=A.a[j][i]/A.a[i][i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=A.n;k++)A.a[j][k]-=f*A.a[i][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>行最简式</p>
<p>$ \begin{bmatrix} a &amp;  0 &amp;0 \\  0&amp;  a &amp;0 \\0&amp;  0 &amp;a\end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$代码如下，在化成行阶梯式之后，再化成行最简式，复杂度$O(n^3)$</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gauss</span><span class="params">(matrix &amp;A)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A.n;i++)&#123;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=A.m;j++)</span><br><span class="line"> 		<span class="keyword">if</span>(<span class="built_in">fabs</span>(A.a[j][i]))&#123;<span class="built_in">swap</span>(A.a[j],A.a[i]);<span class="keyword">break</span>;&#125;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=A.m;j++)&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">fabs</span>(A.a[i][i])&lt;eps)<span class="keyword">continue</span>;</span><br><span class="line"> 			<span class="type">double</span> f=A.a[j][i]/A.a[i][i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=A.n;k++)A.a[j][k]-=f*A.a[i][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=A.n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(<span class="built_in">fabs</span>(A.a[j][i])&lt;eps)<span class="keyword">continue</span>;</span><br><span class="line"> 		<span class="type">double</span> f=-A.a[i][i]/A.a[j][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=A.n;k++)</span><br><span class="line">    (A.a[j][k]*=f)+=A.a[i][k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵的秩和行列式的值"><a href="#矩阵的秩和行列式的值" class="headerlink" title="矩阵的秩和行列式的值"></a>矩阵的秩和行列式的值</h2><ol>
<li>矩阵的秩</li>
</ol>
<p>$\ \ \ \ \ \ \,$矩阵的秩是A的线性独立的纵（横）列的极大数目，感性地理解，就是在线性方程里的非自由元数目，也就是有用的为多少，我们可以在高斯消元的同时，来求矩阵的秩。</p>
<p>$\ \ \ \ \ \ \ \,$也就是统计行阶梯式的对角线上，不为 $0$ 的数目。</p>
<ol>
<li>行列式的值</li>
</ol>
<p>$\ \ \ \ \ \ \,$行列式虽然与矩阵不同，但是也可以用矩阵表示，暴力求行列式的值复杂度太高，但是我们可以高斯消元过后再求。</p>
<p>$\ \ \ \ \ \ \,$就是行阶梯式的对角线的乘积。</p>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>$\ \ \ \ \ \ \,$那么对于矩阵之间的乘法 $B\times A$，我们这样定义：</p>
<p>$\ \ \ \ \ \ \,$首先，我们需要确定，$B$ 的列数等于$A$ 的行数，既$m_A=n_B$。</p>
<p>$\ \ \ \ \ \ \,$令$S_{(i,j)}=\sum_{k=1}^{m_A}a_{(k,j)}\times b_{(i,k)}$，那么有：</p>
<p>$B\times A=\begin{bmatrix} S_{(1,1)} &amp;  S_{(1,2)} &amp;\cdots &amp;S_{(1,n_A)} \\  S_{(2,1)}&amp;  S_{(2,2)} &amp;\cdots &amp;S_{(2,n_A)} \\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\\  S_{(m_B,1)}&amp;  S_{(m_B,2)} &amp;\cdots &amp;S_{(m_B,n_A)}  \end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$显然是一定满足结合律，不一定满足交换律的，复杂度为$O(n^3)$，直接模拟的，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> matrix <span class="keyword">operator</span> *(<span class="type">const</span> matrix &amp;a,<span class="type">const</span> matrix &amp;b)&#123;</span><br><span class="line">	matrix ret;ret.n=a.n;ret.m=b.m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a.n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.m;j++)&#123;</span><br><span class="line">	  ret.a[i][j]=<span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a.m;k++)</span><br><span class="line">	  ret.a[i][j]+=a.a[i][k]*b.a[k][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵逆元"><a href="#矩阵逆元" class="headerlink" title="矩阵逆元"></a>矩阵逆元</h2><p>$\ \ \ \ \ \ \,$有矩阵乘法，那么就会存在单位元，那么就自然会有逆元的存在。</p>
<p>$\ \ \ \ \ \ \,$单位矩阵，既对角线上面都是 $1$，其余都是 $0$ 的矩阵：</p>
<p>$ I=\begin{bmatrix} 1 &amp;  0 &amp;\cdots &amp;0 \\  0&amp;  1 &amp;\cdots &amp;0 \\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\\  0&amp;  0 &amp;\cdots &amp;1  \end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$根据矩阵乘法的定义，很容易知道$A\times I=A$。</p>
<p>$\ \ \ \ \ \ \,$那么对于矩阵$A$，若是$A\times A’=I$，我们就称 $A’$ 为 $A$ 的逆矩阵。</p>
<p>$\ \ \ \ \ \ \,$对于一个矩阵$A$，肯定可以通过一些行与行之间的加减，或者乘一个常数，既高斯消元，变成 $I$。那么我们令$B=I$，同时和$A$做高斯消元，那么当$A=I$时，$B=A’$了。</p>
<p>$\ \ \ \ \ \ \,$模板如下，返回$0$是无逆元情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Inv</span><span class="params">(matrix A,matrix &amp;B)</span></span>&#123;</span><br><span class="line">	B.n=A.n;B.m=A.m;</span><br><span class="line">	<span class="built_in">memset</span>(B.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(B.a));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A.n;i++)B.a[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A.n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=A.n;j++)</span><br><span class="line">    <span class="keyword">if</span>(A.a[j][i])&#123;</span><br><span class="line">      <span class="built_in">swap</span>(A.a[i],A.a[j]);</span><br><span class="line">			<span class="built_in">swap</span>(B.a[i],B.a[j]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!A.a[i][i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r=<span class="built_in">inv</span>(A.a[i][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=A.n;j++)A.a[i][j]=A.a[i][j]*r%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=A.n;j++)B.a[i][j]=B.a[i][j]*r%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=A.n;j++)</span><br><span class="line">    <span class="keyword">if</span>(j!=i)&#123;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> f=A.a[j][i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=A.n;k++)</span><br><span class="line">      A.a[j][k]=(A.a[j][k]-f*A.a[i][k]%mod+mod)%mod;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=A.n;k++)</span><br><span class="line">      B.a[j][k]=(B.a[j][k]-f*B.a[i][k]%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>矩阵乘法</tag>
        <tag>数学</tag>
        <tag>矩阵求逆</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay各种操作模板大赏</title>
    <url>/2019/01/05/Splay%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%E5%A4%A7%E8%B5%8F/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于Splay操作的复习笔记：</p>
<p>$\ \ \ \ \ \ \ \,$依然的，只记录模板，不讲原理，关于Splay出门左拐百度。</p>
<span id="more"></span>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson son[0][rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson son[1][rt]</span></span><br><span class="line">	<span class="type">int</span> root,cnt;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">2</span>][N],sum[N],val[N],size[N],fa[N];</span><br><span class="line">	<span class="type">int</span> lazy[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>$\tt root$ ：根；</li>
<li>$\tt cnt$ ：下标大小；</li>
<li>$\tt son[0/1][]$ ：左右儿子；</li>
<li>$\tt sum[]$ ：子树大小；</li>
<li>$\tt val[]$ ：节点权值；</li>
<li>$\tt size[]$ ：节点大小；</li>
<li>$\tt fa[]$ ：节点父亲；</li>
<li>$\tt lazy[]$ ：下传标记。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>标记上传 ($pushup$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!rt)<span class="keyword">return</span>;</span><br><span class="line">	sum[rt]=sum[lson]+sum[rson]+size[rt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>标记下传 ($pushdown$)，根据情况会不一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">  	lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">  	lazy[rt]=<span class="number">0</span>;</span><br><span class="line">  	<span class="built_in">swap</span>(lson,rson);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>左旋+右旋 ($rotate$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> y=fa[x];<span class="type">int</span> z=fa[y];</span><br><span class="line">  	<span class="type">int</span> k=son[<span class="number">1</span>][y]==x;</span><br><span class="line">  	son[son[<span class="number">1</span>][z]==y][z]=x;</span><br><span class="line">  	fa[x]=z;</span><br><span class="line">  	son[k][y]=son[k^<span class="number">1</span>][x];</span><br><span class="line">  	fa[son[k^<span class="number">1</span>][x]]=y;</span><br><span class="line">  	son[k^<span class="number">1</span>][x]=y;</span><br><span class="line">  	fa[y]=x;</span><br><span class="line">	<span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将$x$旋转到$goal$下 ($splay$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> goal)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line">  		<span class="type">int</span> y=fa[x];<span class="type">int</span> z=fa[y];</span><br><span class="line">  		<span class="keyword">if</span>(z!=goal)</span><br><span class="line">  		(son[<span class="number">1</span>][z]==y)^(son[<span class="number">1</span>][y]==x)?<span class="built_in">rotate</span>(x):<span class="built_in">rotate</span>(y);</span><br><span class="line">  		<span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(goal==<span class="number">0</span>)root=x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li>新建节点 ($newnode$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=++cnt;</span><br><span class="line">    size[rt]=<span class="number">1</span>;sum[rt]=<span class="number">1</span>;val[rt]=v;</span><br><span class="line">    fa[rt]=f;lson=rson=<span class="number">0</span>;lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>清空节点 ($clean$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    lson=rson=<span class="number">0</span>;fa[rt]=<span class="number">0</span>;</span><br><span class="line">    val[rt]=<span class="number">0</span>;sum[rt]=size[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>建立 ($Build$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> &amp;rt,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span>;</span><br><span class="line">  	<span class="type">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  	rt=<span class="built_in">newnode</span>(f,a[mid]);</span><br><span class="line">  	<span class="built_in">Build</span>(lson,L,mid<span class="number">-1</span>,rt);</span><br><span class="line">  	<span class="built_in">Build</span>(rson,mid+<span class="number">1</span>,R,rt);</span><br><span class="line">  	<span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>插入($Insert$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;root=<span class="built_in">newnode</span>(<span class="number">0</span>,v);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> now=root,rt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(now);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(val[now]==v)&#123;</span><br><span class="line">  			++size[now];</span><br><span class="line">        <span class="built_in">pushup</span>(now);<span class="built_in">pushup</span>(rt);</span><br><span class="line">        <span class="built_in">splay</span>(now,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      rt=now;</span><br><span class="line">      val[rt]&lt;v?now=rson:now=lson;</span><br><span class="line">    	<span class="built_in">pushdown</span>(now);</span><br><span class="line">      <span class="keyword">if</span>(!now)&#123;</span><br><span class="line">        now=<span class="built_in">newnode</span>(rt,v);</span><br><span class="line">  	    val[rt]&lt;v?rson=now:lson=now;</span><br><span class="line">        <span class="built_in">pushup</span>(rt);<span class="built_in">splay</span>(now,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除节点($delete_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_pos</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(size[rt]&gt;<span class="number">1</span>)&#123;--size[rt];<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> now;</span><br><span class="line">    <span class="keyword">if</span>(!lson||!rson)&#123;</span><br><span class="line">      now=rson+lson;<span class="built_in">pushdown</span>(now);</span><br><span class="line">      <span class="keyword">if</span>(!now)&#123;<span class="built_in">clean</span>(rt);root=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="built_in">clean</span>(rt);root=now;fa[now]=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">pushup</span>(now);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    now=<span class="built_in">pre_pos</span>(rt);</span><br><span class="line">    <span class="built_in">pushdown</span>(now);</span><br><span class="line">    <span class="built_in">splay</span>(now,rt);</span><br><span class="line">    fa[now]=<span class="number">0</span>;son[<span class="number">1</span>][now]=rson;fa[rson]=now;</span><br><span class="line">    root=now;<span class="built_in">clean</span>(rt);</span><br><span class="line">    <span class="built_in">pushup</span>(rson);<span class="built_in">pushup</span>(now);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除($Delete$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    v=<span class="built_in">QueryRank_pos</span>(v);</span><br><span class="line">    <span class="built_in">pushdown</span>(v);</span><br><span class="line">    <span class="built_in">delete_pos</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除第k($Delete_QueryRank$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete_QueryRank</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    v=<span class="built_in">Rank_pos</span>(v);</span><br><span class="line">    <span class="built_in">pushdown</span>(v);</span><br><span class="line">    <span class="built_in">delete_pos</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>区间修改（翻转）($revse$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">revse</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	a=<span class="built_in">find</span>(a);</span><br><span class="line">  	b=<span class="built_in">find</span>(b+<span class="number">2</span>);</span><br><span class="line">  	<span class="built_in">splay</span>(a,<span class="number">0</span>);<span class="built_in">splay</span>(b,a);</span><br><span class="line">  	lazy[son[<span class="number">0</span>][son[<span class="number">1</span>][root]]]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h2><ul>
<li>查找某个值的节点编号($QueryRank_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueryRank_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]==x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> rt;&#125; </span><br><span class="line">    	<span class="keyword">if</span>(val[rt]&lt;x)rt=rson;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(val[rt]&gt;x)rt=lson;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查找某个排名的节点编号($Rank_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rank_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> rt=root;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  	<span class="keyword">if</span>(sum[lson]&gt;=x)&#123;rt=lson;<span class="keyword">continue</span>;&#125;</span><br><span class="line">  	x-=sum[lson];</span><br><span class="line">    	<span class="keyword">if</span>(size[rt]&gt;=x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">    	x-=size[rt];</span><br><span class="line">    	rt=rson;</span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查找排名第k的值($QueryRank$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueryRank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(sum[lson]&gt;=x)&#123;rt=lson;<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	x-=sum[lson];</span><br><span class="line">    	<span class="keyword">if</span>(size[rt]&gt;=x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">    	x-=size[rt];</span><br><span class="line">    	rt=rson;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找某个值的排名($Rank$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rank</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]==num)&#123;ans=ans+sum[lson]+<span class="number">1</span>;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> ans;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]&lt;num)ans+=sum[lson]+size[rt],rt=rson;</span><br><span class="line">     	<span class="keyword">else</span> <span class="keyword">if</span>(val[rt]&gt;num)rt=lson;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>集合内前驱的节点编号($pre_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(!(rt=son[<span class="number">0</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">while</span>(rson)<span class="built_in">pushdown</span>(rt),rt=rson;</span><br><span class="line">    <span class="keyword">return</span> rt;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>集合内后继的节点编号($nex_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nex_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(!(rt=son[<span class="number">1</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">while</span>(lson)<span class="built_in">pushdown</span>(rt),rt=lson;</span><br><span class="line">    <span class="keyword">return</span> rt;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>集合内前驱的值($pre$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(!(rt=son[<span class="number">0</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">while</span>(rson)<span class="built_in">pushdown</span>(rt),rt=rson;</span><br><span class="line">    <span class="keyword">return</span> val[rt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>集合内后继的值($nex$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(!(rt=son[<span class="number">1</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">while</span>(lson)<span class="built_in">pushdown</span>(rt),rt=lson;</span><br><span class="line">    <span class="keyword">return</span> val[rt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>前驱($Numpre$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Numpre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Insert</span>(x);</span><br><span class="line">    <span class="type">int</span> y=x;x=<span class="built_in">QueryRank_pos</span>(x);</span><br><span class="line">    <span class="type">int</span> ls=<span class="built_in">pre</span>(x);</span><br><span class="line">    <span class="built_in">Delete</span>(y);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>后继($Numnex$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Numnex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Insert</span>(x);</span><br><span class="line">    <span class="type">int</span> y=x;x=<span class="built_in">QueryRank_pos</span>(x);</span><br><span class="line">    <span class="type">int</span> ls=<span class="built_in">nex</span>(x);</span><br><span class="line">    <span class="built_in">Delete</span>(y);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查找某个值的节点编号($find$)，不改变结构<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> rt=root;</span><br><span class="line">  	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  		<span class="keyword">if</span>(sum[lson]&gt;=k)rt=lson;</span><br><span class="line">  		<span class="keyword">else</span> <span class="keyword">if</span>(sum[lson]+<span class="number">1</span>==k)<span class="keyword">return</span> rt;</span><br><span class="line">  		<span class="keyword">else</span> k-=sum[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="完整模板"><a href="#完整模板" class="headerlink" title="完整模板"></a>完整模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson son[0][rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson son[1][rt]</span></span><br><span class="line">	<span class="type">int</span> root,cnt;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">2</span>][N],sum[N],val[N],size[N],fa[N];</span><br><span class="line">  	<span class="type">bool</span> lazy[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">  		lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">  		lazy[rt]=<span class="number">0</span>;</span><br><span class="line">  		<span class="built_in">swap</span>(lson,rson);</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">if</span>(!rt)<span class="keyword">return</span>;</span><br><span class="line">	  	sum[rt]=sum[lson]+sum[rson]+size[rt];</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	  	<span class="type">int</span> y=fa[x];<span class="type">int</span> z=fa[y];</span><br><span class="line">	  	<span class="type">int</span> k=son[<span class="number">1</span>][y]==x;</span><br><span class="line">	  	son[son[<span class="number">1</span>][z]==y][z]=x;</span><br><span class="line">	  	fa[x]=z;</span><br><span class="line">	  	son[k][y]=son[k^<span class="number">1</span>][x];</span><br><span class="line">	  	fa[son[k^<span class="number">1</span>][x]]=y;</span><br><span class="line">	  	son[k^<span class="number">1</span>][x]=y;</span><br><span class="line">	  	fa[y]=x;</span><br><span class="line">	  	<span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> goal)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line">	  		<span class="type">int</span> y=fa[x];<span class="type">int</span> z=fa[y];</span><br><span class="line">	  		<span class="keyword">if</span>(z!=goal)</span><br><span class="line">	  		(son[<span class="number">1</span>][z]==y)^(son[<span class="number">1</span>][y]==x)?<span class="built_in">rotate</span>(x):<span class="built_in">rotate</span>(y);</span><br><span class="line">	  		<span class="built_in">rotate</span>(x);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span>(goal==<span class="number">0</span>)root=x;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	    <span class="type">int</span> rt=++cnt;</span><br><span class="line">	    size[rt]=<span class="number">1</span>;sum[rt]=<span class="number">1</span>;val[rt]=v;</span><br><span class="line">	    fa[rt]=f;lson=rson=<span class="number">0</span>;lazy[rt]=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">return</span> rt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	    lson=rson=<span class="number">0</span>;fa[rt]=<span class="number">0</span>;</span><br><span class="line">	    val[rt]=<span class="number">0</span>;sum[rt]=size[rt]=<span class="number">0</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> &amp;rt,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span>;</span><br><span class="line">	  	<span class="type">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	  	rt=<span class="built_in">newnode</span>(f,a[mid]);</span><br><span class="line">	  	<span class="built_in">Build</span>(lson,L,mid<span class="number">-1</span>,rt);</span><br><span class="line">	  	<span class="built_in">Build</span>(rson,mid+<span class="number">1</span>,R,rt);</span><br><span class="line">	  	<span class="built_in">pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(!root)&#123;root=<span class="built_in">newnode</span>(<span class="number">0</span>,v);<span class="keyword">return</span>;&#125;</span><br><span class="line">    	<span class="type">int</span> now=root,rt=<span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">pushdown</span>(now);</span><br><span class="line">   		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      		<span class="keyword">if</span>(val[now]==v)&#123;</span><br><span class="line">	  			++size[now];</span><br><span class="line">	        	<span class="built_in">pushup</span>(now);<span class="built_in">pushup</span>(rt);</span><br><span class="line">	        	<span class="built_in">splay</span>(now,<span class="number">0</span>);</span><br><span class="line">	        	<span class="keyword">break</span>;</span><br><span class="line">	      	&#125;</span><br><span class="line">	      	rt=now;</span><br><span class="line">	      	val[rt]&lt;v?now=rson:now=lson;</span><br><span class="line">	    	<span class="built_in">pushdown</span>(now);</span><br><span class="line">	      	<span class="keyword">if</span>(!now)&#123;</span><br><span class="line">	        	now=<span class="built_in">newnode</span>(rt,v);</span><br><span class="line">	  	    	val[rt]&lt;v?rson=now:lson=now;</span><br><span class="line">	        	<span class="built_in">pushup</span>(rt);<span class="built_in">splay</span>(now,<span class="number">0</span>);</span><br><span class="line">	        	<span class="keyword">break</span>;</span><br><span class="line">	      	&#125;</span><br><span class="line">   	 	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">QueryRank_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="type">int</span> rt=root;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      		<span class="keyword">if</span>(val[rt]==x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> rt;&#125; </span><br><span class="line">      		<span class="keyword">if</span>(val[rt]&lt;x)rt=rson;</span><br><span class="line">      		<span class="keyword">else</span> <span class="keyword">if</span>(val[rt]&gt;x)rt=lson;</span><br><span class="line">    	&#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Rank_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      <span class="keyword">if</span>(sum[lson]&gt;=x)&#123;rt=lson;<span class="keyword">continue</span>;&#125;</span><br><span class="line">      x-=sum[lson];</span><br><span class="line">      <span class="keyword">if</span>(size[rt]&gt;=x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">      x-=size[rt];</span><br><span class="line">      rt=rson;</span><br><span class="line">    &#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">QueryRank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="type">int</span> rt=root;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">     		<span class="keyword">if</span>(sum[lson]&gt;=x)&#123;rt=lson;<span class="keyword">continue</span>;&#125;</span><br><span class="line">     		x-=sum[lson];</span><br><span class="line">      		<span class="keyword">if</span>(size[rt]&gt;=x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">      		x-=size[rt];</span><br><span class="line">      		rt=rson;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">Rank</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    	<span class="type">int</span> rt=root,ans=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      		<span class="keyword">if</span>(val[rt]==num)&#123;ans=ans+sum[lson]+<span class="number">1</span>;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> ans;&#125;</span><br><span class="line">     		<span class="keyword">if</span>(val[rt]&lt;num)ans+=sum[lson]+size[rt],rt=rson;</span><br><span class="line">      		<span class="keyword">else</span> <span class="keyword">if</span>(val[rt]&gt;num)rt=lson;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">pre_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    	<span class="built_in">pushdown</span>(x);</span><br><span class="line">    	<span class="keyword">if</span>(!(rt=son[<span class="number">0</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    	<span class="keyword">while</span>(rson)<span class="built_in">pushdown</span>(rt),rt=rson;</span><br><span class="line">    	<span class="keyword">return</span> rt;	</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">nex_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    	<span class="built_in">pushdown</span>(x);</span><br><span class="line">    	<span class="keyword">if</span>(!(rt=son[<span class="number">1</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    	<span class="keyword">while</span>(lson)<span class="built_in">pushdown</span>(rt),rt=lson;</span><br><span class="line">    	<span class="keyword">return</span> rt;	</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    	<span class="built_in">pushdown</span>(x);</span><br><span class="line">    	<span class="keyword">if</span>(!(rt=son[<span class="number">0</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    	<span class="keyword">while</span>(rson)<span class="built_in">pushdown</span>(rt),rt=rson;</span><br><span class="line">    	<span class="keyword">return</span> val[rt];</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">nex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    	<span class="built_in">pushdown</span>(x);</span><br><span class="line">    	<span class="keyword">if</span>(!(rt=son[<span class="number">1</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    	<span class="keyword">while</span>(lson)<span class="built_in">pushdown</span>(rt),rt=lson;</span><br><span class="line">    	<span class="keyword">return</span> val[rt];</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">delete_pos</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(rt,<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">if</span>(size[rt]&gt;<span class="number">1</span>)&#123;--size[rt];<span class="keyword">return</span>;&#125;</span><br><span class="line">    	<span class="type">int</span> now;</span><br><span class="line">    	<span class="keyword">if</span>(!lson||!rson)&#123;</span><br><span class="line">      		now=rson+lson;<span class="built_in">pushdown</span>(now);</span><br><span class="line">      		<span class="keyword">if</span>(!now)&#123;<span class="built_in">clean</span>(rt);root=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">      		<span class="built_in">clean</span>(rt);root=now;fa[now]=<span class="number">0</span>;</span><br><span class="line">      		<span class="built_in">pushup</span>(now);<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	now=<span class="built_in">pre_pos</span>(rt);</span><br><span class="line">    	<span class="built_in">pushdown</span>(now);</span><br><span class="line">    	<span class="built_in">splay</span>(now,rt);</span><br><span class="line">    	fa[now]=<span class="number">0</span>;son[<span class="number">1</span>][now]=rson;fa[rson]=now;</span><br><span class="line">    	root=now;<span class="built_in">clean</span>(rt);</span><br><span class="line">    	<span class="built_in">pushup</span>(rson);<span class="built_in">pushup</span>(now);	</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    	v=<span class="built_in">QueryRank_pos</span>(v);</span><br><span class="line">    	<span class="built_in">pushdown</span>(v);</span><br><span class="line">    	<span class="built_in">delete_pos</span>(v);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">Delete_QueryRank</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    	v=<span class="built_in">Rank_pos</span>(v);</span><br><span class="line">    	<span class="built_in">pushdown</span>(v);</span><br><span class="line">    	<span class="built_in">delete_pos</span>(v);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">Numpre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">Insert</span>(x);</span><br><span class="line">    	<span class="type">int</span> y=x;x=<span class="built_in">QueryRank_pos</span>(x);</span><br><span class="line">    	<span class="type">int</span> ls=<span class="built_in">pre</span>(x);</span><br><span class="line">    	<span class="built_in">Delete</span>(y);</span><br><span class="line">    	<span class="keyword">return</span> ls;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">Numnex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">Insert</span>(x);</span><br><span class="line">    	<span class="type">int</span> y=x;x=<span class="built_in">QueryRank_pos</span>(x);</span><br><span class="line">    	<span class="type">int</span> ls=<span class="built_in">nex</span>(x);</span><br><span class="line">    	<span class="built_in">Delete</span>(y);</span><br><span class="line">    	<span class="keyword">return</span> ls;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  		<span class="type">int</span> rt=root;</span><br><span class="line">  		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  			<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  			<span class="keyword">if</span>(sum[lson]&gt;=k)rt=lson;</span><br><span class="line">  			<span class="keyword">else</span> <span class="keyword">if</span>(sum[lson]+<span class="number">1</span>==k)<span class="keyword">return</span> rt;</span><br><span class="line">  			<span class="keyword">else</span> k-=sum[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">revse</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		a=<span class="built_in">find</span>(a);</span><br><span class="line">  		b=<span class="built_in">find</span>(b+<span class="number">2</span>);</span><br><span class="line">  		<span class="built_in">splay</span>(a,<span class="number">0</span>);<span class="built_in">splay</span>(b,a);</span><br><span class="line">  		lazy[son[<span class="number">0</span>][son[<span class="number">1</span>][root]]]^=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Spl;</span><br></pre></td></tr></table></figure>
<h2 id="两个模板题："><a href="#两个模板题：" class="headerlink" title="两个模板题："></a>两个模板题：</h2><ul>
<li><a href="https://www.luogu.org/problemnew/show/P3369">P3369 【模板】普通平衡树</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span>-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;Spl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">  	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    	<span class="type">int</span> opt=<span class="built_in">read</span>(),x=<span class="built_in">read</span>();</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;Spl.<span class="built_in">Insert</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;Spl.<span class="built_in">Delete</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Spl.<span class="built_in">Rank</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">4</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Spl.<span class="built_in">QueryRank</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">5</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Spl.<span class="built_in">Numpre</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">6</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Spl.<span class="built_in">Numnex</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://www.luogu.org/problemnew/show/P3391">P3391 【模板】文艺平衡树（Splay）</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span>-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;Spl;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  	Spl.<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  	<span class="keyword">if</span>(Spl.lson)<span class="built_in">write</span>(Spl.lson);</span><br><span class="line">  	<span class="keyword">if</span>(Spl.val[rt]&gt;<span class="number">1</span>&amp;&amp;Spl.val[rt]&lt;n+<span class="number">2</span>)</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Spl.val[rt]<span class="number">-1</span>);</span><br><span class="line">  	<span class="keyword">if</span>(Spl.rson)<span class="built_in">write</span>(Spl.rson); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++)a[i]=i;</span><br><span class="line"> 	Spl.<span class="built_in">Build</span>(Spl.root,<span class="number">1</span>,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"> 	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    	<span class="type">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">  		Spl.<span class="built_in">revse</span>(l,r);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="built_in">write</span>(Spl.root);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2016]生成魔咒 简易题解</title>
    <url>/2019/03/12/SDOI2016-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P4070">[SDOI2016]生成魔咒</a></p>
<span id="more"></span>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>$\ \ \ \ \ \ \,$一看这个题目：</p>
<ul>
<li>只是单调在后面加字符；</li>
<li>只是统计子串数量。</li>
</ul>
<p>$\ \ \ \ \ \ \,$哇！这不是 $SAM$ 的裸题吗，周道感动得要哭了，根据<a href="/2018/12/29/后缀自动机/">【后缀自动机的性质】</a>：</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \ \,$点$i$上面表示子串的数量为:$len[fa[i]]−len[i]$<br>$\ \ \ \ \ \ \,$所以我们每次插入一个点，把新加的子串个数记累加就好了。</p>
<p>$\ \ \ \ \ \ \,$但是一看这个字符集大小……</p>
<p>$\ \ \ \ \ \ \,$不过我们知道，虽然字符集这么大，但是每个节点上面的儿子个数却是远远达不到字符集那么大的，所以我们试着用 $map$ 代替数组来记录儿子：</p>
<p>$\ \ \ \ \ \ \,$然后……就过了……</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Suffix_Automaton</span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;ch[N];</span><br><span class="line">  	<span class="type">int</span> last=<span class="number">1</span>,cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> len[N],fa[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> np=++cnt,p=last;last=np;</span><br><span class="line">		len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;p&amp;&amp;!ch[p][c];p=fa[p])ch[p][c]=np;</span><br><span class="line">		<span class="keyword">if</span>(!p)fa[np]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> q=ch[p][c];</span><br><span class="line">			<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>)fa[np]=q;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> nq=++cnt;len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">				ch[nq]=ch[q];</span><br><span class="line">				fa[nq]=fa[q];fa[q]=fa[np]=nq;</span><br><span class="line">				<span class="keyword">for</span>(;ch[p][c]==q;p=fa[p])ch[p][c]=nq;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=<span class="number">1ll</span>*len[np]-len[fa[np]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Sam;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="built_in">read</span>();</span><br><span class="line">		Sam.<span class="built_in">insert</span>(a);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>tarjian算法的运用</title>
    <url>/2019/01/02/tarjian%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$tarjian算法及其相关算法的复习笔记：</p>
<span id="more"></span>
<h2 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h2><p>$\ \ \ \ \ \ \ \,$对于一个有向图，能互相到达的点在一个连通分量，很多时候一个连通分量的点对答案没有影响，或者可以统一安排，那么我们就用tarjan算法把它们缩在一起。</p>
<p>$\ \ \ \ \ \ \ \,$这样就把有向图转换为了一个DAG，会方便处理很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> U[N],V[N],p;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;U[++p]=a;V[p]=b;G[a].<span class="built_in">push_back</span>(b);&#125;</span><br><span class="line"><span class="type">int</span> sta[N],top;</span><br><span class="line"><span class="type">int</span> low[N],dfn[N],tim;</span><br><span class="line"><span class="type">int</span> col[N],mark;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  sta[++top]=x;</span><br><span class="line">  low[x]=dfn[x]=++tim;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!dfn[v])<span class="built_in">tarjan</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(!col[v])low[x]=<span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">    mark++; </span><br><span class="line">    <span class="keyword">while</span>(sta[top+<span class="number">1</span>]!=x)col[sta[top]]=mark,top--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main():</span></span><br><span class="line"><span class="comment">//  for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//  if(!dfn[i]) tarjan(i);</span></span><br></pre></td></tr></table></figure>
<h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><p>$\ \ \ \ \ \ \ \,$在一个无向图中，去掉一个点，使得图不连通，这个点就叫割点（sta[]中）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;G[a].<span class="built_in">push_back</span>(b);G[b].<span class="built_in">push_back</span>(a);&#125;</span><br><span class="line"><span class="type">int</span> sta[N],top;</span><br><span class="line"><span class="type">int</span> low[N],dfn[N],tim;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  low[x]=dfn[x]=++tim;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v,rt);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">      <span class="keyword">if</span>(low[v]&gt;=dfn[x]&amp;&amp;x!=rt&amp;&amp;used[x]==<span class="number">0</span>)</span><br><span class="line">      &#123;sta[++top]=x;used[x]=<span class="number">1</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(x==rt)cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    low[x]=<span class="built_in">min</span>(low[x],dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x==rt&amp;&amp;cnt&gt;=<span class="number">2</span>&amp;&amp;used[x]==<span class="number">0</span>)</span><br><span class="line">  &#123;sta[++top]=x;used[x]=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main():</span></span><br><span class="line"><span class="comment">//  for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//  if(!dfn[i]) tarjan(i,i);</span></span><br></pre></td></tr></table></figure>
<h2 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h2><p>$\ \ \ \ \ \ \ \,$专门处理仙人掌的做法，把一个环转换为一个方点，把一个仙人掌转换为一棵树，方便处理：</p>
<p>$\ \ \ \ \ \ \ \,$（方点之间连接的圆点为割点）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sta[N],top,size,tim,dfn[N],low[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],E[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;G[a].<span class="built_in">push_back</span>(b);G[b].<span class="built_in">push_back</span>(a);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;E[a].<span class="built_in">push_back</span>(b);E[b].<span class="built_in">push_back</span>(a);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tim;</span><br><span class="line">  sta[++top]=x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v),low[x]=<span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">      <span class="keyword">if</span>(low[v]&gt;=dfn[x])&#123;</span><br><span class="line">        ++size;</span><br><span class="line">        <span class="keyword">while</span>(sta[top+<span class="number">1</span>]!=v)<span class="built_in">add2</span>(sta[top],size),top--;</span><br><span class="line">        <span class="built_in">add2</span>(x,size);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		low[x]=<span class="built_in">min</span>(low[x],dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>图论</tag>
        <tag>圆方树</tag>
        <tag>Tarjian</tag>
        <tag>连通分量</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/14/hello-world/</url>
    <content><![CDATA[<p>&#8195; &#8195;忙乎了6天，终于算是把这个Blog搭好了，同时也把之前自己写过的东西搬了过来。说实话，川北家里，春节期间气候不是很好，还是怪冷的。每天的工作时间还是比较有限，效率也不是很高，不过好在还是在开学前把该学的东西学完，东西也做出来了。</p>
<p>&#8195; &#8195;感觉很久没有写过什么东西了呢，那么现在还是来做一个最后的总结，记录一下这几天都忙了些什么东西。</p>
<span id="more"></span>
<h2 id="为什么要搭建这个Blog"><a href="#为什么要搭建这个Blog" class="headerlink" title="为什么要搭建这个Blog"></a>为什么要搭建这个Blog</h2><h3 id="首先是对寒假自学成果的检验"><a href="#首先是对寒假自学成果的检验" class="headerlink" title="首先是对寒假自学成果的检验"></a>首先是对寒假自学成果的检验</h3><p>&#8195; &#8195;学校平台能力有限，教学进度要照顾其他同学。而我作为一个前OI选手，已经掌握了一部分代码算法知识，也有了较为成熟的计算机思维，学校的教学方式显然是很难喂饱我的。大学已经过去一年半，这一年半里我专业知识方面的进步很小，也没有多少实战经验。之前报了学校的ACM队，但是因为家庭和个人原因没能持续参与，不过也不算什么大不了的吧！我在高中的时候已经经过系统的算法竞赛培训，再在大学继续搞的话，考虑到学校平台的问题，投入的时间和得到的收益很难匹配，属于是既学不到东西，又拿不到牌子，还很难得到实战经验。</p>
<p>&#8195; &#8195;最开始我还是很焦虑的。在<strong>Ferric</strong>的建议下，我开始着重进行较为系统的自学，并希望做出东西来证明学习成果。</p>
<p>&#8195; &#8195;于是在这个假期，我补了计算机基础：OS，计网，机组和数据库。然后学习了其他语言：python和java，方便我后期进行APK甚至HPK的开发工作。然后根据自己的兴趣，学习了HTML，CSS，Javascript三件套并做了相应的练习。</p>
<p>&#8195; &#8195;于是就有了做这个Blog的想法，这也是<strong>Ferric</strong>推荐的，他希望我成为一个优秀的计算机从业者。</p>
<h3 id="其次是对个人履历的丰富"><a href="#其次是对个人履历的丰富" class="headerlink" title="其次是对个人履历的丰富"></a>其次是对个人履历的丰富</h3><p>&#8195; &#8195;搭建个人Blog应该算是一个计算机从业者的入门门票，这在个人简历中比很多大学社团活动有用多了，而且可以来记录并展示你的学习过程，你掌握的技能，并分享你对事件的看法，分享你的技术。就算是忘了什么东西，也可以很方便的找回来。可谓是一举多得，性价比超高。</p>
<h3 id="最后是对自己的激励"><a href="#最后是对自己的激励" class="headerlink" title="最后是对自己的激励"></a>最后是对自己的激励</h3><p>&#8195; &#8195;学海无涯，尤其是在计算机领域，持续学习是非常有必要的。技术迭代非常快，要持续学习才能保证自己的优势。未来我会计划在计算机领域进行更广更深入的学习，这个Blog就是对我自己的激励，看着自己的日志数量越来越多，也是对自己的一个肯定。</p>
<h2 id="关于Blog的搭建过程"><a href="#关于Blog的搭建过程" class="headerlink" title="关于Blog的搭建过程"></a>关于Blog的搭建过程</h2><h3 id="为什么选择Hexo和NexT"><a href="#为什么选择Hexo和NexT" class="headerlink" title="为什么选择Hexo和NexT"></a>为什么选择<strong>Hexo</strong>和<strong>NexT</strong></h3><p>&#8195; &#8195;要搭建个人Blog，首先就遇到了第一个选择，是搭建动态网站还是静态网站？在<strong>Ferric</strong>的建议下，我选择了静态网站，因为个人blog体量不大，静态网站足以满足要求，还不用搭建数据库，非常方便。而且现在静态网站Blog非常成熟，有很多现成的可以利用，就比如<strong>Hexo</strong>，这也是<strong>Ferric</strong>推荐我使用的。</p>
<p>&#8195; &#8195;然后便是具体搭建和个性化。<strong>Hexo</strong>的主题非常多，但却没有能让我非常满意的。最终还是选择了<strong>NexT</strong>的主题，原因很简单，<strong>Next</strong>主题使用群体多，而且可供选择样式也不少，整体简洁大方，方便进行二次魔改，修改部分CSS代码便可让人满意。于是整体的方向就定了下来。</p>
<h3 id="设计时的整体想法"><a href="#设计时的整体想法" class="headerlink" title="设计时的整体想法"></a>设计时的整体想法</h3><p>&#8195; &#8195;最开始的时候，我都只是按照自己的想法随便修修改改，最终的结果也很难让自己满意，于是便选择想在互联网寻找现成的设计来参考。</p>
<p>&#8195; &#8195;最终选上了华为的<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/overview-0000001053563071"><strong>HarmonyOS设计规范</strong></a>，其相关资料的开源和设计的现代性吸引了我。再加上华为鸿蒙这一热点，让我最终选择它作为我的Blog设计指导。</p>
<p>&#8195; &#8195;按照规范，我为盒子都做了圆角，在每个卡片元素下都做了阴影。还为每个嵌套元素做了圆角匹配。字体也选择了文档推荐的<strong>HarmonyOS_Sans</strong>。对于配色的选择，我用了<strong>HarmonyOS</strong>的主题色：</p>
<p><img src="/images/material/color0A59F7.png" alt=""> <img src="/images/material/colorF1F3F5.png" alt=""></p>
<p>&#8195; &#8195;在功能方面，感知较强的是我为Blog在右下角添加了返回主界面的按钮。当然还有<strong>Hexo</strong>和<strong>NexT</strong>自带的功能，必装的插件：如对Latex的支持，目录跳转，返回顶部，归档，标签等等。</p>
<h3 id="搭建时遇到的困难"><a href="#搭建时遇到的困难" class="headerlink" title="搭建时遇到的困难"></a>搭建时遇到的困难</h3><p>&#8195; &#8195;由于是利用了现成的静态Blog<strong>Hexo</strong>和<strong>NexT</strong>，所以修改别人的代码就是很烦的一件事情，经常修改CSS不能达到我想要的效果，有的时候只能选择更换设计思维妥协一下。或者是js的使用方法与我之前的Blog文章内容不能匹配渲染失败，或者是使用个别浏览器打开导致卡顿。图标库的版本也比较<br>低，有些需要的图标没有。</p>
<p>&#8195; &#8195;还有就是<strong>Hexo</strong>和<strong>NexT</strong>也比较老了，和最新版本难以匹配有的时候要去猜测文档的意思。</p>
<p>&#8195; &#8195;那么在这里再次感谢<strong>Ferric</strong>的帮助，帮我解决了很多问题。</p>
<h3 id="未实现的遗憾"><a href="#未实现的遗憾" class="headerlink" title="未实现的遗憾"></a>未实现的遗憾</h3><p>&#8195; &#8195;想做一个一键深色模式，但是苦于工作量过高就先暂时搁置了。</p>
<p>&#8195; &#8195;想用弥散光做background，但是不能CSS直接做出来，需要设计软件生成，也就换成了一个普通的图片。</p>
<p>&#8195; &#8195;想在文章里面插入一个HTML的窗口，但是也不知道为什么不支持，为了避免麻烦也暂时搁置了。</p>
<h2 id="之后打算干点什么"><a href="#之后打算干点什么" class="headerlink" title="之后打算干点什么"></a>之后打算干点什么</h2><p>&#8195; &#8195;在个人层面，Blog上面的东西并不能完全代表我，我也不打算什么事情都往Blog什么写。我希望Blog上面只留下计算机相关内容。于是我还需要一个个人主页。</p>
<p>&#8195; &#8195;我打算本站的<strong>关于</strong>界面可以链接过去，在个人主页内也应该可以用一个链接指回来。但个人主页目前只是在构想期间，所以我在<strong>关于</strong>界面留下了一个<del>情人节</del>小彩蛋。</p>
<p>&#8195; &#8195;我还是一个会画画的人，所以我还计划做一个个人画廊，这个就计划做一个动态网页，来记录我的热爱。<del>想必是很多福瑞</del></p>
<p>&#8195; &#8195;同时我还有画漫画的梦想，我想利用计算机技术，做一个表现力更强的漫画，目前这个项目也是在计划中了：</p>
<p><img src="/images/material/SamsarA.png" alt=""></p>
<p>&#8195; &#8195;相信不久之后我就可以开始这些项目的开发，我也会及时同步进度和内容到本站。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>&#8195; &#8195;那么这个Blog的开发现在就告一段落，非常感谢<strong>Ferric</strong>的帮助和<strong>Hexo</strong>，<strong>NexT</strong>的支持。</p>
<p>&#8195; &#8195;今天刚好是情人节，最后就祝<strong>Ferric</strong>节日快乐😘。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>关于整型异或的线性基</title>
    <url>/2018/12/29/%E5%85%B3%E4%BA%8E%E6%95%B4%E5%9E%8B%E5%BC%82%E6%88%96%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于线性基的复习笔记：</p>
<p>$\ \ \ \ \ \ \,$基（$\tt basis$）是线性代数中的一个概念，它是描述、刻画向量空间的基本工具。而在现行的 OI 题目中，通常在利用基在异或空间中的一些特殊性质来解决题目，而这一类题目所涉及的知识点被称作线性基。</p>
<span id="more"></span>
<p>$\ \ \ \ \ \ \,$具体证明先不谈，<a href="https://blog.sengxian.com/algorithms/linear-basis">【给个链接】</a>，下面主要讲关于整型异或的线性基的代码实现和操作。</p>
<p>$\ \ \ \ \ \ \,$简单来说，线性基是解决一系列整形集合异或值的轻量数据结构，主要思想在于贪心，空间复杂度很低，只有$\log n$的级别（$n$为元素大小上界）:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Linear_Base</span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> a[Lim+<span class="number">10</span>];</span><br><span class="line">&#125;LB;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$他支持的操作有（$n$为元素大小上界）：</p>
<ol>
<li><p>向集合中插入一个整形元素（$O(\log n)$）</p>
</li>
<li><p>询问集合的中元素是否可以相互异或出某个整形（$O(\log n)$）</p>
</li>
<li><p>询问集合的中元素与某个整形可以相互异或出的最大值（$O(\log n)$）</p>
</li>
<li><p>询问集合的中元素与某个整形可以相互异或出的最小值（$O(\log n)$）</p>
</li>
<li><p>询问集合的中元素可以相互异或出的第$k$大值（$O(\log^2 n)$）</p>
</li>
<li><p>合并两个集合(线性基)（$O(\log^2 n)$）</p>
</li>
</ol>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>$\ \ \ \ \ \ \,$考虑按位异或其实只与每一个位数有关，并且要这个位数为$1$的时候才会造成贡献。问题是如何用 $\log n$ 的空间来描述整个集合的异或集合，我们的想法是：</p>
<ul>
<li><p>如果这个数前面高数位的值可以被已有集合表达，那么我们用插入的数异或掉这个可以表达的数，就可以把插入的数化为低位。</p>
</li>
<li><p>如果这个数前面高数位的值不能被已有集合表达，那么我们就顺势插入集合，然后弹出。</p>
</li>
</ul>
<p>$\ \ \ \ \ \ \,$这样我们就可以保证，集合的异或值都可以表达出来，没有遗漏，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=Lim;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a[i])&#123;a[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> x^=a[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询是否存在"><a href="#查询是否存在" class="headerlink" title="查询是否存在"></a>查询是否存在</h2><p>$\ \ \ \ \ \ \,$在插入完成后，线性基的每一一个位置存放的都是这个集合可以通过异或表达的元素，并且最高位就是这个数位，于是查询存在就边成了：</p>
<ul>
<li><p>如果询问的数在这个数位为$1$,那么要表达询问的数的一个元素，肯定是这个位数上的元素，于是我们拿询问的数去异或他，询问的数将会成功减少至少一个数位。</p>
</li>
<li><p>如果询问的数在这个数位为$0$,那么要表达询问的数的元素肯定没有这个位数上的元素，不然后面再怎么异或，这个位数就消不掉了，所以直接跳过这种位数。</p>
</li>
</ul>
<p>$\ \ \ \ \ \ \,$当然了，要是最后把要查询的这个数都异或为$0$了,这个数当然就存在了，若是异或到后面的位数上的元素都是空的了还没有归$0$，那么肯定就不存在了，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=Lim;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a[i])<span class="keyword">break</span>;</span><br><span class="line">    x^=a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询最大"><a href="#查询最大" class="headerlink" title="查询最大"></a>查询最大</h2><p>$\ \ \ \ \ \ \,$这个比较好想，我们依然从高位到地位枚举，若是询问的数这一个数位的元素异或起来变大了，那么就异或起来，最后便可以得到答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">querymax</span><span class="params">(<span class="type">long</span> <span class="type">long</span> res)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=Lim;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  <span class="keyword">if</span>((res^a[i])&gt;res)res^=a[i];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询最小"><a href="#查询最小" class="headerlink" title="查询最小"></a>查询最小</h2><p>$\ \ \ \ \ \ \,$查询最小的话，我们的策略就需要改变一下了，应该是尽量把为搞数位降成低数位，那么我们的操作和插入的操作其实差不多：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">querymax</span><span class="params">(<span class="type">long</span> <span class="type">long</span> res)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=Lim;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  <span class="keyword">if</span>(res&amp;(<span class="number">1ll</span>&lt;&lt;i))res^=a[i];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询组合第-k-大"><a href="#查询组合第-k-大" class="headerlink" title="查询组合第$k$大"></a>查询组合第$k$大</h2><p>$\ \ \ \ \ \ \,$这个是最复杂的操作了，简单说一下就好了，主要记板子，主要的想法是我们需要将每一位数的元素后面的位数也消掉，那么我们每一数位的元素就差不多变成了$2^i$，然后把$k$位数拆分就好了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">querykth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> tmp[Lim+<span class="number">10</span>],res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=Lim;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)<span class="keyword">if</span>(a[i]&amp;(<span class="number">1ll</span>&lt;&lt;j))a[i]^=a[j];</span><br><span class="line">    <span class="keyword">if</span>(a[i])tmp[cnt++]=a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)<span class="keyword">if</span>(k&amp;(<span class="number">1ll</span>&lt;&lt;i))res^=tmp[i];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>$\ \ \ \ \ \ \,$合并的话，就是把一个线性基里面整合的元素再插入另一个就好了呗：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> Linear_Base &amp;other)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=Lim;i++) <span class="built_in">insert</span>(other.a[i]);&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整模板代码："><a href="#完整模板代码：" class="headerlink" title="完整模板代码："></a>完整模板代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Linear_Base</span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> a[Lim+<span class="number">10</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=Lim;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">      <span class="keyword">if</span>(!a[i])&#123;a[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="keyword">else</span> x^=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=Lim;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">      <span class="keyword">if</span>(!a[i])<span class="keyword">break</span>;</span><br><span class="line">      x^=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x&gt;<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">querymax</span><span class="params">(<span class="type">long</span> <span class="type">long</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=Lim;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>((res^a[i])&gt;res)res^=a[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">querymin</span><span class="params">(<span class="type">long</span> <span class="type">long</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=Lim;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(res&amp;(<span class="number">1ll</span>&lt;&lt;i))res^=a[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">querykth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp[Lim+<span class="number">10</span>],res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=Lim;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)<span class="keyword">if</span>(a[i]&amp;(<span class="number">1ll</span>&lt;&lt;j))a[i]^=a[j];</span><br><span class="line">      <span class="keyword">if</span>(a[i])tmp[cnt++]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)<span class="keyword">if</span>(k&amp;(<span class="number">1ll</span>&lt;&lt;i))res^=tmp[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> Linear_Base &amp;other)</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=Lim;i++) <span class="built_in">insert</span>(other.a[i]);&#125;</span><br><span class="line">&#125;LB;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f9d91e62d79d8b79f4252ecb6a8ead32.gif" alt=""></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>异或</tag>
        <tag>修勾勾</tag>
        <tag>数学</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>关于DP的优化</title>
    <url>/2018/12/29/%E5%85%B3%E4%BA%8EDP%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$动态规划及其相优化方法的复习笔记：</p>
<span id="more"></span>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>$\ \ \ \ \ \ \,$很多时候我们的dp式子如下形式，是一个递推形式$f_{(m,n)}$：</p>
<p>$f_{(i,j)}=a_{(1,j)}\cdot f_{(i-1,1)}+a_{(2,j)}\cdot f_{(i-1,2)}+\cdots+a_{(n,j)}\cdot f_{(i-1,n)}$</p>
<p>$\ \ \ \ \ \ \,$显然，若是$a_{(i,j)}$参数确定,复杂度也是$O(mn^2)$的，多数情况下不会达到这个复杂度，但是也是接受不了的，有些题目$m$给的特别大，$n$比较小，我们就考虑矩阵优化：</p>
<p>$\ \ \ \ \ \ \,$首先设定初始矩阵$A$，也就是原dp式子的初始化项：</p>
<p>$A= \begin{bmatrix} f_{(0,1)} &amp; f_{(0,2)} &amp; \cdots &amp; f_{(0,n)}\\ \end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$然后设定转移矩阵$B$：</p>
<p>$B= \begin{bmatrix} a_{(1,1)} &amp; a_{(1,2)} &amp; \cdots &amp; a_{(1,n)}\\a_{(2,1)} &amp; a_{(2,2)} &amp; \cdots &amp; a_{(2,n)}\\\vdots\\a_{(n,1)} &amp; a_{(n,2)} &amp; \cdots &amp; a_{(n,n)}\\ \end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$根据矩阵乘法的定义，很容易得到：</p>
<p>$A\times B=\begin{bmatrix} f_{(1,1)} &amp; f_{(1,2)} &amp; \cdots &amp; f_{(1,n)}\\ \end{bmatrix}$</p>
<p>$\ \ \ \ \ \ \,$推广得到：</p>
<p>$A\times B^m=\begin{bmatrix} f_{(m,1)} &amp; f_{(m,2)} &amp; \cdots &amp; f_{(m,n)}\\ \end{bmatrix}$</p>
<p>$\ \ \ \ \ \ \,$根据矩阵乘法满足交换律，所以我们可以先算出$B^m$，再$A$乘之，即可得到答案，矩阵快速幂如下，复杂度优化到$O(\log m \cdot n^3)$：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;<span class="type">int</span> n,m,a[N][N];&#125;;</span><br><span class="line"><span class="keyword">inline</span> matrix <span class="keyword">operator</span> *(<span class="type">const</span> matrix &amp;a,<span class="type">const</span> matrix &amp;b)&#123;</span><br><span class="line">	matrix ret;ret.n=a.n;ret.m=b.m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a.n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.m;j++)&#123;</span><br><span class="line">	  ret.a[i][j]=<span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a.m;k++)</span><br><span class="line">	  ret.a[i][j]+=a.a[i][k]*b.a[k][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> matrix <span class="title">power</span><span class="params">(matrix A,matrix B,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;m;m&gt;&gt;=<span class="number">1</span>,B=B*B)<span class="keyword">if</span>(m&amp;<span class="number">1</span>)A=A*B;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P1349-广义斐波那契数列"><a href="#P1349-广义斐波那契数列" class="headerlink" title="P1349 广义斐波那契数列"></a><a href="https://www.luogu.org/problemnew/show/P1349">P1349 广义斐波那契数列</a></h3><p>$\ \ \ \ \ \ \,$模板题目，递推式是：</p>
<p>$a_{n}=p\cdot a_{(n-1)}+q\cdot a_{(n-2)}$</p>
<p>$\ \ \ \ \ \ \,$所以我们令：</p>
<p>$f_{i,2}=[a_{i-1},a_{i}]$</p>
<p>$\ \ \ \ \ \ \,$那么有：</p>
<p>$f_{(i,1)}=0\cdot f_{(i-1,1)}+1\cdot f_{(i-1,2)}$</p>
<p>$f_{(i,2)}=p\cdot f_{(i-1,1)}+q\cdot f_{(i-1,2)}$</p>
<p>$\ \ \ \ \ \ \,$所以我们把$A$，$B$矩阵设置为：</p>
<p>$A= \begin{bmatrix} a_{1} &amp; a_{2} \end{bmatrix} $</p>
<p>$B= \begin{bmatrix} 0 &amp; q\\1 &amp;p \end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$那么我们的答案就在$A\times B^{n-2}$的第二项。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m;</span><br><span class="line"><span class="type">int</span> p,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;<span class="type">int</span> n,m;<span class="type">long</span> <span class="type">long</span> a[N][N];&#125;A,B;</span><br><span class="line"><span class="keyword">inline</span> matrix <span class="keyword">operator</span> *(<span class="type">const</span> matrix &amp;a,<span class="type">const</span> matrix &amp;b)&#123;</span><br><span class="line">	matrix ret;ret.n=a.n;ret.m=b.m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a.n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.m;j++)&#123;</span><br><span class="line">	  ret.a[i][j]=<span class="number">0ll</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a.m;k++)</span><br><span class="line">	  ret.a[i][j]=(ret.a[i][j]+a.a[i][k]*b.a[k][j]%m)%m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> matrix <span class="title">power</span><span class="params">(matrix A,matrix B,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;m;m&gt;&gt;=<span class="number">1</span>,B=B*B)<span class="keyword">if</span>(m&amp;<span class="number">1</span>)A=A*B;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A.n=<span class="number">1</span>;A.m=B.m=B.n=<span class="number">2</span>;</span><br><span class="line">	p=<span class="built_in">read</span>();q=<span class="built_in">read</span>();</span><br><span class="line">	A.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">read</span>();A.a[<span class="number">1</span>][<span class="number">2</span>]=<span class="built_in">read</span>();</span><br><span class="line">	B.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;B.a[<span class="number">1</span>][<span class="number">2</span>]=q;</span><br><span class="line">	B.a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;B.a[<span class="number">2</span>][<span class="number">2</span>]=p;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	A=<span class="built_in">power</span>(A,B,n<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,A.a[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>$\ \ \ \ \ \ \,$对于一个dp转移方程式，其中取最小或最大：</p>
<p>$f_{i}={\rm solve}(i,j)[l&lt;j&lt;r]$</p>
<p>$\ \ \ \ \ \ \,$若是可以化成如下形式：</p>
<p>$f_(i)=F(j)+g(i)[l&lt;j&lt;r]$</p>
<p>$\ \ \ \ \ \ \,$既 $j$ 造成的贡献与 $i$ 没有关系，并且 $j$ 造成的贡献我们需要取最大或者最小时，并且范围$[l&lt;j&lt;r]$有单调性时，我们可以利用单调队列来优化dp，从$O(n^2)$优化到$O(n)$。</p>
<p>$\ \ \ \ \ \ \,$核心想法是，建立一个容器，我们把 $F(j)$ 造成的贡献按照单调性加入该容器，若是现在需要新加入一个元素，那么就从队尾开始，把比他造成贡献不优的踢出去（原dp取 $\rm Min$ 的话就是需要 $F(j)$ 比队尾小，反之就是要大）。</p>
<p>$\ \ \ \ \ \ \,$当然这个时候队首将会是最优秀的 $j$，不过我们的范围限制还可能单调变化，于是我们又需要把队首那些范围不对的都踢掉，于是现在队首就是我们要的 $j$ 了，带入原dp即可。</p>
<p>$\ \ \ \ \ \ \,$由于所有元素都最多进入容器一次，又最多被踢一次，所以复杂度是$O(n)$的，模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> q=<span class="number">1</span>,p=<span class="number">0</span>,Q[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i--)&#123;</span><br><span class="line">  <span class="keyword">while</span>(q&lt;=p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">F</span>(i),<span class="built_in">F</span>(Q[p])))p--;</span><br><span class="line">  Q[++p]=i;</span><br><span class="line">  <span class="keyword">while</span>(q&lt;=p&amp;&amp;!<span class="built_in">in_lim</span>(i,Q[q]))q++;</span><br><span class="line">  <span class="keyword">if</span>(q&lt;=p)f[i]=<span class="built_in">F</span>(Q[q])+<span class="built_in">g</span>(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P2569-SCOI2010-股票交易"><a href="#P2569-SCOI2010-股票交易" class="headerlink" title="P2569 [SCOI2010]股票交易"></a><a href="https://www.luogu.org/problemnew/show/P2569">P2569 [SCOI2010]股票交易</a></h3><p>$\ \ \ \ \ \ \,$这题显然会有一个dp方程，$f_{(i,j)}$表示在第$i$天手里有$j$张股票的最大收益：</p>
<ul>
<li><p>直接购买：</p>
<p>$f_{(i,j)}=-aP_i\times j[0\leq j\leq aS_i]$</p>
</li>
<li><p>不行动：</p>
<p>$f_{(i,j)}=f_{(i-1,j)}$</p>
</li>
<li><p>买入：</p>
<p>$f_{(i,j)}={\rm Max}_{k=j-aS_i}^{j-1}\left(f_{(i-w-1,k)}-(j-k)\times aP_i\right)$</p>
</li>
<li><p>卖出：</p>
<p>$f_{(i,j)}={\rm Max}_{k=j+1}^{j+bS_i}\left(f_{(i-w-1,k)}+(k-j)\times bP_i\right)$</p>
</li>
</ul>
<p>$\ \ \ \ \ \ \,$复杂度为$O(n^3)$，主要是后面两个操作花时间了，所幸，后面两个都可以斜率优化，复杂度优化为$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> n,m,w;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> aP[N],bP[N],aS[N],bS[N];</span><br><span class="line"><span class="type">int</span> q,p,Q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	aP[i]=<span class="built_in">read</span>(),bP[i]=<span class="built_in">read</span>(),</span><br><span class="line">	aS[i]=<span class="built_in">read</span>(),bS[i]=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">memset</span>(f,<span class="number">128</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=aS[i];j++)f[i][j]=-j*aP[i];</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j]);</span><br><span class="line">  	<span class="keyword">if</span>(i&lt;=w)<span class="keyword">continue</span>;</span><br><span class="line">    q=<span class="number">1</span>,p=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">while</span>(q&lt;=p&amp;&amp;f[i-w<span class="number">-1</span>][Q[p]]+Q[p]*aP[i]&lt;=f[i-w<span class="number">-1</span>][j]+j*aP[i])p--;</span><br><span class="line">      Q[++p]=j;</span><br><span class="line">      <span class="keyword">while</span>(q&lt;=p&amp;&amp;Q[q]&lt;j-aS[i])q++;</span><br><span class="line">      <span class="keyword">if</span>(q&lt;=p)f[i][j]=<span class="built_in">max</span>(f[i][j],f[i-w<span class="number">-1</span>][Q[q]]+(Q[q]-j)*aP[i]); </span><br><span class="line">    &#125;</span><br><span class="line">	  q=<span class="number">1</span>,p=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">      <span class="keyword">while</span>(q&lt;=p&amp;&amp;f[i-w<span class="number">-1</span>][Q[p]]+Q[p]*bP[i]&lt;=f[i-w<span class="number">-1</span>][j]+j*bP[i])p--;</span><br><span class="line">      Q[++p]=j;</span><br><span class="line">      <span class="keyword">while</span>(q&lt;=p&amp;&amp;Q[q]&gt;j+bS[i])q++;</span><br><span class="line">      <span class="keyword">if</span>(q&lt;=p)f[i][j]=<span class="built_in">max</span>(f[i][j],f[i-w<span class="number">-1</span>][Q[q]]+(Q[q]-j)*bP[i]); </span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)ans=<span class="built_in">max</span>(ans,f[n][i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>$\ \ \ \ \ \ \,$对于一个dp式子，我们尝试将它化成3个部分：</p>
<ul>
<li>只与 $i$ 有关的（$A_i$）；</li>
<li>只与 $j$ 有关的（$D_j$）；</li>
<li>与 $i$ 和 $j$ 同时有关的（$B_i\cdot C_j$）；</li>
</ul>
<p>$\ \ \ \ \ \ \,$所以我们会得到形如这样子的式子：</p>
<p>${B_i}\cdot C_j+{A_i}={D_j}$</p>
<p>$\ \ \ \ \ \ \,$那么这个时候，我们把$B_i$当做斜率，$C_j$是横坐标，$D_j$是纵坐标，我们想要的是$A_i$最大或者是最小，那么答案一定是下面的那一层点里面诞生，需要满足的是：</p>
<ul>
<li><p>两个点之间的斜率必须优于$B_i$，若是取$\rm Max$就是需要大于，否者就是小于。</p>
</li>
<li><p>最优的$j$取值一定是斜率尽量优的。</p>
</li>
</ul>
<p>$\ \ \ \ \ \ \,$那么我们的想法是维护这个斜率组成的凸壳，若是$B_i$单调，我们可以考虑单调队列，若是不单调，那么我们在单调队列的基础上面，就不能从队首踢，就是维护一整个凸壳，每次询问在上面二分。</p>
<p>$\ \ \ \ \ \ \,$下面给出单调队列版的模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Q[N],q,p;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">Slope</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;<span class="comment">//B(i)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">X</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;<span class="comment">//C(j)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> j)</span></span>&#123;&#125;<span class="comment">//D(j)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">X</span>(i)==<span class="built_in">X</span>(j))<span class="keyword">return</span> <span class="number">1.0</span>*inf;<span class="comment">//max_inf,min_-inf;</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span>*(<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j)))/(<span class="number">1.0</span>*(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q=p=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">slope</span>(Q[q],Q[q+<span class="number">1</span>]),Slope))++q;</span><br><span class="line">		f[i]=<span class="built_in">F</span>(Q[q]);<span class="comment">//原dp方程</span></span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">slope</span>(i,Q[p<span class="number">-1</span>]),<span class="built_in">slope</span>(Q[p],Q[p<span class="number">-1</span>])))--p;</span><br><span class="line">		Q[++p]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P3195-HNOI2008-玩具装箱TOY"><a href="#P3195-HNOI2008-玩具装箱TOY" class="headerlink" title="P3195 [HNOI2008]玩具装箱TOY"></a><a href="https://www.luogu.org/problemnew/show/P3195">P3195 [HNOI2008]玩具装箱TOY</a></h3><p>$\ \ \ \ \ \ \,$本题dp方程如下：</p>
<p>$f_i={\rm Min}_{j=1}^{i-1}\left(f_j+(Sum_i-Sum_j+i-j-L-1)^2\right)$</p>
<p>$\ \ \ \ \ \ \,$化成如下形式：</p>
<p>${2\times(Sum_i+i)}(Sum_j+j+L+1)+{\left(f_i-(Sum_i+i)^2\right)}={\left(f_j+(Sum_j+j+L+1)^2\right)}$</p>
<p>$\ \ \ \ \ \ \,$我们发现${2\times(Sum_i+i)}$是单调的，于是我们想用单调队列来维护这个凸壳：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="type">double</span> f[N],sum[N],L;</span><br><span class="line"><span class="type">int</span> q,p,Q[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> sum[i]+(<span class="type">double</span>)i;&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">X</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fn</span>(i)+L;&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> f[i]+(<span class="built_in">fn</span>(i)+L)*(<span class="built_in">fn</span>(i)+L);&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> (<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j))/(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j));&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=(<span class="type">int</span>)<span class="built_in">read</span>();L=(<span class="type">double</span>)<span class="built_in">read</span>()+<span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	sum[i]=(<span class="type">double</span>)<span class="built_in">read</span>(),sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">	q=p=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">slope</span>(Q[q],Q[q+<span class="number">1</span>])&lt;<span class="number">2</span>*<span class="built_in">fn</span>(i))++q;</span><br><span class="line">		f[i]=f[Q[q]]+(<span class="built_in">fn</span>(i)-<span class="built_in">fn</span>(Q[q])-L)*(<span class="built_in">fn</span>(i)-<span class="built_in">fn</span>(Q[q])-L);</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">slope</span>(i,Q[p<span class="number">-1</span>])&lt;<span class="built_in">slope</span>(Q[p<span class="number">-1</span>],Q[p])) --p;</span><br><span class="line">    	Q[++p]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="WQS二分"><a href="#WQS二分" class="headerlink" title="WQS二分"></a>WQS二分</h2><p>$\ \ \ \ \ \ \,$WQS二分和斜率优化很相似，多了一个宽度限制，既需要干好取$m$个。和斜率优化一样，我们需要把式子化成下面的形式：</p>
<p>${B_i}\cdot C_j+{A_i}={D_j}$</p>
<p>$\ \ \ \ \ \ \,$在二分之前，我们二分一个特殊的值 $v$，取$k$个物品时，总贡献会多$kv$，在进行dp的同时，若$v$越大，取的物品越少，那么我们检查在$v$，的时候有多少个物品被选就好了，<strong>注意使用WQS二分需要满足$v$越大，取的物品越少</strong>，既需要满足取$x$个时的总贡献斜率不增，说白了，就是需要满足选的越多越好。</p>
<p>$\ \ \ \ \ \ \,$模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Q[N],q,p;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">Slope</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;<span class="comment">//B(i)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">X</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;<span class="comment">//C(j)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> j)</span></span>&#123;&#125;<span class="comment">//D(j)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">X</span>(i)==<span class="built_in">X</span>(j))<span class="keyword">return</span> <span class="number">1.0</span>*inf;<span class="comment">//max_inf,min_-inf;</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span>*(<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j)))/(<span class="number">1.0</span>*(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cheak</span><span class="params">(<span class="type">long</span> <span class="type">long</span> v)</span></span>&#123;</span><br><span class="line">	q=p=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">slope</span>(Q[q],Q[q+<span class="number">1</span>]),Slope))++q;</span><br><span class="line">		f[i]=<span class="built_in">F</span>(Q[q])+v;<span class="comment">//原dp方程</span></span><br><span class="line">		tot[i]=tot[Q[q]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">slope</span>(i,Q[p<span class="number">-1</span>]),<span class="built_in">slope</span>(Q[p],Q[p<span class="number">-1</span>])))--p;</span><br><span class="line">		Q[++q]=i;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> tot[n]&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cheak</span>(mid))r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cheak</span>(l);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]-l*m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4983-忘情"><a href="#P4983-忘情" class="headerlink" title="P4983 忘情"></a><a href="https://www.luogu.org/problemnew/show/P4983">P4983 忘情</a></h3><p>$\ \ \ \ \ \ \,$这个题是我们团队准备的，原式是来恶心人的，化简下来就是这个东西：</p>
<p>$\left(\sum_{i=1}^nx_i+1\right)^2$</p>
<p>$\ \ \ \ \ \ \,$dp方程显然就是这个东西：</p>
<p>$f_i={\rm Min}_{j=1}^{i-1}f_j+\left(Sum_i-Sum_j+1\right)^2$</p>
<p>$\ \ \ \ \ \ \,$化成如下形式：</p>
<p>${2\times Sum_i}\cdot Sum_j+{\left(f_i-(Sum_i+1)^2\right)}={f_j+Sum_j^2-2\times Sum_j}$</p>
<p>$\ \ \ \ \ \ \,$感性思考一下，当$m$越大，答案一定小越小，那么我们就可以使用WQS二分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,tot[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[N],f[N],Q[N];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">X</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> sum[a];&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> f[a]+sum[a]*sum[a]<span class="number">-2ll</span>*sum[a];&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solpe</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> <span class="number">1.0</span>*(<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j))/(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j));&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cheak</span><span class="params">(<span class="type">long</span> <span class="type">long</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> q=<span class="number">1</span>,p=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  	<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">solpe</span>(Q[q+<span class="number">1</span>],Q[q])&lt;<span class="number">2.0</span>*sum[i])q++;</span><br><span class="line">    f[i]=f[Q[q]]+(sum[i]-sum[Q[q]]+<span class="number">1</span>)*(sum[i]-sum[Q[q]]+<span class="number">1</span>)+v;</span><br><span class="line">		tot[i]=tot[Q[q]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">solpe</span>(i,Q[p])&lt;<span class="built_in">solpe</span>(Q[p<span class="number">-1</span>],Q[p]))p--;</span><br><span class="line">    Q[++p]=i;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> tot[n]&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[i]=sum[i<span class="number">-1</span>]+<span class="number">1ll</span>*<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> l=<span class="number">1</span>,r=(sum[n]*sum[n])/<span class="number">2</span>,mid;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cheak</span>(mid))r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cheak</span>(l);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]-l*m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>动态规划</tag>
        <tag>矩阵乘法</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
        <tag>WQS二分</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式全家桶</title>
    <url>/2019/04/03/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \,$终于把多项式差不多弄完了，可以找个机会在退役前把多项式整理封装弄好，也算是留下了一点东西吧（嘿嘿。</p>
<p>$\ \ \ \ \ \ \,$这一部分实例的代码是用 $std::vector$ 封装好的：</p>
<p><strong>2022-02-14 跟新：把这最长的一篇搬来新博客上面，然后做了一下整合</strong></p>
<span id="more"></span>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$\ \ \ \ \ \ \,$多项式（Polynomial）是代数学中的基础概念，是由称为未知数的变量和称为系数的常数通过有限次加减法、乘法以及自然数幂次的乘方运算得到的代数表达式。多项式是整式的一种。未知数只有一个的多项式称为一元多项式。</p>
<p>$\ \ \ \ \ \ \,$一个$n$元多项式，也就是长度为$n$的多项式$f$，我们可以这样表达：</p>
<p>$f=\sum_{i=0}^{n}f_i\cdot x^i$</p>
<p>$\ \ \ \ \ \ \,$我们一般简写为:</p>
<p>$f=\sum_{i=0}^{n}f_i$</p>
<p>$\ \ \ \ \ \ \,$首先是可能需要用到的模板定义，都是比较基础的数论知识，不赘述了：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Polynomial vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="comment">//封装多项式为 std::vector，方便resize等操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Polynomial &amp;a,<span class="type">int</span> len)</span></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>,mod_g=<span class="number">3</span>,img=<span class="number">86583718</span>;</span><br><span class="line"><span class="comment">//mod为多项式系数的取模值，mod_g是它的原根，img为在模意义下的虚部，只有多项式三角函数会遇到。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">exgcd</span>(b,a%b,y,x);y-=x*(a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcd，exgcd只有在开根的时候会用到</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">int</span> ans=<span class="number">1</span>;<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="number">1ll</span>*a*a%mod)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=<span class="number">1ll</span>*ans*a%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Inv(x) power(x,mod-2)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h3><p>$\ \ \ \ \ \ \,$然后是核心的快速数论变换 $NTT$，相关请看<a href="/2018/12/29/求多项式卷积的变换/">【求多项式卷积的变换】</a>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Polynomial R;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Binary_Rounding</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">int</span> len=<span class="number">1</span>;<span class="keyword">for</span>(;len&lt;n;len&lt;&lt;=<span class="number">1</span>);<span class="keyword">return</span> len;&#125;</span><br><span class="line"><span class="comment">//二进制向上取整，为方便NTT变换准备。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Prepare_Transformation</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> L=<span class="number">0</span>,len;<span class="keyword">for</span>(len=<span class="number">1</span>;len&lt;n;len&lt;&lt;=<span class="number">1</span>)L++;R.<span class="built_in">clear</span>();R.<span class="built_in">resize</span>(len);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">  	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预处理R数组，准备变换，在每次NTT之前理论都要调用此函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(Polynomial &amp;a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;R[i])<span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,gn=<span class="built_in">power</span>(mod_g,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,g=<span class="number">1</span>,x,y;k&lt;i;k++,g=<span class="number">1ll</span>*g*gn%mod)</span><br><span class="line">	  	x=a[j+k],y=<span class="number">1ll</span>*g*a[i+j+k]%mod,</span><br><span class="line">	  	a[j+k]=(x+y)%mod,a[i+j+k]=(x-y+mod)%mod;</span><br><span class="line">  	<span class="keyword">if</span>(f==<span class="number">-1</span>)&#123;</span><br><span class="line">   		<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">end</span>());</span><br><span class="line">    	<span class="type">int</span> inv=<span class="built_in">Inv</span>(n);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=<span class="number">1ll</span>*a[i]*inv%mod;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多项式的加，减，卷积"><a href="#多项式的加，减，卷积" class="headerlink" title="多项式的加，减，卷积"></a>多项式的加，减，卷积</h2><p>$\ \ \ \ \ \ \,$对于一个长度为$n$的多项式$f$和长度为$m$的多项式$g$:</p>
<p>$\begin{aligned}f+g&amp;=\sum_{i=0}^{n}f_i+\sum_{i=0}^{m}g_i\\ &amp;=\sum_{i=0}^{max(n,m)}f_i+g_i\end{aligned}$</p>
<p>$\begin{aligned}f-g&amp;=\sum_{i=0}^{n}f_i-\sum_{i=0}^{m}g_i\\ &amp;=\sum_{i=0}^{max(n,m)}f_i-g_i\end{aligned}$</p>
<p>$\ \ \ \ \ \ \,$多项式的卷积，我们还是对于上文中的两个函数$f$和$g$，这个地方不展开写挺不方便的，我们就展开吧：</p>
<p>$\begin{aligned}f\bigotimes g&amp;=\sum_{i=0}^{n}f_i\cdot  x^i\times \sum_{i=0}^{m}g_i\cdot x^i \\ &amp;=\sum_{v=0}^{n+m}f_b\cdot  x^b\times g_a\cdot  x^a[a+b=v]\\&amp;=\sum_{x=0}^{n+m}\sum_{i=0}^{v}f_i\cdot g_{v-i}\cdot x^v\end{aligned}$</p>
<p>$\ \ \ \ \ \ \,$计算的复杂度呢，是$O(n^2)$的，可以用一些神奇算法优化成$O(n\log n)$的具体看这里：<a href="/2018/12/29/求多项式卷积的变换/">【求多项式卷积的变换】</a></p>
<p>$\ \ \ \ \ \ \,$多项式的加，减，卷积，是比较基本的多项式操作，以模拟和 $NTT$ 为主，主要是展示和记录模板的操作。</p>
<p>$\ \ \ \ \ \ \,$ <del>单项式其实就是常数。</del></p>
<h3 id="多项式加，减单项式"><a href="#多项式加，减单项式" class="headerlink" title="多项式加，减单项式"></a>多项式加，减单项式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Polynomial <span class="keyword">operator</span> +(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)&#123;</span><br><span class="line">	<span class="type">int</span> sizea=a.<span class="built_in">size</span>();Polynomial ret=a;ret.<span class="built_in">resize</span>(sizea);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sizea;i++)ret[i]=(<span class="number">1ll</span>*a[i]+b+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Polynomial <span class="keyword">operator</span> -(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)&#123;</span><br><span class="line">	<span class="type">int</span> sizea=a.<span class="built_in">size</span>();Polynomial ret=a;ret.<span class="built_in">resize</span>(sizea);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sizea;i++)ret[i]=(<span class="number">1ll</span>*a[i]-b+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式卷积单项式"><a href="#多项式卷积单项式" class="headerlink" title="多项式卷积单项式"></a>多项式卷积单项式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Polynomial <span class="keyword">operator</span> *(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)&#123;</span><br><span class="line">	<span class="type">int</span> sizea=a.<span class="built_in">size</span>();Polynomial ret=a;ret.<span class="built_in">resize</span>(sizea);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sizea;i++)ret[i]=(<span class="number">1ll</span>*a[i]*b%mod+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式加，减多项式"><a href="#多项式加，减多项式" class="headerlink" title="多项式加，减多项式"></a>多项式加，减多项式</h3><p>$\ \ \ \ \ \ \,$注意 $vector$ 在赋值之前，一定先要 $resize$ 到合适的位置，不然就会一直 $RE$ 了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Polynomial <span class="keyword">operator</span> +(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> Polynomial &amp;b)&#123;</span><br><span class="line">	<span class="type">int</span> sizea=a.<span class="built_in">size</span>(),sizeb=b.<span class="built_in">size</span>(),size=<span class="built_in">max</span>(sizea,sizeb);</span><br><span class="line">	Polynomial ret=a;ret.<span class="built_in">resize</span>(size);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sizeb;i++)ret[i]=(<span class="number">1ll</span>*ret[i]+b[i])%mod;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Polynomial <span class="keyword">operator</span> -(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> Polynomial &amp;b)&#123;</span><br><span class="line">	<span class="type">int</span> sizea=a.<span class="built_in">size</span>(),sizeb=b.<span class="built_in">size</span>(),size=<span class="built_in">max</span>(sizea,sizeb);</span><br><span class="line">	Polynomial ret=a;ret.<span class="built_in">resize</span>(size);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sizeb;i++)ret[i]=(<span class="number">1ll</span>*ret[i]-b[i]+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式卷积多项式"><a href="#多项式卷积多项式" class="headerlink" title="多项式卷积多项式"></a>多项式卷积多项式</h3><p> $\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/P3803">P3803 【模板】多项式乘法（FFT）</a>（可以NTT过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Polynomial <span class="keyword">operator</span> *(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> Polynomial &amp;b)&#123;</span><br><span class="line">	Polynomial lsa=a,lsb=b,ret;</span><br><span class="line">	<span class="type">int</span> n=lsa.<span class="built_in">size</span>(),m=lsb.<span class="built_in">size</span>();</span><br><span class="line">	n=<span class="built_in">Prepare_Transformation</span>(n+m);</span><br><span class="line">  	lsa.<span class="built_in">resize</span>(n);lsb.<span class="built_in">resize</span>(n);ret.<span class="built_in">resize</span>(n);</span><br><span class="line">  	<span class="built_in">NTT</span>(lsa,<span class="number">1</span>);<span class="built_in">NTT</span>(lsb,<span class="number">1</span>);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)ret[i]=<span class="number">1ll</span>*lsa[i]*lsb[i]%mod;</span><br><span class="line">  	<span class="built_in">NTT</span>(ret,<span class="number">-1</span>);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式除法和取模"><a href="#多项式除法和取模" class="headerlink" title="多项式除法和取模"></a>多项式除法和取模</h3><p> $\ \ \ \ \ \ \,$你问我多项式除法（<a href="https://www.luogu.org/problemnew/show/P4512">P4512 【模板】多项式除法</a>）？？？多项式除法滚出多项式全家桶！！！（超凶</p>
<p> $\ \ \ \ \ \ \,$看了下一篇 求逆 过后，应该可以自己完成多项式除法了，但是在很多小地方……容易自闭。</p>
<p> $\ \ \ \ \ \ \,$还是贴一下板子吧，小心别一开始二进制取整了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Polynomial <span class="keyword">operator</span> /(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> Polynomial &amp;b)&#123;</span><br><span class="line">	Polynomial ret=a,ls=b;</span><br><span class="line">  	<span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>());</span><br><span class="line">  	<span class="built_in">reverse</span>(ls.<span class="built_in">begin</span>(),ls.<span class="built_in">end</span>());</span><br><span class="line">	ls.<span class="built_in">resize</span>(<span class="built_in">Binary_Rounding</span>(a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()));</span><br><span class="line">	ls=<span class="built_in">Inverse</span>(ls);</span><br><span class="line">	ls.<span class="built_in">resize</span>(a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>());</span><br><span class="line">	ret=ret*ls;ret.<span class="built_in">resize</span>(a.<span class="built_in">size</span>()-b.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">  	<span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Polynomial <span class="keyword">operator</span> %(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> Polynomial &amp;b)&#123;</span><br><span class="line">	Polynomial ret=a/b;</span><br><span class="line">	ret=ret*b;ret.<span class="built_in">resize</span>(a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>());</span><br><span class="line">	ret=a-ret;ret.<span class="built_in">resize</span>(a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式的逆，导，积"><a href="#多项式的逆，导，积" class="headerlink" title="多项式的逆，导，积"></a>多项式的逆，导，积</h2><p>$\ \ \ \ \ \ \,$这一部分麻烦一点了，但是很重要，几乎所有多项式都得用的，不过好在也不是很复杂的。</p>
<h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h3><p>$\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/P4238">P4238 【模板】多项式求逆</a></p>
<p>$\ \ \ \ \ \ \,$求一个多项式 $A$ 的模 $x^n$ 的逆元$B$ 时，假设先求出了模$x^{\frac{n}{2}}$ 的逆元 $B’$，既：</p>
<p>$A*B’ \equiv 1\ (mod\ x^{\frac{n}{2}})$</p>
<p>$A*B \equiv 1\ (mod\ x^{n})$</p>
<p>$\ \ \ \ \ \ \,$那么显然存在：</p>
<p>$A<em>B \equiv 1\ (mod\ x^{\frac{n}{2}})=A</em>B’$</p>
<p>$B-B’ \equiv 0\ (mod\ x^{\frac{n}{2}})$</p>
<p>$\ \ \ \ \ \ \,$两边同时平方：</p>
<p>$B^2-2BB’+B’^2 \equiv 0\ (mod\ x^n)$</p>
<p>$\ \ \ \ \ \ \,$再把 $A$ 乘回去：</p>
<p>$(A<em>B)</em>B-(A<em>B)</em>2B’+A<em>B’^2 \equiv A</em>0\ (mod\ x^n)$</p>
<p>$B-2B’+A*B’^2 \equiv 0\ (mod\ x^n)$</p>
<p>$B \equiv 2B’-A*B’^2\ (mod\ x^n)$</p>
<p>$\ \ \ \ \ \ \,$我们就可以倍增来处理它了，起点是$B_0 \equiv A_0^{-1}(mod\ x^1)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Inverse</span><span class="params">(<span class="type">const</span> Polynomial &amp;a)</span></span>&#123;</span><br><span class="line">	Polynomial ret,inv_a; </span><br><span class="line">	ret.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">  	ret[<span class="number">0</span>]=<span class="built_in">Inv</span>(a[<span class="number">0</span>]);<span class="type">int</span> ed=a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=ed;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">	 	<span class="type">int</span> n=<span class="built_in">Prepare_Transformation</span>(len+len);</span><br><span class="line">	  	inv_a=a;inv_a.<span class="built_in">resize</span>(n);ret.<span class="built_in">resize</span>(n);</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;n;i++)inv_a[i]=<span class="number">0</span>;</span><br><span class="line">	  	<span class="built_in">NTT</span>(inv_a,<span class="number">1</span>);<span class="built_in">NTT</span>(ret,<span class="number">1</span>);</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)ret[i]=<span class="number">1ll</span>*(<span class="number">2ll</span><span class="number">-1ll</span>*inv_a[i]*ret[i]%mod+mod)%mod*ret[i]%mod;</span><br><span class="line">	  	<span class="built_in">NTT</span>(ret,<span class="number">-1</span>);</span><br><span class="line">	  	<span class="comment">//这里把比较复杂的卷积过程拖下来了。</span></span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;n;i++)ret[i]=<span class="number">0</span>;</span><br><span class="line">	  	<span class="comment">//这里不resize了，直接把多余的清零。</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret.<span class="built_in">resize</span>(ed);</span><br><span class="line">	<span class="comment">//resize回来，防止以后长度爆炸。</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="多项式求导"><a href="#多项式求导" class="headerlink" title="多项式求导"></a>多项式求导</h3><p>$\ \ \ \ \ \ \,$按照公式来，公式挺简单的，设多项式 $A$ 的导数为 $A’$。</p>
<p>$\ \ \ \ \ \ \,$那么有：</p>
<p>$x^{A’}=Ax^{A-1}$</p>
<p>$\ \ \ \ \ \ \,$既：</p>
<p>$A’_{i}=i\times A_{i+1}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Derivation</span><span class="params">(<span class="type">const</span> Polynomial &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> size=a.<span class="built_in">size</span>();Polynomial ret;ret.<span class="built_in">resize</span>(size);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;size;i++)ret[i<span class="number">-1</span>]=<span class="number">1ll</span>*i*a[i]%mod;</span><br><span class="line">  	ret[size<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式求积"><a href="#多项式求积" class="headerlink" title="多项式求积"></a>多项式求积</h3><p>$\ \ \ \ \ \ \,$还是按照公式来，设多项式 $A$ 的积分为 $A’$。</p>
<p>$\ \ \ \ \ \ \,$那么有：</p>
<p>$\int x^{A’}dx=\frac{1}{A+1}x^{A-1}$</p>
<p>$\ \ \ \ \ \ \,$既：</p>
<p>$A’_{i}=\frac{A_{i-1}}{i}$</p>
<p>$\ \ \ \ \ \ \,$那就是乘逆元咯 <del>（兄弟俩长得挺像</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Integral</span><span class="params">(<span class="type">const</span> Polynomial &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> size=a.<span class="built_in">size</span>();Polynomial ret;ret.<span class="built_in">resize</span>(size);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;size;i++)ret[i]=<span class="number">1ll</span>*<span class="built_in">Inv</span>(i)*a[i<span class="number">-1</span>]%mod;</span><br><span class="line">  	ret[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式复合逆"><a href="#多项式复合逆" class="headerlink" title="多项式复合逆"></a>多项式复合逆</h3><p>$\ \ \ \ \ \ \,$<a href="https://acm.nflsoj.com/problem/332">NFLSOJ #332. 多项式复合逆</a></p>
<p>$\ \ \ \ \ \ \,$对于一个多项式$F$，若是存在一个多项式$G$，使得：</p>
<p>$G(F(x))=x$</p>
<p>$\ \ \ \ \ \ \,$那么就称多项式$G$是多项式$F$的复合逆。</p>
<p>$\ \ \ \ \ \ \,$目前复合逆没有$O(n \log n)$的做法，但是可以用拉格朗日反演做到$O(n^2 \log n)$，既每一项每一项得求，求一项的时间是$O(n \log n)$的，下面给出公式：</p>
<p>$G_i=\frac{\left(\frac{x}{F}\right)^i_{i-1}}{i}$</p>
<p>$\ \ \ \ \ \ \,$那么求逆和卷积就好了，$x$都挺好处理的，证明很复杂，感兴趣可以看<a href="https://users.math.msu.edu/users/magyar/Math880/Lagrange.pdf">这里</a>。</p>
<p>$\ \ \ \ \ \ \,$有一个值得注意的地方就是求逆的时候，应该直接求$\frac{F}{x}$的逆，而不是$F$的逆，因为既然多项式 $F$ 存在复合逆，那么常数项就应该是 $0$ ，这是不可能求逆的，先算出$\frac{F}{x}$即可。</p>
<p>$\ \ \ \ \ \ \,$若是需要$O(n \log n)$只求一项，则需要用到快速幂，下一篇我们会讲到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Composition_Inverse</span><span class="params">(<span class="type">const</span> Polynomial &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">  	Polynomial ret,Cinv=a,Pow;</span><br><span class="line">  	Cinv.<span class="built_in">resize</span>(n);ret.<span class="built_in">resize</span>(n);Pow.<span class="built_in">resize</span>(n);Pow[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)Cinv[i]=Cinv[i+<span class="number">1</span>];Cinv[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">  	Cinv=<span class="built_in">Inverse</span>(Cinv);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">  		Pow=Pow*Cinv;Pow.<span class="built_in">resize</span>(n);</span><br><span class="line">  		ret[i]=<span class="number">1ll</span>*Pow[i<span class="number">-1</span>]*<span class="built_in">Inv</span>(i)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式的ln，exp"><a href="#多项式的ln，exp" class="headerlink" title="多项式的ln，exp"></a>多项式的ln，exp</h2><p>$\ \ \ \ \ \ \,$对数和指数是很重要的东西了，复杂的多项式都和他们有关系，所以说掌握很重要，这里不建议光背板子，因为这两个板子都有致命的限制，而在实际操作的时候，可以通过一些方法绕过这个限制直接求解，这个就很重要了。</p>
<h3 id="多项式的-ln"><a href="#多项式的-ln" class="headerlink" title="多项式的$ln$"></a>多项式的$ln$</h3><p>$\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/P4725">P4725 【模板】多项式对数函数</a></p>
<p>$\ \ \ \ \ \ \,$公式先走起咯：</p>
<p>$\ln(A)=\int \frac{A’}{A}dx$</p>
<p>$\ \ \ \ \ \ \,$观察公式，一句话解决：</p>
<p>$\ \ \ \ \ \ \,$导卷逆的积：</p>
<p>$\ \ \ \ \ \ \,$看上去很模板，当然模板也是很短的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Logarithmic</span><span class="params">(<span class="type">const</span> Polynomial &amp;a)</span></span>&#123;</span><br><span class="line">	Polynomial ln_a=<span class="built_in">Derivation</span>(a)*<span class="built_in">Inverse</span>(a);</span><br><span class="line">  	ln_a.<span class="built_in">resize</span>(a.<span class="built_in">size</span>());</span><br><span class="line">  	<span class="comment">//这里resize一下，因为卷积后会倍增，防止变长爆掉</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Integral</span>(ln_a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$还有一个值得注意的问题，一般求对数的多项式，是需要要求常数项为 $1$ 的，因为我们知道：</p>
<p>$e^0=1$</p>
<p>$\ \ \ \ \ \ \,$也就是：</p>
<p>$ln(1)=0$</p>
<p>$\ \ \ \ \ \ \,$这样算出来的 $ln$ 常数项是 $0$，而我们追后一步在算积的时候，是默认把常数项补上 $0$ 的，这样就没有问题。可要是原多项式常数项不为 $1$ 呢？</p>
<p>$\ \ \ \ \ \ \,$显然应该算积的时候在常数项补上 $ln(C)$ （C为常数项），不过这个数在模的意义下应该是多少呢？这个问题周道确实不能解决了，所以说，模板题的话，会给出这个常数项为 $1$的条件的。</p>
<p>$\ \ \ \ \ \ \,$否认常数项不等于$1$，完全不能求 $ln$ 的说法。</p>
<h3 id="多项式的-exp"><a href="#多项式的-exp" class="headerlink" title="多项式的$exp$"></a>多项式的$exp$</h3><p><a href="https://www.luogu.org/problemnew/show/P4726">P4726 【模板】多项式指数函数</a></p>
<p>$\ \ \ \ \ \ \,$这玩意说简单也简单，说复杂也挺复杂的，我们得引入一个新玩意，<strong>【牛顿迭代】</strong>，是求函数零点的玩意，收敛速度非常理想，我在这里有简略的讲过：<a href="/2018/12/30/导数和牛顿迭代/">【导数和牛顿迭代】</a>，我也在洛谷出过一个牛顿迭代的裸题，感兴趣可以去体验一下牛顿迭代的神奇：<a href="https://www.luogu.org/problemnew/show/P4986">【P4986 逃离】</a>。</p>
<p>$\ \ \ \ \ \ \,$说远了，现在我们来康康怎么求指数函数。</p>
<p>$\ \ \ \ \ \ \,$令我们要求的是 $A$ 的指数函数 $B$，既是：</p>
<p>$B=e^A$</p>
<p>$\ \ \ \ \ \ \,$变形得：</p>
<p>$\ln(B)-A=0$</p>
<p>$\ \ \ \ \ \ \,$咦？$0$ ?，我们把多项式当做函数值看看？</p>
<p>$\ \ \ \ \ \ \,$哇，函数零点！马上牛顿迭代呀！</p>
<p>$\ \ \ \ \ \ \,$设$F(B)=\ln (B)-A$，我们要求 $F$的零点，根据牛顿迭代的公式可得（注意这里B后面的括号的迭代版本的意思，不是多项式的项）：</p>
<p>$B(x)=B(x-1)-\frac{F\left(B(x-1)\right)}{F’\left(B(x-1)\right)}$</p>
<p>$\ \ \ \ \ \ \,$而根据导数的定义，$F’(B)=\frac{1}{B}$，<del>（<a href="/2018/12/30/导数和牛顿迭代/">【导数和牛顿迭代】</a>里面有提到过一点，这里是把$A$当做常数舍去了）</del></p>
<p>$\ \ \ \ \ \ \,$那我们现在把牛顿迭代的公式化简：</p>
<p>$\begin{aligned}<br>B(x)&amp;<br>=B(x-1)-F\left(B(x-1)\right)\times B(x-1)\\&amp;<br>=B(x-1)-B(x-1)\times F\left(B(x-1)\right)\\&amp;<br>=B(x-1)-B(x-1)\times \left(\ln \left(B(x-1)\right)-A\right)\\&amp;<br>=B(x-1)\times  \left(1-\ln \left(B(x-1)\right)+A \right)<br>\end{aligned}$</p>
<p>$\ \ \ \ \ \ \,$再次强调B后面的括号的迭代版本的意思，不是多项式的项。</p>
<p>$\ \ \ \ \ \ \,$现在看似分治可做，我们用两个容器相互装版本。每次老版本一卷，新版本长度就会倍增，所以说我们做 $\log n$ 次迭代就好。我们的操作相当于把式子拆了求收敛值，所以不会有精度的问题，求出来就好了。</p>
<p>$\ \ \ \ \ \ \,$那么现在的问题是，第一个版本是怎么样，洛咕模板给的是保证 $A_0=0$，因为$e^0=1$，也就是$exp(0)=1$，所以说 $B_0=1$，也就是常数项为 $1$。</p>
<p>$\ \ \ \ \ \ \,$当然了，同理，他一般会保证$A_0=0$，我们不方便找到其他$exp(A_0)$模的意义下的值。如果可以算的话，可以在模板里面传入 $Constant$ 也就是 $exp(A_0)$ 的值。</p>
<p>$\ \ \ \ \ \ \,$否认$A_0$不等于$0$，完全不能求 $exp$ 的说法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Exponential</span><span class="params">(<span class="type">const</span> Polynomial &amp;a,<span class="type">int</span> Constant=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	Polynomial ret,D;<span class="type">int</span> ed=a.<span class="built_in">size</span>();</span><br><span class="line">	ret.<span class="built_in">resize</span>(<span class="number">1</span>);ret[<span class="number">0</span>]=Constant;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=ed;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">	  	D=<span class="built_in">Logarithmic</span>(ret);D.<span class="built_in">resize</span>(len);</span><br><span class="line">	  	D[<span class="number">0</span>]=(<span class="number">1ll</span>*a[<span class="number">0</span>]+<span class="number">1ll</span>-D[<span class="number">0</span>]+mod)%mod;</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;++i) D[i]=(<span class="number">1ll</span>*a[i]-D[i]+mod)%mod;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">Prepare_Transformation</span>(len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	  	ret.<span class="built_in">resize</span>(n);D.<span class="built_in">resize</span>(n);</span><br><span class="line">	  	<span class="built_in">NTT</span>(ret,<span class="number">1</span>);<span class="built_in">NTT</span>(D,<span class="number">1</span>);</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)ret[i]=<span class="number">1ll</span>*ret[i]*D[i]%mod;</span><br><span class="line">	  	<span class="built_in">NTT</span>(ret,<span class="number">-1</span>);</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;(len&lt;&lt;<span class="number">1</span>);++i)ret[i]=D[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ret.<span class="built_in">resize</span>(ed);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式快速幂，开方"><a href="#多项式快速幂，开方" class="headerlink" title="多项式快速幂，开方"></a>多项式快速幂，开方</h2><p>$\ \ \ \ \ \ \,$这是多项式的大头了，实际使用多项式的$ln$和$exp$，这里呢，也只讲$ln$和$exp$的做法。</p>
<hr>
<h3 id="多项式快速幂"><a href="#多项式快速幂" class="headerlink" title="多项式快速幂"></a>多项式快速幂</h3><p>$\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/P5245">P5245 【模板】多项式快速幂</a><br>$\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/P5273">P5273 【模板】多项式幂函数 (加强版)</a></p>
<p>$\ \ \ \ \ \ \,$已知：</p>
<p>$A^k=exp\left(ln(A)\times k\right)$</p>
<p>$\ \ \ \ \ \ \,$显然求$ln$和$exp$就可以出答案了。</p>
<p>$\ \ \ \ \ \ \,$既然要求$ln$和$exp$，那么一定要考虑的是常数项的问题，洛谷的常规题面有保证 $a_0=1$，所以说无脑套模板就对了。</p>
<p>$\ \ \ \ \ \ \,$那么加强版没有保证 $a_0=1$，我们如何算常数项呢？</p>
<p>$\ \ \ \ \ \ \,$容易知道，$ln$的常数项为 $ln(a_0)$ ，$exp$的常数项是$exp(ln(a_0)\times k)$。好像算不出来呢。</p>
<p>$\ \ \ \ \ \ \,$可是$A^k=exp\left(ln(A)\times k\right)$，所以说$exp$的常数项是就应该是$A^k$的常数项，既 $a_0^k$ 。</p>
<p>$\ \ \ \ \ \ \,$所以说我们直接知道$exp$的常数项了，就不管他$ln$的常数项啦。</p>
<p>$\ \ \ \ \ \ \,$注意当$a[0]=0$时，常数项也应该是$B_0=0$，可是……常数项真的可以为$0$吗？</p>
<p>$\ \ \ \ \ \ \,$我们是要求 $F’(B)=\frac{1}{B}$ 的，分母当然不能为 $0$ 了，所以说我们还是要单独处理 $a[0]=0$ 的情况的。</p>
<p>$\ \ \ \ \ \ \,$把为$0$的前缀提出来，然后算，最后在答案前面加上提出的长度乘上$k$个$0$即可，模板没有管这个，需要自己注意。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Power</span><span class="params">(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;K)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> size=a.<span class="built_in">size</span>();</span><br><span class="line">  	Polynomial p_a=<span class="built_in">Logarithmic</span>(a);</span><br><span class="line">  	p_a.<span class="built_in">resize</span>(size);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;size;++i)p_a[i]=<span class="number">1ll</span>*p_a[i]*K%mod;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Exponential</span>(p_a,<span class="built_in">power</span>(a[<span class="number">0</span>],K%(mod<span class="number">-1</span>)));</span><br><span class="line">  	<span class="comment">//这里求a[0]^k，用了欧拉定理优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式开方"><a href="#多项式开方" class="headerlink" title="多项式开方"></a>多项式开方</h3><p>$\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/P5205">P5205 【模板】多项式开根</a><br>$\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/P5277">P5277 【模板】多项式开根 (加强版)</a></p>
<p>$\ \ \ \ \ \ \,$已知：</p>
<p>$\sqrt{A}=exp\left(\frac{ln(A)}{2}\right)$</p>
<p>$\ \ \ \ \ \ \,$同理，求$ln$后，常数项带入$\sqrt{A_0}$ 求 $exp$ 就可以出答案了，不是加强版的照样直接贴模板也可以。</p>
<p>$\ \ \ \ \ \ \,$那么求常数项就比较讲究了，我们要求的是$\sqrt{A_0}\% mod$，也就是 $A_0$ 在 $\% mod$ 意义下的二次剩余。</p>
<p>$\ \ \ \ \ \ \,$如果会二次剩余，可以$O(\log mod)$求，不行还可以$BSGS$花时间 $O(\sqrt{mod})$ 求，时间差别不大，就先不放代码了，代码放在下一个环节，同理常数项为 $0$ 的时候要特殊判断。</p>
<h3 id="多项式开高次方"><a href="#多项式开高次方" class="headerlink" title="多项式开高次方"></a>多项式开高次方</h3><p>$\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/U67388">U67388 【模板】多项式开高次根</a></p>
<p>$\ \ \ \ \ \ \,$已知：</p>
<p>$\sqrt[k]{A}=exp\left(\frac{ln(A)}{k}\right)$</p>
<p>$\ \ \ \ \ \ \,$同理，求$ln$后，常数项带入$\sqrt[k]{A_0}$ 求 $exp$ 就可以出答案了，现在主要是说一下如何用$BSGS$ 求 $\sqrt[k]{A_0}\% mod$，高次剩余。</p>
<p>$\ \ \ \ \ \ \,$因为需要保证有逆元或者可以直接除，所以需要保证 $k|(mod-1)$，或者 $k$ 与 $mod-1$ 互质。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  	unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;hash.<span class="built_in">clear</span>();b%=mod;</span><br><span class="line">  	<span class="type">int</span> t=(<span class="type">int</span>)<span class="built_in">sqrt</span>(mod)+<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)hash[(<span class="type">int</span>)(<span class="number">1ll</span>*b*<span class="built_in">power</span>(a,j)%mod)]=j;</span><br><span class="line">  	a=<span class="built_in">power</span>(a,t);</span><br><span class="line">  	<span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> b?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>,val;i&lt;=t;++i)&#123;</span><br><span class="line">    	<span class="type">int</span> j=hash.<span class="built_in">find</span>(val=<span class="built_in">power</span>(a,i))==hash.<span class="built_in">end</span>()?<span class="number">-1</span>:hash[val];</span><br><span class="line">    	<span class="keyword">if</span>(j&gt;=<span class="number">0</span>)<span class="keyword">return</span> i*t-j;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Kth_Remaining</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> P=<span class="built_in">BSGS</span>(mod_g,a);</span><br><span class="line">	<span class="keyword">if</span>(P%K==<span class="number">0</span>)P/=K;</span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="type">int</span> x,y;<span class="built_in">exgcd</span>(K,mod<span class="number">-1</span>,x,y);<span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=(mod<span class="number">-1</span>);P=<span class="number">1ll</span>*P*x%(mod<span class="number">-1</span>);&#125;</span><br><span class="line">	<span class="type">int</span> ret=<span class="built_in">power</span>(mod_g,P);</span><br><span class="line">	<span class="keyword">if</span>(!(K&amp;<span class="number">1</span>))ret=<span class="built_in">min</span>(ret,mod-ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Kth_root</span><span class="params">(<span class="type">const</span> Polynomial &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;K)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> size=a.<span class="built_in">size</span>();</span><br><span class="line">  	Polynomial s_a=<span class="built_in">Logarithmic</span>(a);</span><br><span class="line">  	s_a.<span class="built_in">resize</span>(size);</span><br><span class="line">  	<span class="type">int</span> Kr=<span class="built_in">Inv</span>(K);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;size;++i)s_a[i]=<span class="number">1ll</span>*s_a[i]*Kr%mod;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Exponential</span>(s_a,<span class="built_in">Kth_Remaining</span>(a[<span class="number">0</span>],K));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> $\ \ \ \ \ \ \,$<strong>模板题是周道用<a href="https://www.luogu.org/problemnew/show/P5273">P5273 【模板】多项式幂函数 (加强版)</a>的板子出的数据，跑了一下应该没有问题，自己写也过了，感兴趣可以写一下。因为目前还不能保证完全的正确性，所以说没有计划申请加入题库。但是目前过开方，写过几道题，这代码还是没有问题的。欢迎$Hack$。</strong></p>
<h2 id="多项式三角函数，反三角函数"><a href="#多项式三角函数，反三角函数" class="headerlink" title="多项式三角函数，反三角函数"></a>多项式三角函数，反三角函数</h2><p> $\ \ \ \ \ \ \,$说好了，这个作用不大，主要是……过一下板子，赶时间的小朋友可以右上角叉叉了……</p>
<h3 id="多项式-Sin-amp-多项式-Cos"><a href="#多项式-Sin-amp-多项式-Cos" class="headerlink" title="多项式$Sin$ &amp; 多项式$Cos$"></a>多项式$Sin$ &amp; 多项式$Cos$</h3><p>$\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/P5264">P5264 【模板】多项式三角函数</a></p>
<p>$\ \ \ \ \ \ \,$欧拉公式：</p>
<p>$e^{ix}=\cos x+i\sin x$</p>
<p>$\ \ \ \ \ \ \,$直接推公式：</p>
<p>$e^{-ix}=\cos x-i\sin x$</p>
<p>$\ \ \ \ \ \ \,$加减一下得到:</p>
<p>$2\cos x=e^{ix}+e^{-ix}$</p>
<p>$2i\sin x=e^{ix}-e^{-ix}$</p>
<p>$\ \ \ \ \ \ \,$所以有：</p>
<p>$\cos x=\frac{e^{ix}+e^{-ix}}{i}$</p>
<p>$\sin x=\frac{e^{ix}-e^{-ix}}{2i}$</p>
<p>$\ \ \ \ \ \ \,$用多项式$A$替换掉 $x$ 即可：</p>
<p>$\cos (A)=\frac{exp(i\cdot A)+exp(-i\cdot A)}{i}$</p>
<p>$\sin (A)=\frac{exp(i\cdot A)-exp(-i\cdot A)}{2i}$</p>
<p>$\ \ \ \ \ \ \,$多项式卷单项式，$exp$，求逆，多项式卷多项式就好了，现在问题是 $i$ 怎么搞：</p>
<p>$\ \ \ \ \ \ \,$已知 $i^2=-1$，所以说 $i$ 既是 $mod-1$ 在 $\%mod$意义下的二次剩余，显然可以预处理出来，前置和目录里面已经说的有了，既为$img$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Sin</span><span class="params">(<span class="type">const</span> Polynomial &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">Exponential</span>(a*img)-<span class="built_in">Exponential</span>(a*(mod-img)))*<span class="built_in">Inv</span>(<span class="number">2ll</span>*img%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Cos</span><span class="params">(<span class="type">const</span> Polynomial &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">Exponential</span>(a*img)+<span class="built_in">Exponential</span>(a*(mod-img)))*<span class="built_in">Inv</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式-Asin-amp-多项式-Atan"><a href="#多项式-Asin-amp-多项式-Atan" class="headerlink" title="多项式$Asin$ &amp; 多项式$Atan$"></a>多项式$Asin$ &amp; 多项式$Atan$</h3><p>$\ \ \ \ \ \ \,$<a href="https://www.luogu.org/problemnew/show/P5265">P5265 【模板】多项式反三角函数</a></p>
<p>$\ \ \ \ \ \ \,$这个东西比较麻烦啦，直接给公式咯，具体证明可以看教材：</p>
<p>$Asin(A)=\int \frac{A’}{\sqrt{1-A^2}}dx$</p>
<p>$Atan(A)=\int \frac{A’}{1+A^2}dx$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Asin</span><span class="params">(<span class="type">const</span> Polynomial &amp;a)</span></span>&#123;</span><br><span class="line">	Polynomial As_a=a*a;</span><br><span class="line">  	As_a.<span class="built_in">resize</span>(a.<span class="built_in">size</span>());</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)As_a[i]=(mod-As_a[i]);</span><br><span class="line">	As_a[<span class="number">0</span>]=(<span class="number">1</span>+As_a[<span class="number">0</span>])%mod;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Integral</span>(<span class="built_in">Derivation</span>(a)*<span class="built_in">Inverse</span>(<span class="built_in">Kth_root</span>(As_a,<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Polynomial <span class="title">Atan</span><span class="params">(<span class="type">const</span> Polynomial &amp;a)</span></span>&#123;</span><br><span class="line">	Polynomial At_a=a*a;</span><br><span class="line">  	At_a.<span class="built_in">resize</span>(a.<span class="built_in">size</span>());At_a[<span class="number">0</span>]=(<span class="number">1</span>+At_a[<span class="number">0</span>])%mod;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Integral</span>(<span class="built_in">Derivation</span>(a)*<span class="built_in">Inverse</span>(At_a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>多项式</tag>
        <tag>NTT</tag>
        <tag>多项式卷积</tag>
        <tag>多项式求逆</tag>
        <tag>多项式求导</tag>
        <tag>多项式求积</tag>
        <tag>多项式复合逆</tag>
        <tag>多项式ln</tag>
        <tag>多项式exp</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展中国剩余定理</title>
    <url>/2018/12/29/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于扩展中国剩余定理及扩展中国剩余定理的复习笔记：</p>
<span id="more"></span>
<h2 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h2><p>  $\ \ \ \ \ \ \ \,$中国剩余定理是求解如下同余方程组的算法：</p>
<p>  $\begin{cases}x\equiv c_1\ \ ({\rm mod}\ m_1)\\x\equiv c_2\ \ ({\rm mod}\ m_2)\\x\equiv c_3\ \ ({\rm mod}\ m_3)\\\ \ \ \ \ \ \ \ \ \ \ \cdots\\x\equiv c_n\ \ ({\rm mod}\ m_n)\end{cases}$<br>  $\ \ \ \ \ \ \ \,$当$m$都互质时，我们使用中国剩余定理（CRT）。</p>
<p>  $\ \ \ \ \ \ \ \,$对于一个同余方程组，我们从简单的入手：</p>
<p>  $\begin{cases}x\equiv c_1\ \ ({\rm mod}\ m_1)\\x\equiv c_2\ \ ({\rm mod}\ m_2)\end{cases}$</p>
<p>  $\ \ \ \ \ \ \ \,$可以写成：$\begin{cases}x= c_1+k_1m_1\\x=c_2+k_2 m_2\end{cases}$</p>
<p>  $\ \ \ \ \ \ \ \,$联立式子：$x= c_1+k_1m_1=c_2+k_2 m_2$<br>  $k_1m_1-k_2 m_2=c_2-c_1$<br>  $\ \ \ \ \ \ \ \,$因为$m_1$和$m_2$互质，所以对于任意$c_2-c_1$的取值，肯定有一队合法解$k_1$，$k_2$.</p>
<p>  $\ \ \ \ \ \ \ \,$然而对于求形如$ax+by=c$的解，就是扩展欧几里得干的事情了:</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;d,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!b)&#123;d=a;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">   <span class="built_in">exgcd</span>(b,a%b,d,y,x);y-=x*(a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  $\ \ \ \ \ \ \ \,$它求出的$x$，$y$，既是$ax+by=\gcd (a,b)=1$的解。</p>
<p>  $\ \ \ \ \ \ \ \,$知道了$k’_1m_1+k’_2 (-m_2)=1$的解为$k’_1$，$k’_2$，那么就容易得到$k_1m_1-k_2 m_2=c_2-c_1$的解了:</p>
<p>  $k’_1m_1+k’_2 (-m_2)=1$</p>
<p>  $k’_1m_1-k’_2 m_2=1$</p>
<p>  $(k’_1(c_2-c_1))m_1-(k’_2(c_2-c_1)) m_2=c_2-c_1$</p>
<p>  $\ \ \ \ \ \ \ \,$既 $k_1=k’_1(c_2-c_1)$，$k_2=k’_2(c_2-c_1)$。</p>
<p>  $\ \ \ \ \ \ \ \,$现在我们带回去，就可以得到:<br>  $x= c_1+(k’_1(c_2-c_1))m_1=c_2+(k’_2(c_2-c_2)) m_2$</p>
<p>  $\ \ \ \ \ \ \ \,$至此我们的答案就出来了，如果遇到很多的方程，我们不妨就这样合并下去，就出来了，不过问题来了，中国剩余定理（CRT）只适用于当$m$都互质时，适用范围比较小，下面我们马上引入扩展中国剩余定理（EXCRT），模板还是记它吧，就不贴中国剩余定理（CRT）的代码了。</p>
<h2 id="扩展中国剩余定理（EXCRT）"><a href="#扩展中国剩余定理（EXCRT）" class="headerlink" title="扩展中国剩余定理（EXCRT）"></a>扩展中国剩余定理（EXCRT）</h2><p>  $\ \ \ \ \ \ \ \,$对于一个同余方程组，同样我们从简单的入手：</p>
<p>  $\begin{cases}x\equiv c_1\ \ ({\rm mod}\ m_1)\\x\equiv c_2\ \ ({\rm mod}\ m_2)\end{cases}$</p>
<p>  $\ \ \ \ \ \ \ \,$同理联立：</p>
<p>  $x= c_1+k_1m_1=c_2+k_2 m_2$<br>  $k_1m_1-k_2 m_2=c_2-c_1$</p>
<p>  $\ \ \ \ \ \ \ \,$因为$m_1$与$m_2$不一定互质，所以不能直接用扩展欧几里得了，当然了，我们可以先把他化成互质的：</p>
<p>  $k_1\frac{m_1}{\gcd (m_1,m_2)}+k_2 \frac{-m_2}{\gcd (m_1,m_2)}=\frac{c_2-c_1}{\gcd (m_1,m_2)}$</p>
<p>  $\ \ \ \ \ \ \ \,$套入扩展欧几里得，得到特解:</p>
<p>  $k’_1\frac{m_1}{\gcd (m_1,m_2)}+k’_2 \frac{-m_2}{\gcd (m_1,m_2)}=1$</p>
<p>  $\frac{k’_1(c_2-c_1)}{\gcd (m_1,m_2)^2}m_1- \frac{k’_2(c_2-c_1)}{\gcd (m_1,m_2)^2}m_2=\frac{c_2-c_1}{\gcd (m_1,m_2)}$</p>
<p>  $\frac{k’_1(c_2-c_1)}{\gcd (m_1,m_2)}m_1- \frac{k’_2(c_2-c_1)}{\gcd (m_1,m_2)}m_2=c_2-c_1$</p>
<p>  $\ \ \ \ \ \ \ \,$带回去，就可以得到:<br>  $x= c_1+\frac{k’_1(c_2-c_1)}{\gcd (m_1,m_2)}m_1=c_2+\frac{k’_2(c_2-c_1)}{\gcd (m_1,m_2)}m_2$</p>
<p>  $\ \ \ \ \ \ \ \,$那么这样就很显然了，依次合并下去就好了，答案就出来了，当上面的除法不能整除的时候，就是无解。</p>
<h2 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h2><p>  $\ \ \ \ \ \ \ \,$这个东西对于CRT很重要，很容易在计算两个数的积的时候就爆了$\rm long\ long$，所以我们需要用到类似快速幂的做法，变算边取模：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">multi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">	  a=(a%p+p)%p;b=(b%p+p)%p;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">for</span>(;a;a&gt;&gt;=<span class="number">1</span>,b=(b*<span class="number">2</span>)%p)<span class="keyword">if</span>(a&amp;<span class="number">1</span>)ans=(ans+b)%p;</span><br><span class="line">	  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  $\ \ \ \ \ \ \ \,$还有$O(1)$的：<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> mod)</span></span>&#123;</span><br><span class="line"> 	a%=mod,b%=mod;</span><br><span class="line"> 	<span class="keyword">return</span> ((a*b-(<span class="type">long</span> <span class="type">long</span>)((<span class="type">long</span> <span class="type">long</span>)((<span class="type">long</span> <span class="type">double</span>)a/mod*b+<span class="number">1e-3</span>)*mod))%mod+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最后给出完整模板"><a href="#最后给出完整模板" class="headerlink" title="最后给出完整模板"></a>最后给出完整模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x,y,lcm;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m[N],c[N];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">multi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">  a=(a%p+p)%p;b=(b%p+p)%p;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;a;a&gt;&gt;=<span class="number">1</span>,b=(b*<span class="number">2</span>)%p)<span class="keyword">if</span>(a&amp;<span class="number">1</span>)ans=(ans+b)%p;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> &amp;x,<span class="type">long</span> <span class="type">long</span> &amp;y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> val=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> t=x;x=y;y=t-a/b*y;<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">excrt</span><span class="params">(<span class="type">long</span> <span class="type">long</span>*m,<span class="type">long</span> <span class="type">long</span>*c,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val=<span class="built_in">exgcd</span>(m[i],m[i+<span class="number">1</span>],x,y);</span><br><span class="line">    lcm=m[i]/val*m[i+<span class="number">1</span>];</span><br><span class="line">    m[i+<span class="number">1</span>]=lcm;</span><br><span class="line"><span class="comment">//    if((c[i+1]-c[i])%val)return -1;</span></span><br><span class="line">    val=<span class="built_in">multi</span>(x,(c[i+<span class="number">1</span>]-c[i])/val,lcm);</span><br><span class="line">    c[i+<span class="number">1</span>]=(<span class="built_in">multi</span>(m[i],val,lcm)+c[i])%lcm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (c[n]%m[n]+m[n])%m[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="【P4777-【模板】扩展中国剩余定理（EXCRT）】"><a href="#【P4777-【模板】扩展中国剩余定理（EXCRT）】" class="headerlink" title="【P4777 【模板】扩展中国剩余定理（EXCRT）】"></a><a href="https://www.luogu.org/problemnew/show/P4777">【P4777 【模板】扩展中国剩余定理（EXCRT）】</a></h3><p>  <a href="https://www.luogu.org/space/show?uid=50167">$\rm Imagine\tt Orz$</a>大佬的模板，数据还是挺强的，卡了我很久。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x,y,lcm;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m[<span class="number">100055</span>],c[<span class="number">100055</span>];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">multi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">  a=(a%p+p)%p;b=(b%p+p)%p;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;a;a&gt;&gt;=<span class="number">1</span>,b=(b*<span class="number">2</span>)%p)<span class="keyword">if</span>(a&amp;<span class="number">1</span>)ans=(ans+b)%p;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> &amp;x,<span class="type">long</span> <span class="type">long</span> &amp;y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> val=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> t=x;x=y;y=t-a/b*y;<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">excrt</span><span class="params">(<span class="type">long</span> <span class="type">long</span>*m,<span class="type">long</span> <span class="type">long</span>*c,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val=<span class="built_in">exgcd</span>(m[i],m[i+<span class="number">1</span>],x,y);</span><br><span class="line">    lcm=m[i]/val*m[i+<span class="number">1</span>];</span><br><span class="line">    m[i+<span class="number">1</span>]=lcm;</span><br><span class="line">    val=<span class="built_in">multi</span>(x,(c[i+<span class="number">1</span>]-c[i])/val,lcm);</span><br><span class="line">    c[i+<span class="number">1</span>]=(<span class="built_in">multi</span>(m[i],val,lcm)+c[i])%lcm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (c[n]%m[n]+m[n])%m[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  n=(<span class="type">int</span>)<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    m[i]=<span class="built_in">read</span>(),c[i]=<span class="built_in">read</span>();</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="built_in">excrt</span>(m,c,n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【P4774-NOI2018-屠龙勇士】"><a href="#【P4774-NOI2018-屠龙勇士】" class="headerlink" title="【P4774 [NOI2018]屠龙勇士】"></a><a href="https://www.luogu.org/problemnew/show/P4774">【P4774 [NOI2018]屠龙勇士】</a></h3><p>  $\ \ \ \ \ \ \,$虽然当时当场就看出来是同余方程组了，不过还是因为快速乘坑了好久，还是做少了，太菜了。考点比较多，有点回忆不起来了，还是贴一下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,T;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N],p[N],a[N],w[N],x[N];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> &amp;x,<span class="type">long</span> <span class="type">long</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=x*(a/b);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">inv</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>,y=<span class="number">0</span>,g=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">    <span class="keyword">if</span>(g&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x+b)%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fast_multi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">  a=(a%p+p)%p;</span><br><span class="line">    b=(b%p+p)%p;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;a;a&gt;&gt;=<span class="number">1</span>,b=(b&lt;&lt;<span class="number">1</span>)%p)</span><br><span class="line">    <span class="keyword">if</span>(a&amp;<span class="number">1LL</span>)ans=(ans+b)%p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CRT</span><span class="params">(<span class="type">long</span> <span class="type">long</span> w1,<span class="type">long</span> <span class="type">long</span> p1,<span class="type">long</span> <span class="type">long</span> w2,<span class="type">long</span> <span class="type">long</span> p2,<span class="type">long</span> <span class="type">long</span> &amp;w,<span class="type">long</span> <span class="type">long</span> &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x,y,z=w2-w1,g=<span class="built_in">exgcd</span>(p1,p2,x,y);</span><br><span class="line">    <span class="keyword">if</span>(z%g)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> t=z/g;</span><br><span class="line">    x=<span class="built_in">fast_multi</span>(x,t,p2/g);</span><br><span class="line">    p=p1/g*p2;</span><br><span class="line">    w=((w1+<span class="built_in">fast_multi</span>(x,p1,p))%p+p)%p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g=<span class="built_in">gcd</span>(a[i],<span class="built_in">gcd</span>(f[i],p[i]));</span><br><span class="line">        f[i]/=g,p[i]/=g,a[i]/=g;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> Inv=<span class="built_in">inv</span>(f[i],p[i]);</span><br><span class="line">        <span class="keyword">if</span>(Inv&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">        x[i]=<span class="built_in">fast_multi</span>(a[i],Inv,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> W=x[<span class="number">1</span>],P=p[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">CRT</span>(W,P,x[i],p[i],W,P))<span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> val=(a[i]+f[i]<span class="number">-1</span>)/f[i];</span><br><span class="line">        <span class="keyword">if</span>(val&lt;=W)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> k=(val-W+P<span class="number">-1</span>)/P;</span><br><span class="line">        W+=k*P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br><span class="line">multiset&lt;<span class="type">long</span> <span class="type">long</span>&gt; S;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen(&quot;dragon.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;dragon.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)w[i]=<span class="built_in">read</span>();</span><br><span class="line">        S.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(m--)S.<span class="built_in">insert</span>(<span class="built_in">read</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            multiset&lt;<span class="type">long</span> <span class="type">long</span>&gt; :: iterator p=S.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span>((*p)&lt;a[i])p=--S.<span class="built_in">upper_bound</span>(a[i]);</span><br><span class="line">            f[i]=*p,S.<span class="built_in">erase</span>(p);</span><br><span class="line">            S.<span class="built_in">insert</span>(w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数学</tag>
        <tag>CRT</tag>
        <tag>exCRT</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机</title>
    <url>/2018/12/29/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于后缀自动机性质的复习笔记：</p>
<span id="more"></span>
<p>$\ \ \ \ \ \ \ \,$后缀自动机是一个可以解决大多数字符串问题的字符串数据结构，可以识别该字符串的所有子串，其时空复杂度也比较优秀，对于一个字符集大小为$m$，长度为$n$的字符串，建立一个后缀自动机的时间复杂度为$O(nm)$，空间复杂度为 $O(2nm)$。</p>
<p>$\ \ \ \ \ \ \ \,$讲后缀自动机的博客很多，这里直接给出模板，重点讲讲后缀自动机长什么样子，怎么用它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Suffix_Automaton</span>&#123;</span><br><span class="line">  <span class="type">int</span> len[N&lt;&lt;<span class="number">1</span>],fa[N&lt;&lt;<span class="number">1</span>],son[N&lt;&lt;<span class="number">1</span>][<span class="number">26</span>];</span><br><span class="line">  <span class="type">int</span> size,last;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;size=last=<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> s=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  	<span class="type">int</span> p=last,np=++size;last=np;</span><br><span class="line">  	len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(;p&amp;&amp;!son[p][s];p=fa[p])son[p][s]=np;</span><br><span class="line">  	<span class="keyword">if</span>(!p)fa[np]=<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">else</span>&#123;</span><br><span class="line">  		<span class="type">int</span> q=son[p][s];</span><br><span class="line">  		<span class="keyword">if</span>(len[p]+<span class="number">1</span>==len[q])fa[np]=q;</span><br><span class="line">  		<span class="keyword">else</span>&#123;</span><br><span class="line">  			<span class="type">int</span> nq=++size;len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">memcpy</span>(son[nq],son[q],<span class="built_in">sizeof</span>(son[q]));</span><br><span class="line">  			fa[nq]=fa[q];fa[q]=fa[np]=nq;</span><br><span class="line">  			<span class="keyword">for</span>(;son[p][s]==q;p=fa[p])son[p][s]=nq;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">Init</span>();</span><br><span class="line">  	<span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">  	<span class="built_in">insert</span>(s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Sam;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$对于一个串 $abcabbca$，我们建立的后缀自动机就是这个样子的：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7d92af985e9c0bc856c6540d026440d2.png" alt="FgcB5V.md.png"><br>（注意点12到点6少了一条边b）</p>
<p>$\ \ \ \ \ \ \ \,$其中我们如下规定：</p>
<ul>
<li><p>红色，蓝色，绿色的边构成一个尾部收束的$Trie$树，用来高效表示这个串的后缀集合，就是$son$数组构成的。并且我们把红色的链叫做主链，蓝色叫做扩展链，同一水平面的点叫做扩展点对（在模板中，每个$last$的取值都是主链，每个$np$和$nq$都是扩展点对）<del>（都是我自己取的名字）</del></p>
</li>
<li><p>黄色构成$parents$树，就是$fa$数组构成的，这棵树爸爸不认儿子，儿子认爸爸。</p>
</li>
<li><p>在点旁边的灰色数字就是$len$数组。</p>
</li>
</ul>
<p>$\ \ \ \ \ \ \ \,$其实这张图看上去还是挺麻烦的，我们不如将它分开来看：</p>
<h2 id="尾部收束的-Trie-树："><a href="#尾部收束的-Trie-树：" class="headerlink" title="尾部收束的$Trie$树："></a>尾部收束的$Trie$树：</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/1f18cdea677c5f50e8046a4ded937fb9.png" alt="Fgc7xe.md.png"><br>（注意点12到点6少了一条边b）</p>
<p>$\ \ \ \ \ \ \ \,$尾部收束的$Trie$树，用来高效表示这个串的后缀集合，可以发现，我们从节点 $1$ 开始走，在走到没有儿子的节点的时候，必然是原串的一个后缀，并且是覆盖完了的，换句话说，<strong>这个串的任意子串都可以在这棵树上表示出来，且仅有这个串的子串才能表示</strong>。</p>
<p>$\ \ \ \ \ \ \ \,$不妨来观察一下，每一个节点上都有哪些子串的信息：</p>
<p><strong> 2：a </strong></p>
<p><strong> 3：ab </strong></p>
<p><strong> 4：abc </strong></p>
<p><strong> 5：abca </strong></p>
<p><strong> 6：abcab，bcab，cab </strong></p>
<p><strong> 7：abcabb，bcabb，cabb，abb，bb </strong></p>
<p><strong> 8：b </strong></p>
<p><strong> 9：abcabbc，bcabbc，cabbc，abbc，bbc </strong></p>
<p><strong> 10：bc，c </strong></p>
<p><strong> 11：abcabbca，bcabbca，cabbca，abbca，bbca </strong></p>
<p><strong> 12：bca，ca </strong></p>
<p>$\ \ \ \ \ \ \ \,$这样一来，很多性质都出来了：</p>
<p><strong> 在$Trie$上，父亲是儿子上的子串的公共前缀<del>（废话）</del>； </strong></p>
<p><strong> 在主链上的点，最长的子串都是原串的前缀； </strong></p>
<p><strong> 在一个点上的子串，短的为长的的后缀； </strong></p>
<p><strong> $len$数组表示的是这个节上的子串最长长度； </strong></p>
<p><strong> 扩展点对一个在主链上一个在扩展链上，在扩展链上的点上的子串是在主链上的点上的子串的公共后缀。 </strong></p>
<h2 id="parents-树："><a href="#parents-树：" class="headerlink" title="$parents$树："></a>$parents$树：</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/c3221ce482a1ff2ce6b53fb9b1d20638.png" alt="Fg2dhV.png"></p>
<p>$\ \ \ \ \ \ \ \,$这样看起来好像不是特别方便，我们把他整合一下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3da88966e5b248626cf33b5c6d868c74.png" alt="Fg26B9.png"></p>
<p>$\ \ \ \ \ \ \ \,$回想一下每一个节点上都有哪些子串的信息和出现次数，顺便看看每个子串出现的终点：</p>
<p><strong> 2：a (3：1,4,8) </strong></p>
<p><strong> 3：ab (2：2,5) </strong></p>
<p><strong> 4：abc (1：3) </strong></p>
<p><strong> 5：abca (1：4) </strong></p>
<p><strong> 6：abcab (1：5)，bcab (1：5)，cab (1：5) </strong></p>
<p><strong> 7：abcabb (1：6)，bcabb (1：6)，cabb (1：6)，abb (1：6)，bb (1：6) </strong></p>
<p><strong> 8：b (3：2,5,6) </strong></p>
<p><strong> 9：abcabbc (1：7)，bcabbc (1：7)，cabbc (1：7)，abbc (1：7)，bbc (1：7) </strong></p>
<p><strong> 10：bc (2：3,7)，c (2：3,7) </strong></p>
<p><strong> 11：abcabbca (1：8)，bcabbca (1：8)，cabbca (1：8)，abbca (1：8)，bbca (1：8) </strong></p>
<p><strong> 12：bca (2：4,8)，ca (2：4,8) </strong></p>
<p>$\ \ \ \ \ \ \ \,$很多性质又都出来了：</p>
<p><strong> 在$parents$上，父亲是儿子上的子串的公共后缀； </strong></p>
<p><strong> 叶子节点都是主链上的节点； </strong></p>
<p><strong> 主链上的节点上的子串的出现终点，都有$len$数组描述的位置； </strong></p>
<p><strong> 一个节点上的子串出现次数是一样的； </strong></p>
<p><strong> 父亲上的子串出现次数，是儿子上的子串出现次数之和； </strong></p>
<p><strong> 儿子上的子串出现的终点，是父亲上的子串出现的终点的子集； </strong></p>
<p><strong> 点$i$上面表示子串的数量为$len[fa[i]]-len[i]$。 </strong></p>
<hr>
<p>$\ \ \ \ \ \ \ \,$最后我们总结一下：<br><strong> 在$Trie$上，父亲是儿子上的子串的公共前缀； </strong></p>
<p><strong> 在$parents$上，父亲是儿子上的子串的公共后缀； </strong></p>
<p><strong> 在一个点上的子串，短的为长的的后缀； </strong></p>
<p><strong> 一个节点上的子串出现次数是一样的； </strong></p>
<p><strong> $len$数组表示的是这个节上的子串最长长度； </strong></p>
<p><strong> $parents$上叶子节点都是主链上的节点； </strong></p>
<p><strong> 在主链上的点，最长的子串都是原串的前缀； </strong></p>
<p><strong> 主链上的节点上的子串的出现终点，都有$len$数组描述的位置； </strong></p>
<p><strong> 扩展点对一个在主链上一个在扩展链上，在扩展链上的点上的子串是在主链上的点上的子串的公共后缀； </strong></p>
<p><strong> $parents$上父亲上的子串出现次数，是儿子上的子串出现次数之和，如果父亲在主链上，就再加一； </strong></p>
<p><strong> $parents$上儿子上的子串出现的终点，是父亲上的子串出现的终点的子集； </strong></p>
<p><strong> 点$i$上面表示子串的数量为$len[fa[i]]-len[i]$。 </strong></p>
<hr>
<p>$\ \ \ \ \ \ \ \,$如此多的性质，我们就可以拿后缀自动机解决很多问题了：</p>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>  文本串建立后缀自动机，模式串在$Trie$上面跑一次，跑完了就匹配到了，利用了$Trie$上面包含了原串所有子串的性质，多文本串的话，就在文本串之间插入奇怪字符，然后一起建立后缀自动机就行了就可以解决了，或者建广义后缀自动机。</p>
<h2 id="子串查询出现次数"><a href="#子串查询出现次数" class="headerlink" title="子串查询出现次数"></a>子串查询出现次数</h2><p>  文本串建立后缀自动机，然后在$parents$上做$dp$，询问就让模式串在$Trie$上面跑一次，找到自动机上点，输出就好了，利用了$parents$上父亲上的子串出现次数，是儿子上的子串出现次数之和的性质。因为$parents$上是儿子认爸爸，爸爸不认儿子，所以我们需要跑个拓扑，拓扑序就是$y$的倒叙了啊：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)x[len[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)x[i]+=x[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)y[x[len[i]]--]=i;</span><br><span class="line"><span class="comment">//for(int i=size;i&gt;=1;i--)tim[fa[y[i]]]+=tim[y[i]];</span></span><br></pre></td></tr></table></figure>
<h2 id="子串查询出现位置"><a href="#子串查询出现位置" class="headerlink" title="子串查询出现位置"></a>子串查询出现位置</h2><p>  文本串建立后缀自动机，让模式串在$Trie$上面跑一次，找到自动机上点，再从这个点开始，在$parents$上跑，遇到在主链上的点，它的$len$值就是终点了，要是求起点坐标，终点减去长度加上$1$就好了。</p>
<h2 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h2><p>  文本串倍增，后半截翻转，查询子串出现次数大于$2$，并且位置换算一下，如果相解就是合法，取最大值就好了，实现起来略复杂，没有Manacher算法优秀。</p>
<h2 id="子串的子串"><a href="#子串的子串" class="headerlink" title="子串的子串"></a>子串的子串</h2><p>  子串的子串要么是它的前缀的后缀，要么是它的前缀，要么是他的后缀，所以说只需要找到子串这个点，他在$parents$上的子树和他在$Trie$的祖先，还有他在$parents$上的子树的$Trie$的祖先，都是他的子串。</p>
<h2 id="后缀自动机的合并（广义后缀自动机）"><a href="#后缀自动机的合并（广义后缀自动机）" class="headerlink" title="后缀自动机的合并（广义后缀自动机）"></a>后缀自动机的合并（广义后缀自动机）</h2><p>  后缀自动机的合并，我们可以理解为，在后缀自动机上新加入一个字符串，其实只需要将 $last$ 重新赋为 $1$ ，注意新串的点打上不一样的标记，这个差不多就是广义后缀自动机，广义后缀自动机还有一步判断这个点有没有被建过的操作，但个人感觉实际上没有必要，最坏空间复杂度依然是$O(2nm)$的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">  col++;last=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">  <span class="built_in">insert</span>(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$还有很多关于子串，前缀，后缀的问题或者可以转换为子串，前缀，后缀的问题，用后缀自动机在大多数情况下都是不二之选，一般字符串的字符集都比较小，所以复杂度也很优秀，但要是字符集大小太大的话，还是仔细想想其他算法吧。</p>
<p>$\ \ \ \ \ \ \ \,$还有，后缀自动机处理的字符串是静态的，最多就是在后面加后缀，要是需要处理动态的字符串的话，多半也是不合算的，需要考虑其他算法。</p>
<p>$\ \ \ \ \ \ \ \,$不过，后缀自动机依然是一个优秀的字符串数据结构，代码量小，适用性高，是一个万金油算法。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>导数和牛顿迭代</title>
    <url>/2018/12/30/%E5%AF%BC%E6%95%B0%E5%92%8C%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于导数和牛顿迭代的复习笔记：</p>
<span id="more"></span>
<h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>  $\ \ \ \ \ \ \,$导数是描述一个函数的变化情况的函数，函数$f$的导数记作$f’$。</p>
<p>  $\ \ \ \ \ \ \,$导数（英语：Derivative）是微积分学中重要的基础概念。一个函数在某一点的导数描述了这个函数在这一点附近的变化率。导数的本质是通过极限的概念对函数进行局部的线性逼近$\ \ \ \ \ \ $——wiki。</p>
<h3 id="导数的运算法则"><a href="#导数的运算法则" class="headerlink" title="导数的运算法则"></a>导数的运算法则</h3><ul>
<li><p>$(f+g)’=f’+g’$</p>
</li>
<li><p>$(f-g)’=f’-g’$</p>
</li>
<li><p>$(f\cdot g)’=f’\cdot g’$</p>
</li>
<li><p>$(af)’=af’$</p>
</li>
<li><p>$(fa)’=f’a+a\cdot f’$</p>
</li>
<li><p>$(f/g)’=\frac{f’\cdot g-f\cdot g’}{g^2}$</p>
</li>
</ul>
<h3 id="常见函数的导数"><a href="#常见函数的导数" class="headerlink" title="常见函数的导数"></a>常见函数的导数</h3><ul>
<li><p>$(x^k)’=kx^{k-1}$</p>
</li>
<li><p>$(a^x)’=a^x\cdot \ln a$</p>
</li>
<li><p>$(e^x)’=e^{x}$</p>
</li>
<li><p>$(\log _a x)’=\frac{1}{x \cdot \ln a}$</p>
</li>
<li><p>$(\ln x)’=\frac{1}{x}$</p>
</li>
<li><p>$(\sin x)’=\cos x$</p>
</li>
<li><p>$(\cos x)’=-\sin x$</p>
</li>
<li><p>$(\tan x)’=\sec ^2x$</p>
</li>
<li><p>$(\cot x)’=-\csc ^2x$</p>
</li>
<li><p>$(\sec x)’=\tan x\cdot\csc x$</p>
</li>
<li><p>$(\csc x)’=-\cot x\cdot\csc x$</p>
</li>
<li><p>$(\arcsin x)’=\frac{1}{\sqrt{1-x^2}}$</p>
</li>
<li><p>$(\arccos x)’=-\frac{1}{\sqrt{1-x^2}}$</p>
</li>
<li><p>$(\arctan x)’=\frac{1}{1-x^2}$</p>
</li>
<li><p>$({\rm arccot}\ x)’=-\frac{1}{1-x^2}$</p>
</li>
<li><p>$({\rm sh}\ x)’={\rm ch}\ x$</p>
</li>
<li><p>$({\rm ch}\ x)’={\rm sh}\ x$</p>
</li>
</ul>
<h3 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h3><p>$\ \ \ \ \ \ \,$这里简单地讲一下<strong> 一阶牛顿迭代 </strong>，牛顿迭代是应用在最优化领域非常重要的一种算法，由于具有二阶收敛性，所以相比二分法能大大降低迭代次数，只能求一个可导函数的零点，或者有二阶导函数的极值，一种全局搜索算法用来解np问题最优解的算法，在算法竞赛中的运用比较少见（<del>Psyduck说</del>）。</p>
<p>$\ \ \ \ \ \ \,$先放wiki的动图，牛顿迭代动态示例图：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CIMMV2UR-1644815019693)(<a href="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif">https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif</a>)]</p>
<p>$\ \ \ \ \ \ \,$容易看出一个重要问题：<strong>对函数的一个点做切线，这个切线与$x$轴的交点当做新的点，重复操作，得到的点就会越来越趋近于零点。</strong></p>
<p>$\ \ \ \ \ \ \,$具体证明涉及 <strong>泰勒展开</strong>，就不细讲了。</p>
<p>$\ \ \ \ \ \ \,$说到函数切线，自然就需要求导。</p>
<p>$\ \ \ \ \ \ \,$在$\ f(x)\ $上，点$\ x=a\ $的斜率为$f’(a)$，所以这个切线与$x$轴的交点当做新的点，应该是$\ a-\frac{f\left(a\right)}{f’\left(a\right)}\ $。</p>
<p>$\ \ \ \ \ \ \,$所以，我们定义:<br>$F(x)=F(x-1)-\frac{f\left(F(x-1)\right)}{f’\left(F(x-1)\right)}$</p>
<p>$\ \ \ \ \ \ \,$也就是不断去求点，可得这个点是越来越趋近某一个零点的。也就是说，我们的答案，就是$\ F(+∞)\ $，既函数$\ F(x)\ $的收敛值。</p>
<p>$\ \ \ \ \ \ \,$若$f(x)$二阶可导，那么在待求的零点$\ F(+∞)\ $值周围存在一个区域，只要起始点$\ F(0)\ $位于这个邻近区域内，那么牛顿迭代必定收敛。</p>
<p>$\ \ \ \ \ \ \,$不过……我们显然不需要算无限次，保证精度在一个范围内就行了，显然，牛顿迭代可以做到极快收敛到我们需要的精度，我们并不需要计算太多次。</p>
<p>$\ \ \ \ \ \ \,$我们最终答案的计算效率、精度，还与迭代系数，也就是最初赋值的$\ F(0)\ $有很大关系。（<del>但是因为比较小的x取值范围，本题没有卡迭代系数的选定</del>）。</p>
<p>$\ \ \ \ \ \ \,$然后贴出一阶牛顿迭代的模板：</p>
<p>$\ \ \ \ \ \ \,$（<del>如果迭代次数过少或者无解，那么会返回一个错误的答案</del>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Newton_Iteration</span><span class="params">(<span class="type">double</span> F,<span class="type">int</span> tim)</span></span>&#123;<span class="comment">//输入迭代系数F=F(0)，迭代次数tim</span></span><br><span class="line">  <span class="keyword">while</span>(tim--)F=F-<span class="built_in">f</span>(F)/<span class="built_in">f1</span>(F);<span class="comment">//f1(x)=f&#x27;(x)</span></span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$这里只是简单地讲一下<strong> 一阶牛顿迭代 </strong>，具体的讲解，有兴趣可以戳下面的链接，博主觉得讲得很清晰 <del>（还有互交动画啊XD）</del> 。</p>
<h2 id="—·—·—《推荐讲解文章》—·—·—"><a href="#—·—·—《推荐讲解文章》—·—·—" class="headerlink" title="—·—·—《推荐讲解文章》—·—·—"></a><a href="https://matongxue.com/madocs/205.html">—·—·—《推荐讲解文章》—·—·—</a></h2><p>$\ \ \ \ \ \ \,$而对于 <strong>二阶牛顿迭代</strong> 呢，就是在一阶导数上面做 <strong>一阶牛顿迭代</strong> ，求一阶导数上面的零点，就是求原函数的极值了，也就是下面这个函数的收敛值：</p>
<p>$F(x)=F(x-1)-\frac{f’\left(F(x-1)\right)}{f’’\left(F(x-1)\right)}$</p>
<p>$\ \ \ \ \ \ \,$例题在这里，是我出的:<a href="https://www.luogu.org/problemnew/show/P4986">【P4986 逃离】</a><a href="https://www.luogu.org/blog/Althen-Way-Satan/tao-li-ti-xie-post">【题解】</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>多项式</tag>
        <tag>牛顿迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值法</title>
    <url>/2018/12/29/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于拉格朗日插值法的复习笔记：</p>
<p>$\ \ \ \ \ \ \,$拉格朗日插值法,是解决多项式点值表达式函数值的问题的算法，具体而言，问题如下：</p>
<p>$\ \ \ \ \ \ \,$已知在二维平面上，一多项式$f$的函数图像经过 $n+1$ 个点 $(x_i,y_i)$ ，既我们知道 $f(x_i)=y_i$，求$f(k)$的值。</p>
<span id="more"></span>
<h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>$\ \ \ \ \ \ \,$显然，经过 $n+1$ 个点的多项式函数一定是$n$次函数，那么也很显然的，我们可以列出一个 $n$ 元方程组来解决这个问题，形如：</p>
<p>$\begin{cases}y_1=a_1\cdot x_1^n+a_2\cdot x_1^{n-1}+a_3\cdot x_1^{n-2}+…+a_{n+1}\\y_2=a_1\cdot x_2^n+a_2\cdot x_2^{n-1}+a_3\cdot x_2^{n-2}+…+a_{n+1}\\\ \ \ \ \ \ \ \ \ \ \ \ \ …\\y_n=a_1\cdot x_n^n+a_2\cdot x_n^{n-1}+a_3\cdot x_n^{n-2}+…+a_{n+1}\end{cases}$</p>
<p>$\ \ \ \ \ \ \,$直观的，我们可以高斯消元来做，复杂度$O(n^3)$，复杂度多半已上天，那么我们如何快速处理呢？</p>
<h2 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h2><p>$\ \ \ \ \ \ \,$我们现在知道的是 $f(x_i)=y_i$，那么我们想怎么快速表达出这个多项式，我们设定一种函数 $S_i$：</p>
<p>$S_i(x)=[x=x_i]$</p>
<p>$\ \ \ \ \ \ \,$它的意义是只有当 $x$ 为 $x_i$ 函数值才为 $1$，其他为 $0$，那么显然有：</p>
<p>$f=\sum_{i=1}^n y_i\cdot S_i$</p>
<p>$\ \ \ \ \ \ \,$很显然的，$S_i$ 是个 $n$ 次多项式，而我们的答案也就是：</p>
<p>$f(k)=\sum_{i=1}^n y_i\cdot S_i(k)$</p>
<p>$\ \ \ \ \ \ \,$遗憾地告诉你，光靠这个办法是不能还原$f$的函数图像的，只能得到近似图像，所以插值法是有一定误差的。</p>
<p>$\ \ \ \ \ \ \,$现在我们简化了问题，如何求$S_i$ 是个 $n$ 次多项式。</p>
<p>$\ \ \ \ \ \ \,$其实满足$S_i(x)$的函数取值合法挺简单的，主要问题是如何满足他是 $n$ 次多项式的事实，那么我们就先把它化作下面的形态：</p>
<p>$S_i(k)=\prod_{j=1,j\neq \rm something}^{n+1}a_jk+b_j$</p>
<p>$\ \ \ \ \ \ \,$如何就卡住了，我们不知道怎么办，但是还记得吗，我们只能得到近似图像，所以我们只需要满足$S_i(x)$的图像大约在$[x=x_i]$就行了，拉格朗日给了一种解法：</p>
<p>$S_i(k)=\prod_{j=1,j\neq i}^{n+1}\frac{k-x_j}{x_i-x_j}$</p>
<p>$\ \ \ \ \ \ \ \,$具体证明可以看这里：<a href="https://blog.csdn.net/VictoryCzt/article/details/82933843">【 VictoryCzt_拉格朗日插值法学习笔记】</a></p>
<p>$\ \ \ \ \ \ \ \,$所以得到拉格朗日公式（$n$个点），复杂度是$O(n^2)$的：</p>
<p>$f(k)=\sum_{i=1}^{n} y_i\prod_{j=1,j\neq i}^{n}\frac{k-x_j}{x_i-x_j}$</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>$\ \ \ \ \ \ \,$普通的拉格朗日差值法其实代码很简单了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Lagrange</span><span class="params">(<span class="type">double</span> *x,<span class="type">double</span> *y,<span class="type">double</span> n,<span class="type">double</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> top,bot,ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">double</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		top=<span class="number">1.0</span>;bot=<span class="number">1.0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">double</span> j=<span class="number">1</span>;j&lt;=n;++j)<span class="keyword">if</span>(i!=j)</span><br><span class="line">			top*=k-x[j],</span><br><span class="line">			bot*=x[i]-x[j];</span><br><span class="line">		ret+=y[i]*top/bot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$有些时候呢，我们的 $x_i$ 是连续的，所以说公式变形为：</p>
<p>$f(k)=\sum_{i=1}^{n} y_i\prod_{j=1,j\neq i}^{n}\frac{k-j}{i-j}$</p>
<p>$\ \ \ \ \ \ \,$我们令：</p>
<p>$pre_i=\prod_{j=1}^{i}(k-j)=pre_{i-1}\times(k-j)$</p>
<p>$suf_i=\prod_{j=i}^{n}(k-j)=suf_{i+1}\times(k-j)$</p>
<p>$\ \ \ \ \ \ \,$显然对于这两个函数是可以$O(n)$预处理的。</p>
<p>$\ \ \ \ \ \ \,$原公式可以化成：</p>
<p>$f(k)=\sum_{i=1}^{n} y_i \frac{pre_{i-1}\times suf_{i+1}}{(i-1)!\times(n-i)!}$</p>
<p>$\ \ \ \ \ \ \,$注意分母是有符号需要判断的，$n-i$为奇数时，分母为负。</p>
<p>$\ \ \ \ \ \ \,$显然阶乘也可以预处理，于是乎复杂度变成了$O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> pre[N],suf[N],fac[N];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Lagrange</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *y,<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> top,bot,ret=<span class="number">0</span>;</span><br><span class="line">	pre[<span class="number">0</span>]=suf[n+<span class="number">1</span>]=fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pre[i]=pre[i<span class="number">-1</span>]*(k-i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)suf[i]=suf[i+<span class="number">1</span>]*(k-i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)fac=fac*i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		top*=pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>],</span><br><span class="line">		bot*=fac[i<span class="number">-1</span>]*fac[n-i];</span><br><span class="line">		<span class="keyword">if</span>((n-i)&amp;<span class="number">1</span>) ret-=y[i]*top/bot;</span><br><span class="line">		<span class="keyword">else</span> ret+=y[i]*top/bot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题【Codeforces-Round-492-F-Cowmpany-Cowmpensation】"><a href="#例题【Codeforces-Round-492-F-Cowmpany-Cowmpensation】" class="headerlink" title="例题【Codeforces Round #492 F. Cowmpany Cowmpensation】"></a>例题<a href="https://codeforces.com/contest/995/problem/F">【Codeforces Round #492 F. Cowmpany Cowmpensation】</a></h2><p>$\ \ \ \ \ \ \,$题目大意：</p>
<p>$\ \ \ \ \ \ \,$给你一棵 $n$ 个节点的树,以 $1$ 为根节点,现在让你给每个节点分配一个权值$∈[1,D]$,使得每个节点的权值不超过他的父亲节点（ $1$ 号节点除外）,问一共有多少种分配方式。$(1≤n≤3000, 1≤D≤10^9)$。</p>
<p>$\ \ \ \ \ \ \,$显然直观的有一个二维树形dp的做法，一维表示当前节点，一维表示这个节点的取值情况，来描述方案数：</p>
<p>$f_{i,j}=\prod_{s\in Son_i}f_{s,j}+f_{i,j-1}$</p>
<p>$\ \ \ \ \ \ \,$答案就是$f_{1,D}$了。</p>
<p>$\ \ \ \ \ \ \,$复杂度为 $O(nD)$ 的，过不了，但是我们观察dp式子，可以发现……这个家伙是个多项式吧？继续大胆猜测，这个是个 $n$ 维多项式。</p>
<p>$\ \ \ \ \ \ \,$所以我们用dp来预处理出 $f_{1,i}\ ,\ {i\in[1,n+1]}$，然后使用拉格朗日差值法，便可以求出 $f_{1,D}$ 了，复杂度是 $O(n^2)$ 的。</p>
<p>$\ \ \ \ \ \ \,$代码如下，<del>取模真的取死人啊</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3030</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans=<span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=a*a%mod)<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> D;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)f[u][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(G[u][i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">		f[u][j]=(f[u][j]*f[G[u][i]][j])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n+<span class="number">1</span>;x++)f[u][x]=(f[u][x]+f[u][x<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> pre[N],suf[N],fac[N];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Lagrange</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *y,<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> k)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> top,bot,ret=<span class="number">0</span>,Fac;</span><br><span class="line">  pre[<span class="number">0</span>]=suf[n+<span class="number">1</span>]=Fac=<span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)pre[i]=(pre[i<span class="number">-1</span>]*(k-i+mod)%mod)%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=n;i&gt;=<span class="number">1</span>;i--)suf[i]=(suf[i+<span class="number">1</span>]*(k-i+mod)%mod)%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=n;i++)Fac=Fac*i%mod;</span><br><span class="line">  fac[n]=<span class="built_in">power</span>(Fac,mod<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)fac[i]=fac[i+<span class="number">1</span>]*<span class="number">1ll</span>*(i+<span class="number">1</span>)%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    top=(pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>]%mod)%mod,</span><br><span class="line">    bot=(fac[i<span class="number">-1</span>]*fac[n-i]%mod)%mod;</span><br><span class="line">    <span class="keyword">if</span>((n-i)&amp;<span class="number">1</span>)ret=(ret-(y[i]*top%mod*bot%mod)+mod)%mod;</span><br><span class="line">    <span class="keyword">else</span> ret=(ret+(y[i]*top%mod*bot%mod))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (ret+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;D);D%=mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,a;i&lt;=n;i++)</span><br><span class="line">	a=<span class="built_in">read</span>(),G[a].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(D&lt;=<span class="number">1ll</span>*n+<span class="number">1ll</span>)<span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>,f[<span class="number">1</span>][D]);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>,<span class="built_in">Lagrange</span>(f[<span class="number">1</span>],n+<span class="number">1</span>,D));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数学</tag>
        <tag>拉格朗日插值法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路，生成树和生成树形图相关</title>
    <url>/2018/12/29/%E6%9C%80%E7%9F%AD%E8%B7%AF-%E7%94%9F%E6%88%90%E6%A0%91%E5%92%8C%E7%94%9F%E6%88%90%E6%A0%91%E5%BD%A2%E5%9B%BE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$图论基础复习笔记：</p>
<span id="more"></span>
<h2 id="存图相关"><a href="#存图相关" class="headerlink" title="存图相关"></a>存图相关</h2><h3 id="1-邻接表："><a href="#1-邻接表：" class="headerlink" title="1.邻接表："></a>1.邻接表：</h3><p>$\ \ \ \ \ \ \ \,$在点数特别小的时候，我们可以用邻接表（二维数组）来表示点之间的链接关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> e[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span>&#123;e[a][b]=w;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-链表："><a href="#2-链表：" class="headerlink" title="2. 链表："></a>2. 链表：</h3><p>$\ \ \ \ \ \ \ \,$在点数比较大的时候，我们可以用链式向前星来表示点之间的链接关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> v,w,last;&#125;E[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;E[++p]=(Edge)&#123;b,w,head[a]&#125;;head[a]=p;&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$遍历方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)G[i].v,G[i].w;</span><br><span class="line"><span class="comment">//G[i].v就是u的直接连接点，G[i].w是边上信息</span></span><br></pre></td></tr></table></figure>
<h3 id="3-动态数组"><a href="#3-动态数组" class="headerlink" title="3.动态数组"></a>3.动态数组</h3><p>$\ \ \ \ \ \ \ \,$在点数比较大的时候，我们可以用$\tt vector$，会比链表慢一点，但是比较方便，下面默认都是这种存图方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> p,w;&#125;E[N];</span><br><span class="line">vector&lt;Edge&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;e[a].<span class="built_in">push_back</span>((Edge)&#123;b,w&#125;);&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$遍历方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])v.p,v.w;</span><br><span class="line"><span class="comment">//v.p就是u的直接连接点，v.w是边上信息</span></span><br></pre></td></tr></table></figure>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>$\ \ \ \ \ \ \ \,$最短路的核心思想都差不多，用松弛操作来求解，所以只讲算法特点和用法，不讲原理：</p>
<h3 id="1-Floyd"><a href="#1-Floyd" class="headerlink" title="1.Floyd"></a>1.Floyd</h3><p>$\ \ \ \ \ \ \ \,$Floyd可以在$O(n^3)$的时间内，求出任意点对两两之间的距离，支持负边权：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dis[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dis[i][i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:E[i])dis[i][v.p]=v.w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	<span class="keyword">if</span>(dist[i][j]&gt;dist[i][k]+dist[k][j])</span><br><span class="line">	dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="2-SPFA"><a href="#2-SPFA" class="headerlink" title="2.SPFA"></a>2.SPFA</h3><p>$\ \ \ \ \ \ \ \,$SPFA可以在下到$n$上到$(n^2)$的时间内，求出单源对于每个点最短路，支持负边权，但是因为复杂度不平衡，关于SPFA,他死了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  Q.<span class="built_in">push</span>(S);used[S]=<span class="number">1</span>;dis[S]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();used[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])</span><br><span class="line">    <span class="keyword">if</span>(dis[v.p]&gt;dis[u]+v.w)&#123;</span><br><span class="line">      dis[v.p]=dis[u]+v.w;</span><br><span class="line">      <span class="keyword">if</span>(used[v.p]==<span class="number">0</span>)</span><br><span class="line">			&#123;used[v.p]=<span class="number">1</span>;Q.<span class="built_in">push</span>(v.p);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$或者SPFA加上堆优化后，复杂度会比较好，长得也和Dijkstra很相像了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> v,dis;&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.dis&gt;b.dis;&#125;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line">priority_queue&lt;node&gt; Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_SPFA</span><span class="params">(<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  Q.<span class="built_in">push</span>((node)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	dis[S]=<span class="number">0</span>;used[S]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=Q.<span class="built_in">top</span>().v;Q.<span class="built_in">pop</span>();used[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])</span><br><span class="line">    <span class="keyword">if</span>(dis[v.p]&gt;dis[u]+v.w)&#123;</span><br><span class="line">      dis[v.p]=dis[u]+v.w;</span><br><span class="line">      <span class="keyword">if</span>(used[v.p]==<span class="number">0</span>)</span><br><span class="line">			&#123;used[v.p]=<span class="number">1</span>;Q.<span class="built_in">push</span>((node)&#123;dis[v.p],v.p&#125;)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Dijkstra"><a href="#3-Dijkstra" class="headerlink" title="3.Dijkstra"></a>3.Dijkstra</h3><p>$\ \ \ \ \ \ \ \,$Dijkstra可以在$O(n\log n)$的时间内，求出单源对于每个点最短路，但是不支持负边权：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> v,dis;&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.dis&gt;b.dis;&#125;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line">priority_queue&lt;node&gt; Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  	Q.<span class="built_in">push</span>((node)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);dis[S]=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    	<span class="type">int</span> u=Q.<span class="built_in">top</span>().v;Q.<span class="built_in">pop</span>();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])</span><br><span class="line">    	<span class="keyword">if</span>(dis[v.p]&gt;dis[u]+v.w)&#123;</span><br><span class="line">      		dis[v.p]=dis[u]+v.w;</span><br><span class="line">			Q.<span class="built_in">push</span>((node)&#123;dis[v.p],v.p&#125;);</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>$\ \ \ \ \ \ \ \,$生成树是针对无向图的说法，基本上是基于贪心的操作。</p>
<h3 id="1-最小生成树"><a href="#1-最小生成树" class="headerlink" title="1.最小生成树"></a>1.最小生成树</h3><p>$\ \ \ \ \ \ \ \,$最小生成树最常见的贪心做法是Kruskal，因为一棵树$n-1$条边，我们可以把所有边排序过后，贪心选取能构成树的最小的$n-1$条边，用并查集维护其连通性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> top,fa[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link</span>&#123;<span class="type">int</span> u,v,w;&#125;e[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Link &amp;a,<span class="type">const</span> Link &amp;b)&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> a==fa[a]?a:fa[a]=<span class="built_in">find</span>(fa[a]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span>&#123;e[++top]=(Link)&#123;a,b,w&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+top+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,A,B;i&lt;=m;i++)</span><br><span class="line">  <span class="keyword">if</span>((A=<span class="built_in">find</span>(e[i].u))!=(B=<span class="built_in">find</span>(e[i].v)))&#123;</span><br><span class="line">		<span class="built_in">add</span>(e[i].u,e[i].v,e[i].w);</span><br><span class="line">		<span class="built_in">add</span>(e[i].v,e[i].u,e[i].w);</span><br><span class="line">		fa[A]=B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-次小生成树-k小生成树-严格次小生成树"><a href="#2-次小生成树-k小生成树-严格次小生成树" class="headerlink" title="2.次小生成树\k小生成树\严格次小生成树"></a>2.次小生成树\k小生成树\严格次小生成树</h3><p>$\ \ \ \ \ \ \ \,$次小生成树，我们就是做如下操作：</p>
<ol>
<li><p>做一次最小生成树；</p>
</li>
<li><p>在没有加入树边的边中选一个最小的，假设为u与v之间的边；</p>
</li>
<li><p>在最小生成树上面$u$到$v$的路径上，删除一条最长的边；</p>
</li>
<li><p>然后把2步中选择的边加入树边。</p>
</li>
</ol>
<p>$\ \ \ \ \ \ \ \,$复杂度是$O(m\log m+n\log n)$，操作比较繁琐，虽然有些时候不需要真实建树，但是还是很繁琐，就不单独贴模板了。</p>
<p>$\ \ \ \ \ \ \ \,$对于k小生成树，我们做k次就好了啊，复杂度$O(m\log m+kn\log n)$。</p>
<p>$\ \ \ \ \ \ \ \,$对于严格次小生成树，我们做最多$m$次，检查直到严格大于最小生成树就停止，复杂度$O(m\log m+mn\log n)$。</p>
<h3 id="P4180-【模板】严格次小生成树-BJWC2010"><a href="#P4180-【模板】严格次小生成树-BJWC2010" class="headerlink" title="P4180 【模板】严格次小生成树[BJWC2010]"></a><a href="https://www.luogu.org/problemnew/show/P4180">P4180 【模板】严格次小生成树[BJWC2010]</a></h3><p>$\ \ \ \ \ \ \ \,$代码很长，引起不适：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> inf=<span class="number">2147483647000000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">900010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Cnt;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> p,w;&#125;E[N];</span><br><span class="line">vector&lt;Edge&gt; G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;G[a].<span class="built_in">push_back</span>((Edge)&#123;b,w&#125;);&#125;</span><br><span class="line"><span class="type">int</span> top,Fa[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link</span>&#123;<span class="type">int</span> u,v,w;&#125;e[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Link &amp;a,<span class="type">const</span> Link &amp;b)&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> a==Fa[a]?a:Fa[a]=<span class="built_in">find</span>(Fa[a]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span>&#123;e[++top]=(Link)&#123;a,b,w&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+top+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)Fa[i]=i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,A,B;i&lt;=m;i++)</span><br><span class="line">  <span class="keyword">if</span>((A=<span class="built_in">find</span>(e[i].u))!=(B=<span class="built_in">find</span>(e[i].v)))&#123;</span><br><span class="line">		<span class="built_in">add</span>(e[i].u,e[i].v,e[i].w);</span><br><span class="line">		<span class="built_in">add</span>(e[i].v,e[i].u,e[i].w);</span><br><span class="line">		Cnt+=<span class="number">1ll</span>*e[i].w;</span><br><span class="line">		used[i]=<span class="number">1</span>;</span><br><span class="line">		Fa[A]=B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">19</span>],deep[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Max[N][<span class="number">19</span>],Min[N][<span class="number">19</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  fa[u][<span class="number">0</span>]=f;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.p==f)<span class="keyword">continue</span>;</span><br><span class="line">    deep[v.p]=deep[u]+<span class="number">1</span>;</span><br><span class="line">    Max[v.p][<span class="number">0</span>]=v.w;</span><br><span class="line">    Min[v.p][<span class="number">0</span>]=-inf;</span><br><span class="line">    <span class="built_in">dfs</span>(v.p,u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;++i)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">    fa[j][i]=fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    Max[j][i]=<span class="built_in">max</span>(Max[j][i<span class="number">-1</span>],Max[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    Min[j][i]=<span class="built_in">max</span>(Min[j][i<span class="number">-1</span>],Min[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(Max[j][i<span class="number">-1</span>]&gt;Max[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>])</span><br><span class="line">		Min[j][i]=<span class="built_in">max</span>(Min[j][i],Max[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Max[j][i<span class="number">-1</span>]&lt;Max[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>])</span><br><span class="line">		Min[j][i]=<span class="built_in">max</span>(Min[j][i],Max[j][i<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(deep[x]&lt;deep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">  <span class="keyword">if</span>(deep[fa[x][i]]&gt;=deep[y])x=fa[x][i];</span><br><span class="line">  <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">  <span class="keyword">if</span>(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];</span><br><span class="line">  <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qmax</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> maxx)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> Ans=-inf;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">  <span class="keyword">if</span>(deep[fa[u][i]]&gt;=deep[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxx!=Max[u][i])Ans=<span class="built_in">max</span>(Ans,Max[u][i]);</span><br><span class="line">    <span class="keyword">else</span> Ans=<span class="built_in">max</span>(Ans,Min[u][i]);</span><br><span class="line">    u=fa[u][i];</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b,c;i&lt;=m;i++)</span><br><span class="line">	a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>(),</span><br><span class="line">	<span class="built_in">add_edge</span>(a,b,c);</span><br><span class="line">	<span class="built_in">Kruskal</span>();</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> Ans=inf;</span><br><span class="line">  Min[<span class="number">1</span>][<span class="number">0</span>]=-inf;</span><br><span class="line">  deep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="built_in">cal</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">    <span class="type">int</span> u=e[i].u,v=e[i].v,lca=<span class="built_in">LCA</span>(u,v);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d=e[i].w;</span><br><span class="line">    Ans=<span class="built_in">min</span>(Ans,Cnt-<span class="built_in">max</span>(<span class="built_in">qmax</span>(u,lca,d),<span class="built_in">qmax</span>(v,lca,d))+d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,Ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-斯坦纳树"><a href="#3-斯坦纳树" class="headerlink" title="3.斯坦纳树"></a>3.斯坦纳树</h3><p>$\ \ \ \ \ \ \ \,$当只要求图的一部分点连接的时候，求最小的生成树，就是斯坦纳树，做法比较繁琐，大数据也不能优秀地处理。具体看这里<a href="https://blog.csdn.net/VictoryCzt/article/details/82972857">【斯坦纳树学习笔记(VictoryCzt Orz)】</a>。</p>
<h2 id="生成树形图"><a href="#生成树形图" class="headerlink" title="生成树形图"></a>生成树形图</h2><p>$\ \ \ \ \ \ \ \,$树形图不是一个有很好求法的东西，朱刘算法可以做到复杂度$O(nm)$求出最小树形图，过程大概如下：</p>
<ol>
<li><p>找到除了$root$以为其他点的权值最小的入边，如果出现除了$root$以外存在其他孤立的点，则不存在最小树形图。</p>
</li>
<li><p>找到图中所有的环，并对环进行缩点，重新编号，更新其他点到环上的点的距离。</p>
</li>
<li><p>以环数为下一次查找的点数，继续执行上述操作，直到没有环或者判定出不存在最小树形图为止。</p>
</li>
</ol>
<p>$\ \ \ \ \ \ \ \,$大概就是这个图的意思：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b5fbfbb3e6872794a624ca4947d868ae.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,root;  </span><br><span class="line"><span class="type">int</span> k[N],idx[N],x,tim;</span><br><span class="line"><span class="type">int</span> cost[N],fa[N],f[N];</span><br><span class="line"><span class="type">int</span> mincost[N],ans,top;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link</span>&#123;<span class="type">int</span> u,v,w;&#125;e[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Link &amp;a,<span class="type">const</span> Link &amp;b)&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span>&#123;e[++top]=(Link)&#123;a,b,w&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Zhu_Liu</span><span class="params">(<span class="type">int</span> root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mincost,<span class="number">63</span>,<span class="built_in">sizeof</span>(mincost));</span><br><span class="line">    <span class="built_in">memset</span>(idx,<span class="number">-1</span>,<span class="built_in">sizeof</span>(idx));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="keyword">if</span>(e[i].w&lt;mincost[e[i].v]&amp;&amp;e[i].u!=e[i].v)</span><br><span class="line">		&#123;mincost[e[i].v]=e[i].w;fa[e[i].v]=e[i].u;&#125;</span><br><span class="line">    mincost[root]=<span class="number">0</span>;tim=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(mincost[i]==mincost[<span class="number">0</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      ans+=mincost[i];x=i;</span><br><span class="line">      <span class="keyword">while</span>(f[x]!=i&amp;&amp;x!=root)f[x]=i,x=fa[x];</span><br><span class="line">      <span class="keyword">if</span>(x!=root&amp;&amp;idx[x]==<span class="number">-1</span>)&#123;</span><br><span class="line">        tim++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=fa[x];j!=x;j=fa[j])idx[j]=tim;</span><br><span class="line">        idx[x]=tim;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tim==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(idx[i]==<span class="number">-1</span>)idx[i]=++tim;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">      x=e[i].v;e[i].u=idx[e[i].u];e[i].v=idx[e[i].v];</span><br><span class="line">      <span class="keyword">if</span>(e[i].u!=e[i].v)e[i].w-=mincost[x];</span><br><span class="line">    &#125;</span><br><span class="line">    n=tim;root=idx[root];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成树和生成树形图计数"><a href="#生成树和生成树形图计数" class="headerlink" title="生成树和生成树形图计数"></a>生成树和生成树形图计数</h2><p>$\ \ \ \ \ \ \ \,$计数的话，需要用到矩阵树定理：</p>
<p>$\ \ \ \ \ \ \ \,$<strong>图基尔霍夫矩阵的行列式值就是图的生成树个数</strong></p>
<p>$\ \ \ \ \ \ \ \,$对于生成树形图同样适用，把双向边和入度改为单向即可，通过线性代数技巧优化求行列式的复杂度，可以做到$O(n^3+nm)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> A[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	A[a][a]++;A[b][b]++;</span><br><span class="line">	A[a][b]--;A[b][a]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">		<span class="keyword">while</span>(A[j][i])&#123;</span><br><span class="line">			<span class="type">int</span> t=A[i][i]/A[j][i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;n;k++)</span><br><span class="line">			A[i][k]-=t*A[j][k];</span><br><span class="line">			<span class="built_in">swap</span>(A[j],A[i]);</span><br><span class="line">			ans=-ans;</span><br><span class="line">		&#125;</span><br><span class="line">		ans*=A[i][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>生成树形图</tag>
      </tags>
  </entry>
  <entry>
    <title>求多项式卷积的变换</title>
    <url>/2018/12/29/%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8D%B7%E7%A7%AF%E7%9A%84%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于导数和牛顿迭代的复习笔记：</p>
<span id="more"></span>
<h2 id="多项式的卷积"><a href="#多项式的卷积" class="headerlink" title="多项式的卷积"></a>多项式的卷积</h2><p>  $\ \ \ \ \ \ \,$在泛函分析中，卷积、旋积或摺积(英语：Convolution)是通过两个函数f 和g 生成第三个函数的一种数学算子，表征函数f 与g经过翻转和平移的重叠部分的面积。</p>
<p>  $\ \ \ \ \ \ \,$对于一个长度为 $n$ 的多项式 $f$ ,和一个长度为 $m$ 的多项式 $g$，那么他们的卷积就可以表达为：</p>
<p>  $(f \bigotimes g)_x = \sum_{i=0}^{x}f_i\cdot g_{x-i}$</p>
<p>  $\ \ \ \ \ \ \,$其中暴力求的复杂度会是$O(nm)$的，在很多情况下是不允许有这么多复杂度的，下面我们来引入一些快速变换：</p>
<h3 id="快速傅里叶变换（FFT）"><a href="#快速傅里叶变换（FFT）" class="headerlink" title="快速傅里叶变换（FFT）"></a>快速傅里叶变换（FFT）</h3><p>  $\ \ \ \ \ \ \,$这个算法算是非常常见的对卷积的处理了，讲起来也非常繁琐，留个链接<a href="https://www.luogu.org/blog/command-block/fft-xue-xi-bi-ji">【傅里叶变换(FFT)学习笔记】</a> <a href="https://blog.csdn.net/VictoryCzt/article/details/80971795">【VictoryCzt_FFT学习笔记】</a>。</p>
<p>  $\ \ \ \ \ \ \,$这里还有 $\tt 3Blue1Brown$ 的视频，可以形象理解一下：<a href="https://www.bilibili.com/video/av19141078">【形象展示傅里叶变换】</a></p>
<p>  $\ \ \ \ \ \ \,$然后就贴板子吧：</p>
<p>  $\ \ \ \ \ \ \,$依然是对于一个长度为 $n$ 的多项式 $f$ ,和一个长度为 $m$ 的多项式 $g$，那么他们的卷积就可以表达为：</p>
<p>  $(f \bigotimes g)_x = \sum_{i=1}^{x}f_i\cdot g_{x-i}$</p>
<p>  $\ \ \ \ \ \ \,$使用快速傅里叶变换（FFT）可以达到$O(n\log n)$的优秀复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cpx</span>&#123;</span><br><span class="line">	<span class="type">double</span> r,i;</span><br><span class="line">	<span class="keyword">inline</span> cpx <span class="keyword">operator</span> *(<span class="type">const</span> cpx&amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> (cpx)&#123;r*x.r-i*x.i,r*x.i+i*x.r&#125;;&#125;</span><br><span class="line">	<span class="keyword">inline</span> cpx <span class="keyword">operator</span> +(<span class="type">const</span> cpx&amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> (cpx)&#123;r+x.r,i+x.i&#125;;&#125;</span><br><span class="line">	<span class="keyword">inline</span> cpx <span class="keyword">operator</span> -(<span class="type">const</span> cpx&amp;x)<span class="type">const</span>&#123;<span class="keyword">return</span> (cpx)&#123;r-x.r,i-x.i&#125;;&#125;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line"><span class="type">int</span> m,n,R[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(cpx*a,<span class="type">int</span> f,<span class="type">int</span> la)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=la;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(i&lt;R[i])<span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		cpx wn=(cpx)&#123;<span class="built_in">cos</span>(pi/i),f*<span class="built_in">sin</span>(pi/i)&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">			cpx w=(cpx)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> k=<span class="number">0</span>;k&lt;i;++k,w=w*wn)&#123;</span><br><span class="line">				cpx x=a[j+k],y=w*a[j+k+i];</span><br><span class="line">				a[j+k]=x+y;a[j+k+i]=x-y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i].r/=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge_fft</span><span class="params">(cpx *a,cpx *b,<span class="type">int</span> la,<span class="type">int</span> lb)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=la,m=lb;</span><br><span class="line">	<span class="type">int</span> L=<span class="number">0</span>;<span class="keyword">for</span>(m+=n,n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>)L++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">	<span class="built_in">FFT</span>(a,<span class="number">1</span>,n);<span class="built_in">FFT</span>(b,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)a[i]=a[i]*b[i];</span><br><span class="line">	<span class="built_in">FFT</span>(a,<span class="number">-1</span>,n);</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治FFT"><a href="#分治FFT" class="headerlink" title="分治FFT"></a>分治FFT</h3><p>  $\ \ \ \ \ \ \,$对于一个长度为 $n$ 的多项式 $g$ ,和一个长度为 $n$ 的多项式 $f$，定义$f$为：</p>
<p>  $f_x=\sum_{i=1}^xf_{x-i}\cdot g_i$</p>
<p>  $\ \ \ \ \ \ \,$其中，$f_0=1$。</p>
<p>  $\ \ \ \ \ \ \,$很容易看出这个式子是卷积形式:</p>
<p>  $f_x=(f \bigotimes g)_x = \sum_{i=1}^{x}g_i\cdot f_{x-i}$</p>
<p>  $\ \ \ \ \ \ \,$我们想到上面提到的FFT算法，但是这里是$f$函数有卷之前算到的自己，所以我们第一次$f$的有效范围是$1$，卷一次，可以得到$f$有效范围是$2$，，再一次是$4$，就像倍增一样，所以我们的复杂度就应该是$O(n\log ^2 n)$。</p>
<p>  $\ \ \ \ \ \ \,$具体怎么做？</p>
<p>  $\ \ \ \ \ \ \,$假设对于$x$的取值区间$l$到$r$，我们知道了$l$到 $\frac{l+r}{2}$ 的$f_x$的值，那么我们令一个长度为 $\frac{r-l}{2}$ 的多项式 $A$ 等于这知道的 $\frac{r-l}{2}$ 项，我们现在想知道前面这一段对于后面 $\frac{l+r}{2}$ 到 $r$ 这一段的贡献是多少：</p>
<p>  $f_x= \sum_{i=1}^{x}g_i\cdot f_{x-i}$</p>
<p>  $f_x= \sum_{i=1}^{x}g_{x-i}\cdot f_i$</p>
<p>  $f_x= \sum_{i=1}^{x}g_{x-i}\cdot A_i$</p>
<p>  $f_x= g \bigotimes A$</p>
<p>  $\ \ \ \ \ \ \,$注意我们这里把$g$的长度只取前$r-l$个哦，因为$x$的范围限制，我们需要保证卷出来的长度是我们需要的。然后贴板子：<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq_FFT</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">  	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  	<span class="built_in">cdq_FFT</span>(l,mid);</span><br><span class="line">  <span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="built_in">sizeof</span>(A));<span class="built_in">memset</span>(G,<span class="number">0</span>,<span class="built_in">sizeof</span>(G));</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=mid;i++)A[i-l].r=(<span class="type">double</span>)f[i];</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r-l;i++)G[i<span class="number">-1</span>].r=(<span class="type">double</span>)g[i];</span><br><span class="line">  	<span class="built_in">merge_fft</span>(A,G,mid-l,r-l<span class="number">-1</span>);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++)f[i]+=(<span class="type">int</span>)A[i-l<span class="number">-1</span>].r;</span><br><span class="line">  	<span class="built_in">cdq_FFT</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  $\ \ \ \ \ \ \,$然而……要是你用这个就死了，主要是死在 $\tt memset$了，所以我们把 $\tt merge_fft$ 托下来：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq_FFT</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">  	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  	<span class="built_in">cdq_FFT</span>(l,mid);</span><br><span class="line">  	<span class="type">int</span> L=<span class="number">0</span>,n=<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(;n&lt;=r-l+<span class="number">1</span>;n&lt;&lt;=<span class="number">1</span>)L++;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  	R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">  A[i].r=G[i].r=A[i].i=G[i].i=<span class="number">0</span></span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=mid;i++)A[i-l].r=(<span class="type">double</span>)f[i];</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r-l;i++)G[i<span class="number">-1</span>].r=(<span class="type">double</span>)g[i];</span><br><span class="line">  	<span class="built_in">FFT</span>(A,<span class="number">1</span>,n);<span class="built_in">FFT</span>(G,<span class="number">1</span>,n);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)A[i]=A[i]*G[i];</span><br><span class="line">  	<span class="built_in">FFT</span>(A,<span class="number">-1</span>,n);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++)f[i]+=(<span class="type">int</span>)A[i-l<span class="number">-1</span>].r;</span><br><span class="line">  	<span class="built_in">cdq_FFT</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  $\ \ \ \ \ \ \,$至于洛谷那道模板题<a href="https://www.luogu.org/problemnew/show/P4721">P4721</a>还是算了吧，要取模，建议把FFT换成NTT，<del>（NTT模数明示）</del></p>
<p>  $\ \ \ \ \ \ \,$那么还有比$O(n\log ^2n)$更快的做法吗？当然有了啊，但是又要涉及生成函数的姿势，<del>还有<strong>多项式求逆！！！我不会啊！！！</strong></del></p>
<p>  $\ \ \ \ \ \ \,$先占坑:</p>
<p>  $\ \ \ \ \ \ \,$我们令$F$为$f$的生成函数，$G$为$g$的生成函数：</p>
<p>  $F(x)=\sum_{i=0}^{n}f_i\cdot x^i$</p>
<p>  $G(x)=\sum_{i=0}^{n}g_i\cdot x^i$</p>
<p>  $\ \ \ \ \ \ \,$那么就有：</p>
<p>  $\begin{aligned}F(x)\times  G(x) &amp;= \left(\sum_{i=0}^{n}f_i\cdot x^i\right)\cdot \left(\sum_{i=0}^{n}g_i\cdot x^i\right)\\&amp;=\sum_{i=0}^{n}x^i\sum_{j=0}^{i}g_j\cdot f_{i-j}\\&amp;=\sum_{i=0}^{n}x^i(f \bigotimes g)_i\end{aligned}$</p>
<p>  $\ \ \ \ \ \ \,$也就是说两个函数的生成函数的积，就是他们卷积的生成函数<del>@贝尔级数</del>。</p>
<p>  $\ \ \ \ \ \ \,$我们知道的$f_{mid+1,r}= f_{l,mid} \bigotimes g$，当然了，$f_0$是不满足这个卷积的，所以有：</p>
<p>  $F(x)\times  G(x)\equiv F(x)-f_0x^0\ \ (mod \ x^n)$</p>
<p>  $F(x)\times  G(x)\equiv F(x)-f_0\ \ (mod \ x^n)$</p>
<p>  $F(x)\times \left(1-G(x)\right)\equiv f_0\ \ (mod \ x^n)$</p>
<p>  $F(x)\equiv \frac{f_0}{1-G(x)}\ \ (mod \ x^n)$</p>
<p>  $F(x)\equiv \frac{1}{1-G(x)}\ \ (mod \ x^n)$</p>
<p>  $F(x)\equiv {(1-G(x))}^{-1}\ \ (mod \ x^n)$</p>
<p>  $\ \ \ \ \ \ \,$然后多项式求逆啊~，<del>并不会</del>，复杂度$O(n\log n)$，就不贴代码了啊。</p>
<hr>
<h2 id="快速数论变换（NTT）"><a href="#快速数论变换（NTT）" class="headerlink" title="快速数论变换（NTT）"></a>快速数论变换（NTT）</h2><p>  $\ \ \ \ \ \ \,$由于FFT是在复平面上操作变换，会用到很多的三角函数，丢精度非常严重，当有模数的时候且模数为NTT模数，形如$a\cdot 2^b+1$，且为素数的时候，常见的是$998244353$，我们推荐使用NTT来操作。</p>
<h3 id="【原根】-大巨佬orz"><a href="#【原根】-大巨佬orz" class="headerlink" title="- 【原根】%%%大巨佬orz"></a>- <a href="https://www.luogu.org/blog/hdxrie/yuan-gen">【原根】<del>%%%大巨佬orz</del></a></h3><ul>
<li><p>定义：</p>
<p>$\ \ \ \ \ \ \,$考虑方程$a^{x}\equiv 1(mod \ b)$，根据欧拉定理，当$a$与$b$互质的时候，一定有解$x=\varphi(b)$，如果$\varphi(b)$既为该方程的最小解，那么$a$就称为$(mod \ b)$的原根。</p>
</li>
<li><p>性质：</p>
<p>$\ \ \ \ \ \ \,1$、若$a$就为$(mod \ b)$的原根，那么集合$\{a^1,a^2,…,a^{b-1}\}=\{0,1,2,…,b-1\}$。也就是说，$a$的任意次方遍历了$(mod \ b)$的剩余系。</p>
<p>$\ \ \ \ \ \ \,2$、如果$(mod \ b)$意义下有原根，那么原根恰好有$\varphi(\varphi(b))$个，这个数量很小。</p>
<p>$\ \ \ \ \ \ \,3$、原根一般都不大，我们可以暴力从$2$到$b-1$枚举$a$，判断$a^{\varphi(b)}\equiv 1(mod \ b)$是否当且仅当$x=\varphi(b)$时成立，注意$x$的解仅有可能是$\varphi(b)$的约数，还有快的求法，可以用<strong>欧拉定理和裴蜀定理</strong>证明，可是我不会。</p>
<p>$\ \ \ \ \ \ \,$当然了，对于原根的理解我们只需要理解到它是$a^{x}\equiv 1(mod \ b)$的最小解，而且可以暴力求就行了<del>2333</del>就行了。</p>
<p>$\ \ \ \ \ \ \,$那么如何用到快速变换中去呢？</p>
<p>$\ \ \ \ \ \ \,$考虑FFT中的单位根$x^n=1$，现在在取模的意义下，就变成了$x^n\equiv 1\ \ (mod \ P)$，所以我们用原根$gn$去替换掉FFT中的单位根$wn$就好了呀，现在的问题是，原根具体怎么求：</p>
<p>$\ \ \ \ \ \ \,$对于一个NTT模数的原根，是有特殊求法的，这就是为什么一般NTT会有NTT模数这个限制：</p>
<p>$gn=g^{\frac{P-1}{2^{i+1}}}$</p>
<p>$\ \ \ \ \ \ \,$原根表在这里：<a href="http://blog.miskcoo.com/2014/07/fft-prime-table">【FFT用到的各种素数】</a></p>
<p>$\ \ \ \ \ \ \,$下面直接给板子了,这里的模数是$998244353$，原根是$3$：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> f,<span class="type">int</span> la)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=la;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(i&lt;R[i])<span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> gn=<span class="built_in">power</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">			<span class="type">int</span> g=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> k=<span class="number">0</span>;k&lt;i;++k,g=<span class="number">1ll</span>*g*gn%mod)&#123;</span><br><span class="line">				<span class="type">int</span> x=a[j+k],y=<span class="number">1ll</span>*g*a[j+k+i]%mod;</span><br><span class="line">				a[j+k]=(x+y)%mod;a[j+k+i]=(x-y+mod)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">		<span class="type">int</span> inv=<span class="built_in">power</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=<span class="number">1ll</span>*a[i]*inv%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge_ntt</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> la,<span class="type">int</span> lb)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=la,m=lb;</span><br><span class="line">	<span class="type">int</span> L=<span class="number">0</span>;<span class="keyword">for</span>(m+=n,n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>)L++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">1</span>,n);<span class="built_in">NTT</span>(b,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">-1</span>,n);</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  $\ \ \ \ \ \ \,$那么不是NTT模数的时候怎么办啊？我们不妨用CRT合并，具体在这里可以看到的<a href="/2018/12/30/由CRT合并引入的各种扩展求余和同余问题">【由CRT合并引入的各种扩展求余和同余问题】</a>。这个方法叫<strong>三模NTT</strong>，你可以用这个方法过洛谷的模板，但是写起来非常复杂。下面还有一种方法:</p>
<h3 id="MTT"><a href="#MTT" class="headerlink" title="MTT"></a>MTT</h3><p> <strong>Mettaton</strong></p>
<p>  <img src="https://img-blog.csdnimg.cn/img_convert/86d214ac619e9afde2057b6ba8d131b7.png" alt=""></p>
<p>  $\ \ \ \ \ \ \,$OH，YEAH~</p>
<p>  $\ \ \ \ \ \ \,$<del>（MTT就是镁塔顿啊，雾）</del></p>
<p>  $\ \ \ \ \ \ \,$好吧让我们重新打开一下：</p>
<p>  $\ \ \ \ \ \ \,$对于一个长度为$n$的多项式$f$，和一个常数$a$，我们知道可以这样运算：</p>
<p>  $\frac{f}{a}=\sum_{i=1}^{n}\frac{f_i}{a}$</p>
<p>  $\ \ \ \ \ \ \,$同理，对于一个长度为$n$的多项式$g$:</p>
<p>  $\frac{g}{a}=\sum_{i=1}^{n}\frac{g_i}{a}$</p>
<p>  $\ \ \ \ \ \ \,$那么有：</p>
<p>  $\left(\frac{f}{a} \bigotimes \frac{g}{a}\right)_x = \sum_{i=1}^{x}\frac{f_i}{a}\cdot \frac{g_{x-i}}{a}$</p>
<p>  $\frac{f}{a} \bigotimes \frac{g}{a}= \frac{f \bigotimes g}{a^2}$</p>
<p>  ${f \bigotimes g}= \left(\frac{f}{a} \bigotimes \frac{g}{a}\right)\times a^2$</p>
<p>  $\ \ \ \ \ \ \,$所以我们想，要是我们把每一项的系数拆了，最后合并不就是我们想要的答案了吗？于是就有了上面那个这个式子，但是很多时候并不能整除啊，就有了下面这个式子:</p>
<p>  ${f \bigotimes g }=\left(\frac{f}{a} \bigotimes \frac{g}{a}\right)\times a^2+\left({f}\%{a} \bigotimes \frac{g}{a}\right)\times a+\left(\frac{f}{a} \bigotimes {g}\%{a}\right)\times a+\left(f \% a \bigotimes g\%{a}\right)$</p>
<p>  $\ \ \ \ \ \ \,$就差不多这样了，取值$a$的时候需要保证用FFT时不会爆炸，不过也容易看出，这个算法精度特别特别卡，卡死了，需要开 $long\ double$ 还有一些特别的奇技淫巧，下面给出模板，$a=2^{15}$，这个板子因为精度问题是过不了洛谷的模板题的，看看就好：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(cpx *a,cpx *b,<span class="type">int</span> L,<span class="type">int</span> len,<span class="type">int</span> val,<span class="type">int</span> *Ret)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=L;i++)f[i]=a[i]*b[i];</span><br><span class="line">	<span class="built_in">FFT</span>(f,<span class="number">-1</span>,L);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	Ret[i]=(Ret[i]+<span class="number">1ll</span>*(<span class="type">long</span> <span class="type">long</span>)(f[i].r+<span class="number">0.5</span>)%mod*val%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_mtt</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B,<span class="type">int</span> la,<span class="type">int</span> lb,<span class="type">int</span> *Ret)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> M=<span class="number">32768</span>,L,l=<span class="number">0</span>,len=la;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(len&lt;&lt;<span class="number">1</span>);++i)a[i]=b[i]=c[i]=d[i]=(cpx)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)a[i].r=A[i]/M,b[i].r=A[i]%M;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)c[i].r=B[i]/M,d[i].r=B[i]%M;</span><br><span class="line">	<span class="keyword">for</span>(L=<span class="number">1</span>;L&lt;=len;L&lt;&lt;=<span class="number">1</span>)++l;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L;++i)R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">	<span class="built_in">FFT</span>(a,<span class="number">1</span>,L);<span class="built_in">FFT</span>(b,<span class="number">1</span>,L);<span class="built_in">FFT</span>(c,<span class="number">1</span>,L);<span class="built_in">FFT</span>(d,<span class="number">1</span>,L);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)Ret[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">merge</span>(a,c,L,len,M*M%mod,Ret);</span><br><span class="line">	<span class="built_in">merge</span>(b,c,L,len,M%mod,Ret);</span><br><span class="line">	<span class="built_in">merge</span>(a,d,L,len,M%mod,Ret);</span><br><span class="line">	<span class="built_in">merge</span>(b,d,L,len,<span class="number">1</span>,Ret);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)Ret[i]=(Ret[i]+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速沃尔什变换（FWT）"><a href="#快速沃尔什变换（FWT）" class="headerlink" title="快速沃尔什变换（FWT）"></a>快速沃尔什变换（FWT）</h2><p>  $\ \ \ \ \ \ \,$首先引入一种生成函数集合幂级数$F$，其中$f$ 是集合中的元素：</p>
<p>  $F=\sum_{s\subseteq O}f_s\cdot x^s$</p>
<p>  $\ \ \ \ \ \ \,$集合幂级数的集合卷积：</p>
<ul>
<li><p>交 $\bigcap$ （与 $and$）</p>
<p>$F\bigotimes_{\bigcap} G=\sum_{i\subseteq O}\sum_{j\subseteq O}f_i\times g_j[i\bigcap j=S]$</p>
</li>
<li><p>并 $\bigcup$ （或 $or$）</p>
<p>$F\bigotimes_{\bigcup} G=\sum_{i\subseteq O}\sum_{j\subseteq O}f_i\times g_j[i\bigcup j=S]$</p>
</li>
<li><p>对称差 $\Delta$ （异或 $xor$）</p>
<p>$F\bigotimes_{\Delta} G=\sum_{i\subseteq O}\sum_{j\subseteq O}f_i\Delta g_j[i\Delta=S]$</p>
<p>$\ \ \ \ \ \ \,$而快速沃尔什变换（FWT）就是快速求出集合幂级数的集合卷积的算法，证明在这里看<a href="https://blog.csdn.net/VictoryCzt/article/details/80879652#t7">【FWT(Fast Walsh Transformation)快速沃尔什变换学习笔记】</a>，下面给出结论和模板代码：</p>
<p>$\ \ \ \ \ \ \,$其中$x=a_{i+j}$，$y=a_{i+j+bit}$:</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算方式</th>
<th style="text-align:center">交 $\bigcap$ （与 $and$）</th>
<th style="text-align:center">并 $\bigcup$ （或 $or$）</th>
<th style="text-align:center">对称差 $\Delta$ （异或 $xor$）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">沃尔什变换</td>
<td style="text-align:center">$a_{i+j}=x+y$</td>
<td style="text-align:center">$a_{i+j+bit}=x+y$</td>
<td style="text-align:center">$a_{i+j}=x+y$,$a_{i+j+bit}=x-y$</td>
</tr>
<tr>
<td style="text-align:center">沃尔什逆变换</td>
<td style="text-align:center">$a_{i+j}=x-y$</td>
<td style="text-align:center">$a_{i+j+bit}=y-x$</td>
<td style="text-align:center">$a_{i+j}=\frac{x+y}{2}$,$a_{i+j+bit}=\frac{x-y}{2}$</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> f,<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">    <span class="type">int</span> p=a[j+k],q=a[j+k+i];</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)&#123;<span class="comment">//and &amp;</span></span><br><span class="line">      a[j+k]=(<span class="number">1ll</span>*f*q+p+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;<span class="comment">//or |</span></span><br><span class="line">      a[j+k+i]=(<span class="number">1ll</span>*f*p+q+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">3</span>)&#123;<span class="comment">//xor ^</span></span><br><span class="line">      a[j+k]=(p+q)%mod;</span><br><span class="line">      a[j+k+i]=(p-q+mod)%mod;</span><br><span class="line">      <span class="keyword">if</span>(f==<span class="number">-1</span>)&#123;</span><br><span class="line">        a[j+k]=<span class="number">1ll</span>*a[j+k]*inv2%mod;</span><br><span class="line">        a[j+k+i]=<span class="number">1ll</span>*a[j+k+i]*inv2%mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_fwt</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> lim,<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">  <span class="built_in">FWT</span>(a,lim,<span class="number">1</span>,type);<span class="built_in">FWT</span>(b,lim,<span class="number">1</span>,type);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++)a[i]=(<span class="type">long</span> <span class="type">long</span>)a[i]*b[i]%mod;</span><br><span class="line">  <span class="built_in">FWT</span>(a,lim,<span class="number">-1</span>,type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>多项式</tag>
        <tag>NTT</tag>
        <tag>FFT</tag>
        <tag>FWT</tag>
        <tag>MTT</tag>
      </tags>
  </entry>
  <entry>
    <title>树分治</title>
    <url>/2019/01/03/%E6%A0%91%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于树分治的复习笔记：</p>
<span id="more"></span>
<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p>$\ \ \ \ \ \ \ \,$树链剖分也叫轻重链剖分，一般会套一个线段树，相当于一个优化过的DFS序，用每次优先遍历重儿子达到优化目的，常用于处理：</p>
<ol>
<li><p>关于两点间路径的询问和修改（$O(n\log^2n)$）</p>
</li>
<li><p>关于某点子树的询问和修改（$O(n\log n)$），这里只用到了DFS序。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree_Chain_Dissection</span>&#123;</span><br><span class="line">	<span class="type">int</span> idx[N],w[N];</span><br><span class="line">	<span class="type">int</span> deep[N],fa[N],son[N],tot[N];</span><br><span class="line">	<span class="type">int</span> cnt,top[N];</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> f,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">	  deep[a]=deep[fa[a]=f]+<span class="number">1</span>;tot[a]=<span class="number">1</span>;</span><br><span class="line">	  <span class="type">int</span> maxson=<span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[a])</span><br><span class="line">	  <span class="keyword">if</span>(v!=f)&#123;</span><br><span class="line">	    tot[a]+=<span class="built_in">dfs1</span>(v,a,dep+<span class="number">1</span>);</span><br><span class="line">	    <span class="keyword">if</span>(tot[v]&gt;maxson) </span><br><span class="line">	    maxson=tot[v],son[a]=v;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> tot[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">	  v[idx[a]=++cnt]=w[a];top[a]=topf;</span><br><span class="line">	  <span class="keyword">if</span>(!son[a])<span class="keyword">return</span>;</span><br><span class="line">	  <span class="built_in">dfs2</span>(son[a],topf);</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[a])</span><br><span class="line">	  <span class="keyword">if</span>(!idx[v])<span class="built_in">dfs2</span>(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 	<span class="built_in">dfs1</span>(rt,<span class="number">0</span>,<span class="number">1</span>);<span class="built_in">dfs2</span>(rt,rt);</span><br><span class="line">	  Seg.<span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Query_Chain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//满足交换律</span></span><br><span class="line">	  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">	    <span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">	    ans=(ans+Seg.<span class="built_in">query</span>(idx[top[x]],idx[x],<span class="number">1</span>,n,<span class="number">1</span>))%mod;</span><br><span class="line">	    x=fa[top[x]];</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span>(deep[x]&gt;deep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">	  ans=(ans+Seg.<span class="built_in">query</span>(idx[x],idx[y],<span class="number">1</span>,n,<span class="number">1</span>))%mod;</span><br><span class="line">	  <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Updata_Chain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	  <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">	    <span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	    Seg.<span class="built_in">updata</span>(idx[top[x]],idx[x],val,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	    x=fa[top[x]];</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span>(deep[x]&gt;deep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	  Seg.<span class="built_in">updata</span>(idx[x],idx[y],val,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Query_Tree</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;<span class="keyword">return</span> Seg.<span class="built_in">query</span>(idx[x],idx[x]+tot[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Updata_Tree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;Seg.<span class="built_in">updata</span>(idx[x],idx[x]+tot[x]<span class="number">-1</span>,val,<span class="number">1</span>,n,<span class="number">1</span>);&#125;</span><br><span class="line">&#125;TCD;</span><br></pre></td></tr></table></figure>
<h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><p>$\ \ \ \ \ \ \ \,$点分治是一种分治策略，其核心在于寻找树的重心，从重心分治解决，从而优化复杂度，实现的$O(n\log n)$分治复杂度，算上分治的操作可能复杂度会更高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> K,root,sum;</span><br><span class="line"><span class="type">int</span> f[N],size[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  size[u]=<span class="number">1</span>;f[u]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[v]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">getroot</span>(v,u);</span><br><span class="line">    size[u]+=size[v];</span><br><span class="line">    f[u]=<span class="built_in">max</span>(f[u],size[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  f[u]=<span class="built_in">max</span>(f[u],sum-size[u]);</span><br><span class="line">  <span class="keyword">if</span>(f[u]&lt;f[root]) root=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="comment">//something</span></span><br><span class="line">  used[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])</span><br><span class="line">  <span class="keyword">if</span>(!used[v])&#123;</span><br><span class="line">    root=<span class="number">0</span>;sum=size[v];</span><br><span class="line">    <span class="built_in">getroot</span>(v,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getans</span>(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$顺带一提动态点分治（点分树），只需要把重儿子重新连在一个图里，这样子我们会得到一个类似于二叉树的新树，每次修改操作的影响我们可以暴力上传，复杂度为$O(n\log n)$，算上细节的操作可能复杂度会更高。</p>
<h2 id="边分治"><a href="#边分治" class="headerlink" title="边分治"></a>边分治</h2><p>$\ \ \ \ \ \ \ \,$边分治的思想是把一棵树每次找到一个边，使得去掉这个边后，留下的两棵树尽量一样大（重边），分治下去，使得复杂度降至$O(n\log n)$分治复杂度，算上分治的操作可能复杂度会更高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> size[N],ctedge,sum;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getctedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  size[u]=<span class="number">1</span>;f[u]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[G[i].v]||G[i].v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">getctedge</span>(G[i].v,u);</span><br><span class="line">    size[u]+=size[G[i].v];</span><br><span class="line">  	<span class="type">int</span> siz=<span class="built_in">max</span>(size[G[i].v],sum-size[G[i].v]);</span><br><span class="line">    <span class="keyword">if</span>(siz&lt;ctsiz)ctsiz=siz,ctedge=i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="comment">//something</span></span><br><span class="line">  used[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">  <span class="keyword">if</span>(!used[G[i].v])&#123;</span><br><span class="line">    ctedge=<span class="number">0</span>;sum=size[G[i].v];</span><br><span class="line">    <span class="built_in">getroot</span>(G[i].v,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">getans</span>(G[ctedge].v);</span><br><span class="line">	<span class="built_in">getans</span>(G[ctedge].from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>树链剖分</tag>
        <tag>点分治</tag>
        <tag>边分治</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P4883 mzf的考验 简易题解【fhq treap】</title>
    <url>/2019/03/12/%E6%B4%9B%E8%B0%B7-P4883-mzf%E7%9A%84%E8%80%83%E9%AA%8C-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3-fhq-treap/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.org/problemnew/show/P4883">洛谷 P4883 mzf的考验</a></p>
<span id="more"></span>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><hr>
<p>$\ \ \ \ \ \ \,$首先我们看他的操作：</p>
<ul>
<li>$opt==1$：两个正整数：$l$，$r$。请翻转区间$[l,r]$；</li>
<li>$opt==2$：三个正整数：$l$，$r$，$d$。请将区间$[l,r]$中的所有卦象都异或卦象$d$;</li>
<li>$opt==3$：两个正整数：$l$，$r$。请查询区间$[l,r]$的卦象权值和。</li>
</ul>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \ \,$显然是一个平衡树可以做的啦，我们试着选择$Fhq_treap$ 做一下：</p>
<p>$\ \ \ \ \ \ \,$对于操作 $1$，$3$ 操作很简单，我们 $pushup$ 一下子树和， $pushdown$ 一下旋转标记，提出区间 $[l,r]$ 进行对应的操作就可以了。</p>
<p>$\ \ \ \ \ \ \,$那么对应的 $2$ 操作似乎没有那么简单操作了，我们先看看我们需要修改的 $pushdown$ 操作是什么：</p>
<ol>
<li>单点权值$(val)$：直接异或上修改的值，在$pushdown$操作的时候同理。</li>
<li>权值懒人标记$(lazy_w)$：直接异或上修改的值，在$pushdown$操作的时候同理。</li>
<li>子树和$(sum)$：？</li>
</ol>
<p>$\ \ \ \ \ \ \,$可以发现子树和的处理特别麻烦，但是对于异或问题，我们通常可以拆位解决，对于每一个节点，我们新开一个数组 $num[i]$ ，表示这个子树内的值，数位 $i$ 上面为 $1$ 的值是多少，这个很显然，我们可以通过 $pushup$ 一并传递上去。</p>
<p>$\ \ \ \ \ \ \,$如何处理子树和呢？因为打了标记的子树都要异或这一个值，所以我们把这个值拆了，如果这一位为 $1$ ，那么子树这一位都会 $1$变$0$，$0$变$1$，所以说有：</p>
<p>$num[i]=size-num[i]$</p>
<p>$\ \ \ \ \ \ \,$其中$size$为子树大小，修改了$num$数组之后，我们就可以重新计算子树和了：</p>
<p>$sum=\sum_{i=0}^{limit}2^i\times num[i]$</p>
<p>$\ \ \ \ \ \ \,$所以 $pushup$ 和 $pushdown$ 差不多应该是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Xor</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	lazy_w[rt]^=x;val[rt]^=x;</span><br><span class="line">    sum[rt]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)tmp[i]=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(tmp[i])num[rt][i]=size[rt]-num[rt][i];</span><br><span class="line">      	sum[rt]+=(<span class="number">1ll</span>&lt;&lt;i)*num[rt][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">	sum[rt]=sum[lson]+sum[rson]+<span class="number">1ll</span>*val[rt];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">	num[rt][i]=num[lson][i]+num[rson][i]+((val[rt]&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lazy[rt])&#123;</span><br><span class="line">		<span class="built_in">swap</span>(lson,rson);</span><br><span class="line">		<span class="keyword">if</span>(lson)lazy[lson]^=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(rson)lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">		lazy[rt]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lazy_w[rt])&#123;</span><br><span class="line">		<span class="type">int</span> x=lazy_w[rt];lazy_w[rt]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(lson)&#123;<span class="built_in">Xor</span>(lson,x);&#125;</span><br><span class="line">		<span class="keyword">if</span>(rson)&#123;<span class="built_in">Xor</span>(rson,x);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$总期望复杂度应该是$O(n\log n\ limit)$，其中$limit=\log val$</p>
<p>$\ \ \ \ \ \ \,$懒得卡常了，吸氧过：</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_treap</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">	<span class="type">int</span> ls[N],rs[N];</span><br><span class="line">	<span class="type">bool</span> lazy[N];</span><br><span class="line">	<span class="type">int</span> lazy_w[N],val[N],key[N],size[N];</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum[N];</span><br><span class="line">	<span class="type">int</span> root,cnt;</span><br><span class="line">	<span class="type">int</span> tmp[<span class="number">25</span>],num[N][<span class="number">25</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Xor</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		lazy_w[rt]^=x;val[rt]^=x;</span><br><span class="line">    	sum[rt]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)tmp[i]=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">  		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line">      		<span class="keyword">if</span>(tmp[i])num[rt][i]=size[rt]-num[rt][i];</span><br><span class="line">      		sum[rt]+=(<span class="number">1ll</span>&lt;&lt;i)*num[rt][i];</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">		sum[rt]=sum[lson]+sum[rson]+<span class="number">1ll</span>*val[rt];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">		num[rt][i]=num[lson][i]+num[rson][i]+((val[rt]&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lazy[rt])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(lson,rson);</span><br><span class="line">			<span class="keyword">if</span>(lson)lazy[lson]^=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(rson)lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">			lazy[rt]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(lazy_w[rt])&#123;</span><br><span class="line">			<span class="type">int</span> x=lazy_w[rt];lazy_w[rt]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(lson)&#123;<span class="built_in">Xor</span>(lson,x);&#125;</span><br><span class="line">			<span class="keyword">if</span>(rson)&#123;<span class="built_in">Xor</span>(rson,x);&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!a||!b)<span class="keyword">return</span> a|b;</span><br><span class="line">		<span class="keyword">if</span>(key[a]&lt;key[b])&#123;<span class="built_in">pushdown</span>(a);rs[a]=<span class="built_in">merge</span>(rs[a],b);<span class="built_in">pushup</span>(a);<span class="keyword">return</span> a;&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="built_in">pushdown</span>(b);ls[b]=<span class="built_in">merge</span>(a,ls[b]);<span class="built_in">pushup</span>(b);<span class="keyword">return</span> b;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!rt)&#123;a=b=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=size[lson])&#123;b=rt;<span class="built_in">split</span>(lson,x,a,lson);&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;a=rt;<span class="built_in">split</span>(rson,x-size[lson]<span class="number">-1</span>,rson,b);&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> rt=++cnt;</span><br><span class="line">		size[rt]=<span class="number">1</span>;val[rt]=x;key[rt]=<span class="built_in">rand</span>();</span><br><span class="line">		lazy[rt]=<span class="number">0</span>;lazy_w[rt]=<span class="number">0</span>;</span><br><span class="line">		lson=rson=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> rt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">		stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">		<span class="type">int</span> rt,last;</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">	    rt=<span class="built_in">newnode</span>(a[i]);last=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>()&amp;&amp;key[S.<span class="built_in">top</span>()]&gt;key[rt])</span><br><span class="line">			<span class="built_in">pushup</span>(last=S.<span class="built_in">top</span>()),S.<span class="built_in">pop</span>();</span><br><span class="line">	    	<span class="keyword">if</span>(!S.<span class="built_in">empty</span>())rs[S.<span class="built_in">top</span>()]=rt;</span><br><span class="line">	    	lson=last;S.<span class="built_in">push</span>(rt);</span><br><span class="line">	  	&#125;</span><br><span class="line">	  	<span class="keyword">while</span>(!S.<span class="built_in">empty</span>())<span class="built_in">pushup</span>(last=S.<span class="built_in">top</span>()),S.<span class="built_in">pop</span>();</span><br><span class="line">	  	<span class="keyword">return</span> last; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Revers</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">split</span>(root,r,a,c);</span><br><span class="line">		<span class="built_in">split</span>(a,l<span class="number">-1</span>,a,b);</span><br><span class="line">		lazy[b]^=<span class="number">1</span>;</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">split</span>(root,r,a,c);</span><br><span class="line">		<span class="built_in">split</span>(a,l<span class="number">-1</span>,a,b);</span><br><span class="line">		<span class="built_in">Xor</span>(b,d);</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">split</span>(root,r,a,c);</span><br><span class="line">		<span class="built_in">split</span>(a,l<span class="number">-1</span>,a,b);</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> ret=sum[b];</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Tree;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],op,l,r,d;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">	Tree.root=Tree.<span class="built_in">build</span>(a,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		op=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)Tree.<span class="built_in">Revers</span>(l,r);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>)d=<span class="built_in">read</span>(),Tree.<span class="built_in">Update</span>(l,r,d);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">3</span>)cout&lt;&lt;Tree.<span class="built_in">Query</span>(l,r)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Fhq_Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1110\BZOJ1058 [ZJOI2007]报表统计</title>
    <url>/2019/03/12/%E6%B4%9B%E8%B0%B7P1110-BZOJ1058-ZJOI2007-%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P1110">洛谷P1110\BZOJ1058 [ZJOI2007]报表统计</a></p>
<span id="more"></span>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>第一次看见这个题：想了一会，woc，三颗平衡树，好麻烦呀，先放一放。</p>
<p>第二次看见这个题：想了一会，woc，平衡树加线段树，好麻烦呀，先放一放。</p>
<p>第三次看见这个题：想了一会，woc，一棵权值平衡树加一棵位置平衡树，好麻烦呀，先放一放。</p>
<p>第四次看见这个题：想了一会，woc，一棵平衡树加堆，好麻烦呀……诶等等，好像可以就开两个差不多的平衡树就行了……</p>
<hr>
<p>写的时候脑袋有点懵，不过还是肝好了呢。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>当他插入的时候，显然可以发现，就是在堆里面删除元素：$abs(head[id+1]-tail[id])$；然后插入两个新元素：$abs(head[id+1]-new)$，$abs(new-tail[id])$。然后新的 $tail[id]$ 再附上 $new$。每次询问 $MIN\_GAP$ 就是询问堆里面的最小值了。</p>
<p>支持删除，插入，查询权值最小，显然可以用平衡树去搞。</p>
<p>对于第二种询问，单独插入一个元素，我们需要在集合里面查找他的前驱和后继，便可以计算最小的差值，显然这个询问的答案是单调的，所以我们开全局变量去记录。</p>
<p>支持插入，查前驱，查后继，显然可以又用平衡树去搞。</p>
<p>这里我用了我喜欢的$Fhq\_Treap$，然后前驱后继是直接查的，其实可以通过$pushup$上传最大最小值，但是不知道为什么会慢一点，然后卡了会儿常，代码有点丑：</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Abs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)<span class="keyword">return</span> -a;<span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)<span class="keyword">return</span> a;<span class="keyword">return</span> b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)<span class="keyword">return</span> a;<span class="keyword">return</span> b;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_treap_val</span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">  <span class="type">int</span> val[N],size[N],key[N];</span><br><span class="line">  <span class="type">int</span> ls[N],rs[N];</span><br><span class="line">  <span class="type">int</span> root,cnt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;size[rt]=size[lson]+size[rson]+<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||!b)<span class="keyword">return</span> a|b;</span><br><span class="line">    <span class="keyword">if</span>(key[a]&lt;key[b])&#123;rs[a]=<span class="built_in">merge</span>(rs[a],b);<span class="built_in">pushup</span>(a);<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ls[b]=<span class="built_in">merge</span>(a,ls[b]);<span class="built_in">pushup</span>(b);<span class="keyword">return</span> b;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt)&#123;a=b=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(val[rt]&lt;=x)&#123;a=rt;<span class="built_in">split</span>(rson,x,rson,b);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;b=rt;<span class="built_in">split</span>(lson,x,a,lson);&#125;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;<span class="keyword">while</span>(rson)rt=rson;<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;<span class="keyword">while</span>(lson)rt=lson;<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=++cnt;</span><br><span class="line">    val[rt]=x;</span><br><span class="line">    size[rt]=<span class="number">1</span>;key[rt]=<span class="built_in">rand</span>();</span><br><span class="line">    lson=rson=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">    <span class="type">int</span> rt=<span class="built_in">newnode</span>(x);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,rt),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert_2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">    <span class="keyword">if</span>(size[a])ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(x-<span class="built_in">Max</span>(a)));</span><br><span class="line">    <span class="keyword">if</span>(size[b])ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(<span class="built_in">Min</span>(b)-x));</span><br><span class="line">    <span class="type">int</span> rt=<span class="built_in">newnode</span>(x);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,rt),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,c);</span><br><span class="line">    <span class="built_in">split</span>(a,x<span class="number">-1</span>,a,b);</span><br><span class="line">    b=<span class="built_in">merge</span>(ls[b],rs[b]);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;T1,T2;</span><br><span class="line"><span class="type">int</span> n,m,a[N],b[N],id,g;</span><br><span class="line"><span class="type">char</span> op[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=b[i]=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)T1.<span class="built_in">Insert</span>(<span class="built_in">Abs</span>(a[i+<span class="number">1</span>]-a[i]));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)T2.<span class="built_in">Insert_2</span>(a[i]);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">      id=<span class="built_in">read</span>();g=<span class="built_in">read</span>();</span><br><span class="line">      T2.<span class="built_in">Insert_2</span>(g);</span><br><span class="line">      <span class="keyword">if</span>(id!=n)&#123;</span><br><span class="line">        T1.<span class="built_in">Delete</span>(<span class="built_in">Abs</span>(a[id+<span class="number">1</span>]-b[id]));</span><br><span class="line">        T1.<span class="built_in">Insert</span>(<span class="built_in">Abs</span>(a[id+<span class="number">1</span>]-g));</span><br><span class="line">      &#125;</span><br><span class="line">      T1.<span class="built_in">Insert</span>(<span class="built_in">Abs</span>(b[id]-g));</span><br><span class="line">      b[id]=g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">4</span>]==<span class="string">&#x27;G&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T1.<span class="built_in">Min</span>(T1.root));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Fhq_Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>线性筛</title>
    <url>/2018/12/30/%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$利用线性欧拉筛筛选常见积性函数的模板总结：</p>
<span id="more"></span>
<h2 id="用欧拉筛法线性筛素数"><a href="#用欧拉筛法线性筛素数" class="headerlink" title="- 用欧拉筛法线性筛素数"></a>- 用欧拉筛法线性筛素数</h2><p>$\ \ \ \ \ \,$我们知道，若$x$为素数的话，那么必然若有任意一个不为$1$的数$a$，$(a\cdot x)$不是素数，打上标记。</p>
<p>$\ \ \ \ \ \,$并且必然有$a&lt;a\cdot x$，$x&lt;a\cdot x$，所以我们不断枚举$a$，在之前若是没有被打上标记，那么$a$就是素数。再不断枚举之前筛出来的素数$x$，对范围$[a,n]$中的$(a\cdot x)$打上标记。</p>
<p>$\ \ \ \ \ \,$若是当前$a$已经是某一个$x$的倍数，那么我们便可不必向后枚举$x$了，因为后面的$(a\cdot x)$一定被打过标记了，这样子可以保证每一个数最多被打过一次标记，复杂度严格$O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//prime[0]为素数个数。</span></span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> prime[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Prime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">	used[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!used[i])prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">			used[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用欧拉筛法线性筛欧拉函数-varphi-，莫比乌斯函数-mu"><a href="#用欧拉筛法线性筛欧拉函数-varphi-，莫比乌斯函数-mu" class="headerlink" title="- 用欧拉筛法线性筛欧拉函数$\varphi$，莫比乌斯函数$\mu$"></a>- 用欧拉筛法线性筛欧拉函数$\varphi$，莫比乌斯函数$\mu$</h2><ul>
<li>筛欧拉函数$\varphi$</li>
</ul>
<p>$\ \ \ \ \ \,$根据欧拉函数$\varphi$的3条性质:</p>
<p>$\ \ \ \ \ \,1$.若$x$为素数，$\varphi(x)=x-1$;</p>
<p>$\ \ \ \ \ \,2$.若$x\%p=0$，$\varphi(x\cdot p)=\varphi(x)\cdot p$;</p>
<p>$\ \ \ \ \ \,3$.若$x\%p\neq 0$，且$p$为素数，$\varphi(x\cdot p)=\varphi(x)\cdot (p-1)$;</p>
<p>$\ \ \ \ \ \,$稍微改动一下线性筛素数就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],phi[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Phi</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;phi[i]=i<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)&#123;phi[i*prim[j]]=phi[i]*prim[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">      phi[i*prim[j]]=phi[i]*(prim[j]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>筛莫比乌斯函数$\mu$</li>
</ul>
<p>$\ \ \ \ \ \,$根据性质，若$x$为素数，$\mu(x)=-1$；对于任意数$a$，存在$\mu(a\cdot x)=-\mu(a)$。</p>
<p>$\ \ \ \ \ \,$再稍微改动一下线性筛素数就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],mu[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Mu</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;mu[i]=<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">      mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对于任意积性函数-f-线性筛"><a href="#对于任意积性函数-f-线性筛" class="headerlink" title="- 对于任意积性函数$f$线性筛"></a>- 对于任意积性函数$f$线性筛</h2><p>$\ \ \ \ \ \,$对于任意积性函数$f$，我们如何线性筛。</p>
<ul>
<li><p>如果$p$是素数：$f(p)=F_1(p)$</p>
</li>
<li><p>如果$p$是素数，$i\%p\neq0$：$f(pi)=f(i)\times F_2(p)$</p>
</li>
<li><p>如果$p$是素数，$i\%p=0$：</p>
<p>我们把 $pi$ 分解成 $p^cx$ ,可以保证 $p^c$ 与 $x$互质，那么有：$f(pi)=f(p^cx)=f(x)*F_3(p,c)$</p>
</li>
</ul>
<p>$\ \ \ \ \ \,$其中，函数$F_1$,$F_2$,$F_3$需要情况制定，模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> pri[N],cnt[N],power[N];</span><br><span class="line"><span class="type">int</span> prime[N],f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Shai</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)power[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                cnt[i]=<span class="number">1</span>;pri[i]=i;power[i]=i;</span><br><span class="line">                prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">                f[i]=<span class="built_in">F1</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,v,pc;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">            v=i*prime[j];</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                cnt[v]=cnt[i]+<span class="number">1</span>;pri[v]=pri[i];power[v]=power[i]*pri[i];</span><br><span class="line">                f[v]=f[v/power[v]]*<span class="built_in">F3</span>(pri[v],cnt[v]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[v]=<span class="number">1</span>;pri[v]=prime[j];power[v]=prime[j];</span><br><span class="line">            f[v]=f[i]*<span class="built_in">F2</span>(prime[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="模板题：T34163-【模板】线性筛"><a href="#模板题：T34163-【模板】线性筛" class="headerlink" title="模板题：T34163 【模板】线性筛"></a>模板题：<a href="https://www.luogu.org/problemnew/show/T34163">T34163 【模板】线性筛</a></h2></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sig</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)<span class="keyword">if</span>(a%i==<span class="number">0</span>)ret++;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> pri[N],cnt[N],power[N];</span><br><span class="line"><span class="type">int</span> phi[N],mu[N],prime[N],sigma0[N],sigma1[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Shai</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>]=mu[<span class="number">1</span>]=sigma0[<span class="number">1</span>]=sigma1[<span class="number">1</span>]=inv[<span class="number">1</span>]=power[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    inv[i]=(n-n/i)*inv[n%i]%n,power[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            cnt[i]=<span class="number">1</span>;pri[i]=i;power[i]=i;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">            sigma0[i]=<span class="number">2</span>;</span><br><span class="line">            sigma1[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,v,pc;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">            v=i*prime[j];</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                cnt[v]=cnt[i]+<span class="number">1</span>;pri[v]=pri[i];power[v]=power[i]*pri[i];</span><br><span class="line">                phi[v]   =phi[i]*prime[j];</span><br><span class="line">                sigma0[v]=sigma0[v/power[v]]*(cnt[v]+<span class="number">1</span>);</span><br><span class="line">                sigma1[v]=sigma1[v/power[v]]*(power[v]*pri[v]<span class="number">-1</span>)/(pri[v]<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[v]=<span class="number">1</span>;pri[v]=prime[j];power[v]=prime[j];</span><br><span class="line">            phi[v]   =phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">            mu[v]    =-mu[i];</span><br><span class="line">            sigma0[v]=sigma0[i]*<span class="number">2</span>;</span><br><span class="line">            sigma1[v]=sigma1[i]*(prime[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">Get_Shai</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,phi[i]);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,mu[i]);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[<span class="number">0</span>]);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=prime[<span class="number">0</span>];i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,prime[i]);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sigma0[i]);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sigma1[i]);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,inv[i]);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数学</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演与杜教筛</title>
    <url>/2018/12/30/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E4%B8%8E%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于莫比乌斯反演，杜教筛等的杂记：</p>
<span id="more"></span>
<h2 id="初识数论常见积性函数：欧拉函数-varphi-，莫比乌斯函数-mu"><a href="#初识数论常见积性函数：欧拉函数-varphi-，莫比乌斯函数-mu" class="headerlink" title="初识数论常见积性函数：欧拉函数$\varphi$，莫比乌斯函数$\mu$"></a>初识数论常见积性函数：欧拉函数$\varphi$，莫比乌斯函数$\mu$</h2><p>$\ \ \ \ \ \,$所谓积性函数，就是对于一个函数$f(x)$，若是对于任意$x_1$，$x_2$满足$f(x_1)\times f(x_2)=f(x_1\times x_2)$。对于任何积性函数$f(x)$，都有$f(1)=1$。</p>
<ul>
<li><p>欧拉函数$\varphi(x)$的意义：在$[1,x]$内，与$x$互质的个数。</p>
<p>$1$.若$x$为素数，$\varphi(x)=x-1$;</p>
<p>$2$.若$x\%p=0$，$\varphi(x\cdot p)=\varphi(x)\cdot p$;</p>
<p>$3$.若$x\%p\neq 0$，且$x$为素数，$\varphi(x\cdot p)=\varphi(x)\cdot (p-1)$;</p>
<p><a href="https://www.luogu.org/blog/hdxrie/dui-ou-la-han-shuo-di-li-xie">【证明戳这里<del>（%%%大巨佬orz）</del>】</a></p>
</li>
<li><p>莫比乌斯函数$\mu(x)$的意义：设$x$的不同质因子个数为$a$，$\mu(x)=(-1)^{a}$；当n存在平方因子时，$\mu(x)=0$。</p>
<p>$1$.若$x$有奇数个不同质因数，$\mu(x)=-1$。</p>
<p>$2$.若$x$有偶数个不同质因数，$\mu(x)=1$。</p>
<p>$3$.若$x$有平方因子，$\mu(x)=0$。</p>
</li>
</ul>
<p>$\ \ \ \ \ \,$还有一些简单的积性函数，在这里一并介绍了：</p>
<p>$ϵ(x)=\begin{cases}1&amp;x=1\\0&amp;x&gt;1\end{cases}$</p>
<p>$id(x)=x$</p>
<p>$id^k(x)=x^k$</p>
<p>$\sigma(x)=\sum_{i|x}1$</p>
<p>$1$</p>
<h2 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h2><p>$\ \ \ \ \ \,$很多时候，我们会遇到这样的式子:</p>
<p>$\sum_{i=1}^{n}f(i)\times g\left(\left\lfloor\frac{n}{i}\right\rfloor\right)$</p>
<p>$\ \ \ \ \ \,$若是我们已经提前知道了$f(x)$在$x\in [1,n]$的值了，但是需要多次计算上面形式的式子的值，每次询问复杂度是$O(n)$的，显然在询问很多的时候，没有很划算。</p>
<p>$\ \ \ \ \ \,$我们枚举了很多$i$，使得很多$\left\lfloor\frac{n}{i}\right\rfloor$都相等，所以我们可以把$\sum_{i=1}^{n}$，分成$\sqrt{n}\ $块，使得每一块的$\left\lfloor\frac{n}{i}\right\rfloor$都相等，这样我们可以通过结合律得到下面的式子，$O(n)$预处理$sum(x)=\sum_{i=1}^{x}f(i)$，来简化询问复杂度到$O(\sqrt{n})$：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_ans</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    ans+=<span class="built_in">g</span>(n/l)*(sum[r]-sum[l<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><p>  $(f*g)(n)=\sum_{x|n}f(x)\times g\left(\frac{n}{x}\right)$</p>
<p>  既：</p>
<p>  $(f*g)(n)=\sum_{xy=n}f(x)\times g(y)$</p>
<p>  狄利克雷卷积的性质：</p>
<pre><code>**1.交换律:** $f*g=g*f$；

**2.结合律:**  $(f*g)*h=g*(f*h)$；$(a\times f)*g=a\times (f*g)$；

**3.分配律:**  $(f+g)*h=f*h+g*h$；

**4.单位元:**  $ϵ*f=f$；其中$ϵ(x)=\begin&#123;cases&#125;1&amp;x=1\\0&amp;x&gt;1\end&#123;cases&#125;$；

**5.逆元:**  对于每个$f(1)\neq0$的函数，都存在一个函数$g$使得$f*g=ϵ$；

**6.两个积性函数的狄利克雷卷积是积性函数。**
</code></pre><h3 id="如何求一个函数的逆："><a href="#如何求一个函数的逆：" class="headerlink" title="$\ \ \ \ \ \,$如何求一个函数的逆："></a>$\ \ \ \ \ \,$如何求一个函数的逆：</h3><p> $\begin{aligned}ϵ&amp;=f*g\\ &amp;=\sum_{x|n}f(x)\times g\left(\frac{n}{x}\right)\\ &amp;=f(1)\times g(n)+\sum_{x|n,i\neq1}f(x)\times g\left(\frac{n}{x}\right)\\&amp;=[n=1]\end{aligned}$<br>$\ \ \ \ \ \,$所以有：<br>$f(1)\times g(n)=[n=1]-\sum_{x|n,i\neq1}f(x)\times g\left(\frac{n}{x}\right)$<br>$g(n)=\frac{1}{f(1)}\left([n=1]-\sum_{x|n,i\neq1}f(x)\times g\left(\frac{n}{x}\right)\right)$</p>
<h4 id="其中-mu-就是函数-1-的逆，也就是说-mu-1-ϵ"><a href="#其中-mu-就是函数-1-的逆，也就是说-mu-1-ϵ" class="headerlink" title="$\ \ \ \ \ \,$其中$\mu$就是函数$1$的逆，也就是说$\mu*1=ϵ$"></a>$\ \ \ \ \ \,$其中$\mu$就是函数$1$的逆，也就是说$\mu*1=ϵ$</h4><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>$\ \ \ \ \ \,$莫比乌斯反演的本质就是利用性质$\mu*1=ϵ$，改变枚举方式，降低式子的复杂度。</p>
<p>$\ \ \ \ \ \,$最常见的操作是,反演式子$\sum_{i=1}^n\sum_{j=1}^{m}[gcd(i,j)=1]$:</p>
<p>$\sum_{i=1}^n\sum_{j=1}^{m}[gcd(i,j)=1]$</p>
<p>$\sum_{i=1}^n\sum_{j=1}^{m}ϵ(gcd(i,j))$</p>
<p>$\sum_{i=1}^n\sum_{j=1}^{m}(\mu*1)(gcd(i,j))$</p>
<p>$\sum_{i=1}^n\sum_{j=1}^{m}\sum_{d|gcd(i,j)}\mu(d)\times 1$</p>
<p>$\sum_{i=1}^n\sum_{j=1}^{m}\sum_{d=1}^{min(n,m)}\mu(d)[d|gcd(i,j)]$</p>
<p>$\sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^n\sum_{j=1}^{m}[d|gcd(i,j)]$</p>
<p>$\sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}1$</p>
<p>$\sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}1\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}1$</p>
<p>$\sum_{d=1}^{min(n,m)}\mu(d){\left\lfloor\frac{n}{d}\right\rfloor}{\left\lfloor\frac{m}{d}\right\rfloor}$</p>
<h3 id="莫比乌斯反演经典例题回顾"><a href="#莫比乌斯反演经典例题回顾" class="headerlink" title="莫比乌斯反演经典例题回顾"></a><a href="/2018/12/30/莫比乌斯反演经典例题回顾/">莫比乌斯反演经典例题回顾</a></h3><p>  <a href="https://www.luogu.org/problemnew/show/P2522">P2522 [HAOI2011]Problem b</a>（反演+容斥）</p>
<p>  <a href="https://www.luogu.org/problemnew/show/P2257">P2257 YY的GCD</a>（反演）</p>
<p>  <a href="https://www.luogu.org/problemnew/show/P3312">P3312 [SDOI2014]数表</a>（反演+离线+数据结构）</p>
<p>  <a href="https://www.luogu.org/problemnew/show/P3704">P3704 [SDOI2017]数字表格</a>（反演）</p>
<p>  <a href="https://www.luogu.org/problemnew/show/P3327">P3327 [SDOI2015]约数个数和</a>（反演，数表的简化版）</p>
<p>  <a href="https://www.luogu.org/problemnew/show/P3455">P3455 [POI2007]ZAP-Queries</a>（反演，裸的）</p>
<p>  <a href="https://www.luogu.org/problemnew/show/P1829">P1829 [国家集训队]Crash的数字表格 / JZPTAB</a>（反演+欧拉筛，做法新奇）</p>
<p>  <a href="https://www.luogu.org/problemnew/show/P3768">P3768 简单的数学题</a>（反演+杜教筛）</p>
<p>  <a href="https://www.luogu.org/problemnew/show/P4240">P4240 毒瘤之神的考验</a>（反演+奇怪的分块，基本上很结论题了）</p>
<p>  <a href="https://www.luogu.org/problemnew/show/P1587">P1587 [NOI2016]循环之美</a>（反演+杜教筛+数学知识+奇技淫巧，难题来了）</p>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><p><a href="https://lx-2003.blog.luogu.org/dujiao-sieve#">【铃悬的数学小讲堂——杜教筛】</a></p>
<p>$\ \ \ \ \ \,$杜教筛是求积性函数的前缀和的筛法，复杂度可以达到小于线性的$O(n^{\frac{2}{3}})$。</p>
<p>$\ \ \ \ \ \,$对于一个积性函数$f$，令$S(n)=\sum_{i=1}^nf(i)$，再新定义一个函数$g$，则有：</p>
<p>$\begin{aligned}&amp;\sum_{i=1}^n(f*g)(i)\\=&amp;\sum_{i=1}^n\sum_{x\times y=i}f(x)\times g(y)\\=&amp;\sum_{y=1}^ng(y)\sum_{x\times y\leq n}f(x)\\=&amp;\sum_{y=1}^ng(y)\sum_{x=1}^{\left\lfloor\frac{n}{y}\right\rfloor}f(x)\\=&amp;\sum_{y=1}^ng(y)S\left(\left\lfloor\frac{n}{y}\right\rfloor\right)\end{aligned}$</p>
<p>$\ \ \ \ \ \,$那么就有：</p>
<p>$\sum_{i=1}^n(f*g)(i)=g(1)S(n)+\sum_{y=2}^ng(y)S\left(\left\lfloor\frac{n}{y}\right\rfloor\right)$</p>
<p>$\ \ \ \ \ \,$既：</p>
<p>$g(1)S(n)=\sum_{i=1}^n(f*g)(i)-\sum_{y=2}^ng(y)S\left(\left\lfloor\frac{n}{y}\right\rfloor\right)$</p>
<p>$S(n)=\frac{\sum_{i=1}^n(f*g)(i)-\sum_{y=2}^ng(y)S\left(\left\lfloor\frac{n}{y}\right\rfloor\right)}{g(1)}$</p>
<p>$S(n)={\sum_{i=1}^n(f*g)(i)-\sum_{y=2}^ng(y)S\left(\left\lfloor\frac{n}{y}\right\rfloor\right)}$</p>
<p>$\ \ \ \ \ \,$若是函数$(f*g)$和$g$的前缀和都可以$O(1)$地算出来，那么我们计算$S(n)$的值的时候递归处理，便可以优化复杂度到$O(n^{\frac{3}{4}})$。</p>
<p>$\ \ \ \ \ \,$但若是我们先线性预处理出$S(i)\ {i\in[1,n^{\frac{2}{3}}]}$的值，复杂度就可以优化到$O(n^{\frac{2}{3}})$</p>
<p>$\ \ \ \ \ \,$那么现在的问题是如何找到这个神奇的函数$g$：</p>
<ul>
<li><p>对于$\varphi(x)$：</p>
<p>$\begin{aligned}\varphi(x)=&amp;\prod_{p|x,p\ \rm{is\ prime}}\frac{p^k(p-1)}{p}\\=&amp;x\times \prod_{p|x,p\ \rm{is\ prime}}\left(1-\frac{1}{p}\right)\end{aligned}$</p>
<p>$\begin{aligned}(\varphi*1)(x)=&amp;\sum_{i|x}\varphi(i)\times 1\left(\frac{x}{i}\right)\\=&amp;\sum_{i|x}\varphi(i)\\=&amp;\sum_{i|x}i\times \prod_{p|i,p\ \rm{is\ prime}}\left(1-\frac{1}{p}\right)\end{aligned}$</p>
</li>
</ul>
<p>显然$(\varphi*1)(x)$</p>
<p>在$x$为素数的次方情况下，$(\varphi*1)(x)=x$</p>
<p>，而$(\varphi*1)(x)$</p>
<p>又为积性函数，可以证明在定义域下$(\varphi*1)(x)=x$</p>
<p>，既$\varphi*1=id$。</p>
<p>  <strong>所以我们选取$g=1$,$(f*g)=id$，容易求和。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Sum_id</span><span class="params">(<span class="type">int</span> x)</span>&#123;<span class="keyword">return</span> <span class="number">1ll</span>*x*(x+<span class="number">1</span>)/<span class="number">2</span>;&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Sum_1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;<span class="keyword">return</span> <span class="number">1ll</span>*r-l+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> g1=<span class="number">1ll</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Sum_phi</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ret=Sum_id(x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>)</span><br><span class="line">  j=x/(x/i),ret-=Sum_1(i,j)*Sum_phi(x/i);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于$\mu(x)$：</p>
<p>已知$\mu*1=ϵ$</p>
<p><strong>所以我们选取$g=1$,$(f*g)=ϵ$，容易求和。</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Sum_e</span><span class="params">(<span class="type">int</span> x)</span>&#123;<span class="keyword">return</span> <span class="number">1ll</span>;&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Sum_1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;<span class="keyword">return</span> <span class="number">1ll</span>*r-l+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> g1=<span class="number">1ll</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Sum_mu</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ret=Sum_e(x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>)</span><br><span class="line">  j=x/(x/i),ret-=Sum_1(i,j)*Sum_mu(x/i);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：杜教筛套杜教筛复杂度还是$O(n^\frac{2}{3})$，因为实际上他们是并列进行的。</strong></p>
<h3 id="贝尔级数"><a href="#贝尔级数" class="headerlink" title="贝尔级数"></a>贝尔级数</h3><p>  $\ \ \ \ \ \,$对于其他积性函数，为了找到满足条件的$g$，我们引入<strong>贝尔级数</strong>，需要用到生成函数的姿势，但是实际上只需要记住下面的公式就够用了：</p>
<p>  $\ \ \ \ \ \,$对于积性函数$f$，定义$f$模$p$的贝尔级数为：</p>
<p>  $f_p(x)=\sum_{i=0}^{\infty}f(p^i)x^i$</p>
<p>  $\ \ \ \ \ \,$一个完全积性函数的贝尔级数为几何级数：</p>
<p>  $f_p(x)=\frac{1}{1-f(p)\times x}$</p>
<p>  $\ \ \ \ \ \,$例如（“*”完全积性函数）:</p>
<p>  *$ϵ_p(x)=1$</p>
<p>  *$1_p(x)=\frac{1}{1-x}$</p>
<p>  *$id^k_p(x)=\frac{1}{1-p^k\cdot x}$</p>
<p>  $\mu_p(x)=1-x$</p>
<p>  $\sigma_p(x)=\frac{1}{(1-x)^2}$</p>
<p>  $(\sigma_1)_p(x)=\frac{1}{1-\sigma_1(p)x+px^2}$ ——&gt; $\left[(\sigma_k)_p(x)=\frac{1}{1-\sigma_k(p)x+p^kx^2}\right]$</p>
<p>  $\varphi_p(x)=\frac{1-x}{1-p\cdot x}$</p>
<p>  $\ \ \ \ \ \,$有了这个东西，我们边可以把狄利克雷卷积化成一般卷积的形式：</p>
<p>  $(f*g)_p(x)=f_p(x)\times g_p(x)$</p>
<p>  $\ \ \ \ \ \,$再带回去就可以得到我们想要的$g$和$g*f$，主观感觉非常复杂。</p>
<h3 id="一些比较常见的容易求的卷积"><a href="#一些比较常见的容易求的卷积" class="headerlink" title="一些比较常见的容易求的卷积"></a>一些比较常见的容易求的卷积</h3><p>  $\mu*\sigma=1$</p>
<p>  $id*id=n$</p>
<p>  $\varphi*1=id$</p>
<p>  $\mu*id=\varphi$</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流，费用流和二分图匹配模板</title>
    <url>/2018/12/31/%E7%BD%91%E7%BB%9C%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81%E5%92%8C%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$网络流，费用流相关的复习笔记：</p>
<span id="more"></span>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p=<span class="number">1</span>,S,T,n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last,rl;&#125;G[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	G[++p]=(ss)&#123;b,head[a],c&#125;;head[a]=p;</span><br><span class="line">	G[++p]=(ss)&#123;a,head[b],<span class="number">0</span>&#125;;head[b]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; Q;dis[S]=<span class="number">1</span>;Q.<span class="built_in">push</span>(S);</span><br><span class="line">  <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">    <span class="keyword">if</span>(G[i].rl&gt;<span class="number">0</span>&amp;&amp;dis[G[i].v]==<span class="number">0</span>)&#123;</span><br><span class="line">      dis[G[i].v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">      Q.<span class="built_in">push</span>(G[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dis[T]!=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Augment</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> S,<span class="type">int</span> T,<span class="type">int</span> mi)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a==T)<span class="keyword">return</span> mi;</span><br><span class="line">	<span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[a];i;i=G[i].last)</span><br><span class="line">  <span class="keyword">if</span>((dis[G[i].v]==dis[a]+<span class="number">1</span>)&amp;&amp;(G[i].rl!=<span class="number">0</span>))&#123;</span><br><span class="line">    <span class="type">int</span> ls=<span class="built_in">Augment</span>(G[i].v,S,T,<span class="built_in">min</span>(mi,G[i].rl));</span><br><span class="line">		flow+=ls;mi-=ls;G[i].rl-=ls;G[i^<span class="number">1</span>].rl+=ls;</span><br><span class="line">    <span class="keyword">if</span>(!mi)<span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,ls;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>(S,T))ans+=<span class="built_in">Augment</span>(S,S,T,inf);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p=<span class="number">1</span>,S,T,n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last;<span class="type">int</span> rl;&#125;G[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	G[++p]=(ss)&#123;b,head[a],c&#125;;head[a]=p;</span><br><span class="line">	G[++p]=(ss)&#123;a,head[b],<span class="number">0</span>&#125;;head[b]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N],cur[N],num[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">	++num[dis[T]=<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; Q;Q.<span class="built_in">push</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)<span class="keyword">if</span>(!dis[G[i].v])</span><br><span class="line">		&#123;++num[dis[G[i].v]=dis[u]+<span class="number">1</span>];Q.<span class="built_in">push</span>(G[i].v);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Augment</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> S,<span class="type">int</span> T,<span class="type">int</span> mi)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==T)<span class="keyword">return</span> mi;</span><br><span class="line">	<span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cur[a];i;i=G[i].last)<span class="keyword">if</span>(dis[G[i].v]==dis[a]<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> ls=<span class="built_in">Augment</span>(G[i].v,S,T,<span class="built_in">min</span>(mi,G[i].rl));</span><br><span class="line">		flow+=ls;mi-=ls;G[i].rl-=ls;G[i^<span class="number">1</span>].rl+=ls;</span><br><span class="line">		<span class="keyword">if</span>(!mi)<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!(--num[dis[a]]))dis[S]=n+<span class="number">1</span>;</span><br><span class="line">	++num[++dis[a]];cur[a]=head[a];</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISAP</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	<span class="built_in">bfs</span>(T);</span><br><span class="line">	<span class="type">int</span> ret=<span class="built_in">Augment</span>(S,S,T,inf);</span><br><span class="line">	<span class="keyword">while</span>(dis[S]&lt;=n)ret+=<span class="built_in">Augment</span>(S,S,T,inf);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="费用流（最小费用最大流）"><a href="#费用流（最小费用最大流）" class="headerlink" title="费用流（最小费用最大流）"></a>费用流（最小费用最大流）</h2><h3 id="ZKW"><a href="#ZKW" class="headerlink" title="ZKW"></a>ZKW</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p=<span class="number">1</span>,S,T,n,m,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last;<span class="type">int</span> rl,w;&#125;G[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	G[++p]=(ss)&#123;b,head[a],c,d&#125;;head[a]=p;</span><br><span class="line">	G[++p]=(ss)&#123;a,head[b],<span class="number">0</span>,-d&#125;;head[b]=p;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">int</span> dis[N],Mincost,Maxflow;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)dis[i]=inf,vis[i]=<span class="number">0</span>;</span><br><span class="line">	dis[T]=<span class="number">0</span>,vis[T]=<span class="number">1</span>;</span><br><span class="line">	Q.<span class="built_in">push</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">		<span class="keyword">if</span>(G[i^<span class="number">1</span>].rl&gt;<span class="number">0</span>&amp;&amp;dis[G[i].v]&gt;dis[u]-G[i].w)&#123;</span><br><span class="line">			dis[G[i].v]=dis[u]-G[i].w;</span><br><span class="line">			<span class="keyword">if</span>(!vis[G[i].v])</span><br><span class="line">			Q.<span class="built_in">push</span>(G[i].v),vis[G[i].v]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[S]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Augment</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> S,<span class="type">int</span> T,<span class="type">int</span> mi)</span></span>&#123;</span><br><span class="line">	used[a]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(a==T)<span class="keyword">return</span> mi;</span><br><span class="line">  <span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[a];i;i=G[i].last)</span><br><span class="line">	<span class="keyword">if</span>(!used[G[i].v]&amp;&amp;G[i].rl&amp;&amp;dis[a]-G[i].w==dis[G[i].v])&#123;</span><br><span class="line">	  <span class="type">int</span> ls=<span class="built_in">Augment</span>(G[i].v,S,T,<span class="built_in">min</span>(G[i].rl,mi));</span><br><span class="line">	  Mincost+=ls*G[i].w,mi-=flow,G[i].rl-=ls,G[i^<span class="number">1</span>].rl+=ls,flow+=ls;</span><br><span class="line">	  <span class="keyword">if</span>(!mi)<span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZKW</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	Maxflow=Mincost=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">SPFA</span>(S,T))&#123;</span><br><span class="line">		used[T]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(used[T])&#123;</span><br><span class="line">      <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">      Maxflow+=<span class="built_in">Augment</span>(S,S,T,inf);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><h3 id="Hungary"><a href="#Hungary" class="headerlink" title="Hungary"></a>Hungary</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> used[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n,m,e,ans;</span><br><span class="line"><span class="type">int</span> head[N],p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last;&#125;G[N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;G[++p].v=b;G[p].last=head[a];head[a]=p;&#125;</span><br><span class="line"><span class="type">int</span> match[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)<span class="keyword">if</span>(!used[G[i].v])&#123;</span><br><span class="line">		used[G[i].v]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!match[G[i].v]||<span class="built_in">dfs</span>(match[G[i].v]))</span><br><span class="line">		&#123;match[G[i].v]=u;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungary</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">dfs</span>(i))ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kuhn-Munkres（带权）"><a href="#Kuhn-Munkres（带权）" class="headerlink" title="Kuhn Munkres（带权）"></a>Kuhn Munkres（带权）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last,w;&#125;G[N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;G[++p].v=b;G[p].last=head[a];G[p].w=c;head[a]=p;&#125;</span><br><span class="line"><span class="type">bool</span> usem[N&lt;&lt;<span class="number">1</span>],usen[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> match[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> maxn[N&lt;&lt;<span class="number">1</span>],maxm[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> slack[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  usen[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)&#123;</span><br><span class="line">    <span class="keyword">if</span>(usem[G[i].v])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> gap=maxn[u]+maxm[G[i].v]-G[i].w;</span><br><span class="line">    <span class="keyword">if</span>(gap==<span class="number">0</span>)&#123;</span><br><span class="line">      usem[G[i].v]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(match[G[i].v]==<span class="number">0</span>||<span class="built_in">dfs</span>(match[G[i].v]))</span><br><span class="line">			&#123;match[G[i].v]=u;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    &#125; </span><br><span class="line">		<span class="keyword">else</span> slack[G[i].v]=<span class="built_in">min</span>(slack[G[i].v],gap);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kuhn_Munkres</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="built_in">sizeof</span>(match));</span><br><span class="line">	<span class="built_in">memset</span>(maxm,<span class="number">0</span>,<span class="built_in">sizeof</span>(maxm));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">		maxn[u]=-inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">		maxn[u]=<span class="built_in">max</span>(maxn[u],G[i].w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)slack[j]=inf;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">memset</span>(usem,<span class="number">0</span>,<span class="built_in">sizeof</span>(usem));</span><br><span class="line">			<span class="built_in">memset</span>(usen,<span class="number">0</span>,<span class="built_in">sizeof</span>(usen));</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dfs</span>(i))<span class="keyword">break</span>;</span><br><span class="line">			<span class="type">int</span> a=inf;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">      <span class="keyword">if</span>(!usem[j])a=<span class="built_in">min</span>(a,slack[j]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(usen[j])maxn[j]-=a;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">if</span>(usem[j])maxm[j]+=a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">		<span class="keyword">if</span>(match[G[i].v]==u)</span><br><span class="line">		res+=G[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>由CRT合并引入的各种扩展求余和同余问题</title>
    <url>/2018/12/30/%E7%94%B1CRT%E5%90%88%E5%B9%B6%E5%BC%95%E5%85%A5%E7%9A%84%E5%90%84%E7%A7%8D%E6%89%A9%E5%B1%95%E6%B1%82%E4%BD%99%E5%92%8C%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$扩展中国剩余定理的引入，使得在模特定素数意义下的算法得以扩张为模任意数，这大大方便了我们对于算法的运用。</p>
<span id="more"></span>
<h2 id="大前提【中国剩余定理】"><a href="#大前提【中国剩余定理】" class="headerlink" title="大前提【中国剩余定理】"></a>大前提<a href="/2018/12/29/扩展中国剩余定理/">【中国剩余定理】</a></h2><h2 id="扩展卢卡斯定理（exLucas）"><a href="#扩展卢卡斯定理（exLucas）" class="headerlink" title="扩展卢卡斯定理（exLucas）"></a>扩展卢卡斯定理（exLucas）</h2><h3 id="卢卡斯定理（Lucas）"><a href="#卢卡斯定理（Lucas）" class="headerlink" title="卢卡斯定理（Lucas）"></a>卢卡斯定理（Lucas）</h3><p>  $\ \ \ \ \ \ \,$卢卡斯定理是快速求组合数余的算法，其中最基本的卢卡斯定理只能解决模数为素数的情况，复杂度是$O(p)$预处理阶乘和逆元，每次回答$O(\log n)$。</p>
<p>  $\ \ \ \ \ \ \,$当$n$或$m&gt;p$，套用下面的公式递归处理：</p>
<p>  $C_{n}^{m}\equiv C_{\left\lfloor\frac{n}{P}\right\rfloor}^{\left\lfloor\frac{m}{P}\right\rfloor}\times C_{n\%P}^{m\%P}({\rm mod}\ P)$</p>
<p>  $\ \ \ \ \ \ \,$当$n$或$m\leq p$时，套用定义公式：</p>
<p>  $C_{n}^{m}=\frac{n!}{m!(n-m)!}({\rm mod}\ P)$</p>
<p>  $\ \ \ \ \ \ \,$那么当模数不为素数的情况下，我们使用中国剩余定理（CRT）合并。</p>
<ul>
<li><p>将$P$分解质因数：<br>$P=\prod_{i=1}^rp_i^{c_i}$</p>
</li>
<li><p>得到同余方程：<br>$\begin{cases}x\equiv C_{n}^{m}\ \ ({\rm mod}\ p_1^{c_1})\\x\equiv C_{n}^{m}\ \ ({\rm mod}\ p_2^{c_2})\\x\equiv C_{n}^{m}\ \ ({\rm mod}\ p_3^{c_3})\\\ \ \ \ \ \ \ \ \ \ \ \cdots\\x\equiv C_{n}^{m}\ \ ({\rm mod}\ p_r^{c_r})\end{cases}$</p>
</li>
</ul>
<p>$\ \ \ \ \ \ \,$显然可以很方便的用中国剩余定理（CRT）求出$x$的值，现在我们的问题是如何快速求出$C_{n}^{m}\% p_i^{c_i}$的值。</p>
<p>  $\ \ \ \ \ \ \,$先忘记卢卡斯定理吧，这里并用不到它。</p>
<p>  $\ \ \ \ \ \ \,$观察组合数的定义式：</p>
<p>  $C_{n}^{m}=\frac{n!}{m!(n-m)!}=\frac{\prod_{i=1}^ni}{\prod_{i=1}^mi\prod_{i=1}^{n-m}i}$</p>
<p>  $\ \ \ \ \ \ \,$现在的问题是如何快速求出$\prod_{i=1}^ni\ (\% p^{c})$的值。</p>
<p>  $\ \ \ \ \ \ \,$我们开始拆开它：</p>
<p>  $\prod_{i=1}^ni\ (\% p^{c})$</p>
<p>  $\prod_{i=1,p|i}^ni\prod_{i=1,p\nmid i}^ni\ (\% p^{c})$</p>
<p>  $\prod_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}ip\prod_{i=1,p\nmid i}^ni\ (\% p^{c})$</p>
<p>  ${\left\lfloor\frac{n}{p}\right\rfloor}!\cdot p\prod_{i=1,p\nmid i}^ni\ (\% p^{c})$</p>
<p>  $\ \ \ \ \ \ \,$前面那一块阶乘我们递归处理，后面那一块嘛，我们可以发现他是有循环节的，而且长度最多为$p^{c}$，所以暴力算出循环节然后快速幂咯，至于中间那个$p$，我们最后再计算要方便不少。</p>
<p>  $\ \ \ \ \ \ \,$现在阶乘倒是处理完了，我们带回定义式，发现还需要求个逆元。这个还是扩展欧几里得来吧，然后我们发现还有很多$p$没有乘，需要统计一下里面乘$p$的次数再快速幂乘回去。</p>
<p>  $\ \ \ \ \ \ \,$说了这么多，终于有下面的模板了，复杂度大约在$O(P\log P)$左右：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">inv</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> x,y;<span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line">  <span class="keyword">return</span> (x+p)%p==<span class="number">0</span>?p:(x+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fac</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> p,<span class="type">long</span> <span class="type">long</span> pc)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=pc;i++)<span class="keyword">if</span>(i%p)res=(res*i)%pc;</span><br><span class="line">  res=<span class="built_in">power</span>(res,n/pc,pc);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=n%pc;i++)<span class="keyword">if</span>(i%p)res=(res*i)%pc;</span><br><span class="line">  <span class="keyword">return</span> (res*<span class="built_in">fac</span>(n/p,p,pc))%pc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m,<span class="type">long</span> <span class="type">long</span> p,<span class="type">long</span> <span class="type">long</span> pc,<span class="type">long</span> <span class="type">long</span> Mod)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> a=<span class="built_in">fac</span>(n,p,pc),b=<span class="built_in">fac</span>(m,p,pc),c=<span class="built_in">fac</span>(n-m,p,pc);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=n;i;i/=p)k+=i/p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=m;i;i/=p)k-=i/p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=n-m;i;i/=p)k-=i/p;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res=a*<span class="built_in">inv</span>(b,pc)%pc*<span class="built_in">inv</span>(c,pc)%pc*<span class="built_in">power</span>(p,k,pc)%pc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">exLucas</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m,<span class="type">long</span> <span class="type">long</span> Mod)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>,P=Mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=P;i++)</span><br><span class="line">    <span class="keyword">if</span>(P%i==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> pc=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(P%i==<span class="number">0</span>)P/=i,pc*=i;</span><br><span class="line">      res=(res+<span class="built_in">C</span>(n,m,i,pc,Mod)*(Mod/pc)%Mod*<span class="built_in">inv</span>(Mod/pc,pc)%Mod)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="【P4720-【模板】扩展卢卡斯】"><a href="#【P4720-【模板】扩展卢卡斯】" class="headerlink" title="【P4720 【模板】扩展卢卡斯】"></a><a href="https://www.luogu.org/problemnew/show/P4720">【P4720 【模板】扩展卢卡斯】</a></h3><p>  $\ \ \ \ \ \ \,$既然是模板题，就不多废话了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;a=a%c;</span><br><span class="line">  <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=(a*a)%c)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans*a)%c;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> &amp;x,<span class="type">long</span> <span class="type">long</span> &amp;y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!b)&#123;x=<span class="number">1ll</span>;y=<span class="number">0ll</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="built_in">exgcd</span>(b,a%b,y,x);y-=x*(a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">inv</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> x,y;<span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line">  <span class="keyword">return</span> (x+p)%p==<span class="number">0</span>?p:(x+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fac</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> p,<span class="type">long</span> <span class="type">long</span> pc)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=pc;i++)<span class="keyword">if</span>(i%p)res=(res*i)%pc;</span><br><span class="line">  res=<span class="built_in">power</span>(res,n/pc,pc);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=n%pc;i++)<span class="keyword">if</span>(i%p)res=(res*i)%pc;</span><br><span class="line">  <span class="keyword">return</span> (res*<span class="built_in">fac</span>(n/p,p,pc))%pc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m,<span class="type">long</span> <span class="type">long</span> p,<span class="type">long</span> <span class="type">long</span> pc,<span class="type">long</span> <span class="type">long</span> Mod)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> a=<span class="built_in">fac</span>(n,p,pc),b=<span class="built_in">fac</span>(m,p,pc),c=<span class="built_in">fac</span>(n-m,p,pc);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=n;i;i/=p)k+=i/p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=m;i;i/=p)k-=i/p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=n-m;i;i/=p)k-=i/p;</span><br><span class="line">  <span class="keyword">return</span> (a*<span class="built_in">inv</span>(b,pc)%pc*<span class="built_in">inv</span>(c,pc)%pc*<span class="built_in">power</span>(p,k,pc)%pc)*(Mod/pc)%Mod*<span class="built_in">inv</span>(Mod/pc,pc)%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">exLucas</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m,<span class="type">long</span> <span class="type">long</span> Mod)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>,P=Mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=P;i++)</span><br><span class="line">    <span class="keyword">if</span>(P%i==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> pc=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(P%i==<span class="number">0</span>)P/=i,pc*=i;</span><br><span class="line">      res=(res+<span class="built_in">C</span>(n,m,i,pc,Mod))%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),P=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">exLucas</span>(n,m,P));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="扩展欧拉算法（exEuler）"><a href="#扩展欧拉算法（exEuler）" class="headerlink" title="扩展欧拉算法（exEuler）"></a>扩展欧拉算法（exEuler）</h2><h3 id="欧拉算法（Euler）"><a href="#欧拉算法（Euler）" class="headerlink" title="欧拉算法（Euler）"></a>欧拉算法（Euler）</h3><p>$\ \ \ \ \ \,$欧拉算法是快速求$a^b\%P$的值的算法，其核心是欧拉定理：</p>
<p>$\ \ \ \ \ \,$当$a$,$P$互质时,有 $a^{\varphi(P)}\equiv1({\rm mod}\ P)$</p>
<p>$\ \ \ \ \ \,$那么就有，欧拉算法：$a^b\%P=a^{b\%{\varphi(P)}}\%P$</p>
<p>$\ \ \ \ \ \,$当模数不为素数的情况下，我们依然使用中国剩余定理（CRT）合并。</p>
<ul>
<li><p>将$P$分解质因数：<br>$P=\prod_{i=1}^rp_i^{c_i}$</p>
</li>
<li><p>得到同余方程：<br>$\begin{cases}x\equiv a^b\ \ ({\rm mod}\ p_1^{c_1})\\x\equiv a^b\ \ ({\rm mod}\ p_2^{c_2})\\x\equiv a^b\ \ ({\rm mod}\ p_3^{c_3})\\\ \ \ \ \ \ \ \ \ \ \ \cdots\\x\equiv a^b\ \ ({\rm mod}\ p_r^{c_r})\end{cases}$</p>
<p>$\ \ \ \ \ \ \,$好吧其实这个结论挺简单的，证明比较麻烦，所以我们就开心地记结论吧，<a href="https://blog.csdn.net/synapse7/article/details/19610361">证明在这里哦</a>。</p>
<p>$a^b\%P=\begin{cases}a^{b\%{\varphi(P)}}\%P, &amp; {[\gcd(a,P)=1]}\\a^{b\%{\varphi(P)}+\varphi(P)}\%P, &amp; {[\gcd(a,P)\neq 1,b&gt;\varphi(P)]}\\a^b\%P, &amp; {[\gcd(a,P)\neq 1,b\leq\varphi(P)]}\end{cases}$</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Euler_Power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">gcd</span>(a,n)==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">power</span>(a,b%phi[n],n);</span><br><span class="line">  <span class="keyword">if</span>(b&gt;phi[n])<span class="keyword">return</span> <span class="built_in">power</span>(a,b%phi[n]+phi[n],n)%n;</span><br><span class="line">  <span class="keyword">if</span>(b&lt;=phi[n])<span class="keyword">return</span> <span class="built_in">power</span>(a,b,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【P4139-上帝与集合的正确用法】"><a href="#【P4139-上帝与集合的正确用法】" class="headerlink" title="【P4139 上帝与集合的正确用法】"></a><a href="https://www.luogu.org/problemnew/show/P4139">【P4139 上帝与集合的正确用法】</a></h3><p>  $\ \ \ \ \ \ \,$这道题是只用了欧拉算法呢，我们不断递归过去，一定会遇到指数为$1$的时候，退出就行了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">phi_table</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)phi[i]=<span class="number">0</span>;</span><br><span class="line">  phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="keyword">if</span>(!phi[i])</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!phi[j])phi[j]=j;</span><br><span class="line">    phi[j]=phi[j]/i*(i<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> mod)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1ll</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(<span class="number">1ll</span>*ans*a)%mod;</span><br><span class="line">    a=(<span class="number">1ll</span>*a*a)%mod;b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mod==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">power</span>(<span class="number">2</span>,<span class="built_in">solve</span>(phi[mod])+phi[mod],mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">phi_table</span>(N<span class="number">-10</span>);</span><br><span class="line">  <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="type">int</span> mod=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(mod));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="扩展大步小步算法（exBSGS）"><a href="#扩展大步小步算法（exBSGS）" class="headerlink" title="扩展大步小步算法（exBSGS）"></a>扩展大步小步算法（exBSGS）</h2><h3 id="大步小步算法（BSGS）"><a href="#大步小步算法（BSGS）" class="headerlink" title="大步小步算法（BSGS）"></a>大步小步算法（BSGS）</h3><p>$\ \ \ \ \ \ \,$大步小步算法，是求解指数方程同余最小自然数解的算法，其中必须保证模数与$a$互质,形如:</p>
<p>$a^x\equiv b\ \ ({\rm mod}\ P)$</p>
<p>$\ \ \ \ \ \ \,$其实想法还是挺简单的，因为$p$是素数，所以我们可以知道解 $x&lt;P$，那么我们$\sqrt P$ 分块。</p>
<p>$\ \ \ \ \ \ \,$我们不妨假设我们的答案$x=k\sqrt P+l$，显然 $l&lt;\sqrt P$，$k&lt;\sqrt P$：</p>
<p>$a^x\equiv b\ \ ({\rm mod}\ P)$</p>
<p>$a^{k\sqrt p+l}\equiv b\ \ ({\rm mod}\ P)$<br>$(a^{\sqrt p})^{k}a^l\equiv b\ \ ({\rm mod}\ P)$</p>
<p>$\left(a^{\sqrt p}\right)^{k}\equiv \left(a^l\right)^{-1}b\ \ ({\rm mod}\ P)$</p>
<p>$\left(a^{\sqrt p}\right)^{k}\equiv a^{-l}b\ \ ({\rm mod}\ P)$</p>
<p>$\ \ \ \ \ \ \,$那么我们枚举一个 $k$,就可以确定那个唯一的 $l$了,前提是我们要把所有$a^{-l}b\ \ ({\rm mod}\ P)$预处理出来，当然了，这不是问题，我们可以用$\rm map$存一下，复杂度$O(\sqrt P)$：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">BSGS</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">  map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;hash.<span class="built_in">clear</span>();b%=p;</span><br><span class="line">  <span class="type">int</span> t=(<span class="type">int</span>)<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">    <span class="type">int</span> val=(<span class="type">int</span>)(b*<span class="built_in">power</span>(a,j,p)%p);</span><br><span class="line">    hash[val]=j;</span><br><span class="line">  &#125;</span><br><span class="line">  a=<span class="built_in">power</span>(a,t,p);</span><br><span class="line">  <span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">	  <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;i++)&#123;</span><br><span class="line">    <span class="type">int</span> val=<span class="built_in">power</span>(a,i,p);</span><br><span class="line">    <span class="type">int</span> j=hash.<span class="built_in">find</span>(val)==hash.<span class="built_in">end</span>()?<span class="number">-1</span>:hash[val];</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;i*t-j&gt;=<span class="number">0</span>)<span class="keyword">return</span> i*t-j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  $\ \ \ \ \ \ \,$那么当模数与$a$不互质的情况下，我们依然使用中国剩余定理（CRT）合并。</p>
<p>  $\ \ \ \ \ \ \,$由扩展欧拉定理可以得到，当$\gcd (a,P)\nmid b$并且$b\neq1$的时候，方程是无解的，我们先把他判掉。</p>
<p>  $\ \ \ \ \ \ \,$首先我们的想法是，如何一步一步把它化简成模数与$a$互质，再BSGS就行了：</p>
<p>  $a^x\equiv b\ \ ({\rm mod}\ P)$</p>
<p>  $\frac{a^x}{\gcd (a,P)} \equiv \frac{b}{\gcd (a,P)}\ \ ({\rm mod}\ \frac{P}{\gcd (a,P)})$</p>
<p>  ${a^{x-1}} \frac{a}{\gcd (a,P)}\equiv \frac{b}{\gcd (a,P)}\ \ ({\rm mod}\ \frac{P}{\gcd (a,P)})$</p>
<p>  ${a^{x-1}} \equiv \frac{b}{a}\ \ ({\rm mod}\ \frac{P}{\gcd (a,P)})$</p>
<p>  $\ \ \ \ \ \ \,$如此递归下去，化简成模数与$a$互质，再BSGS，返回值记住加上递归层数：<del>（- 然而并没有用到CRT啊，它是怎么混进来的？？- ex嘛，一样的）</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">exBSGS</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;a%=p,b%=p;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,d=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> g=<span class="built_in">gcd</span>(a,p);g!=<span class="number">1</span>;g=<span class="built_in">gcd</span>(a,p))&#123;</span><br><span class="line">    <span class="keyword">if</span>(b%g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    p/=g;b/=g;d=d*(a/g)%p;k++;</span><br><span class="line">    <span class="keyword">if</span>(d==b) <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line">  a%=p;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;hash.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> t=(<span class="type">int</span>)<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">    <span class="type">int</span> val=(<span class="type">int</span>)(b*<span class="built_in">power</span>(a,j,p)%p);</span><br><span class="line">    hash[val]=j;</span><br><span class="line">  &#125;</span><br><span class="line">  a=<span class="built_in">power</span>(a,t,p);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">    <span class="type">int</span> val=d*<span class="built_in">power</span>(a,i,p)%p;</span><br><span class="line">    <span class="type">int</span> j=hash.<span class="built_in">find</span>(val)==hash.<span class="built_in">end</span>()?<span class="number">-1</span>:hash[val];</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;i*t-j+k&gt;=<span class="number">0</span>)<span class="keyword">return</span> i*t-j+k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【P4195-【模板】exBSGS-Spoj3105-Mod】"><a href="#【P4195-【模板】exBSGS-Spoj3105-Mod】" class="headerlink" title="【P4195 【模板】exBSGS/Spoj3105 Mod】"></a><a href="https://www.luogu.org/problemnew/show/P4195">【P4195 【模板】exBSGS/Spoj3105 Mod】</a></h3><p>  $\ \ \ \ \ \ \,$模板题，不废话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;a=<span class="number">1ll</span>*a*a%mod,b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=<span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">100208</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HaHashsh</span>&#123;</span><br><span class="line">	<span class="type">int</span> head[mod],p;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v;<span class="type">int</span> w,last;&#125;G[<span class="number">100000</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));p=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> A=a%mod;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[A];i;i=G[i].last)</span><br><span class="line">		<span class="keyword">if</span>(G[i].v==a)<span class="keyword">return</span> G[i].w;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> A=a%mod;</span><br><span class="line">		G[++p]=(ss)&#123;a,b,head[A]&#125;;head[A]=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;hash;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exBSGS</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	a%=c,b%=c;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> (b==<span class="number">0</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,d=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> g=<span class="built_in">gcd</span>(a,c);g^<span class="number">1</span>;g=<span class="built_in">gcd</span>(a,c))&#123;</span><br><span class="line">		<span class="keyword">if</span>(b%g)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		c/=g;b/=g;d=<span class="number">1ll</span>*d*(a/g)%c;k++;</span><br><span class="line">		<span class="keyword">if</span>(d==b)<span class="keyword">return</span> k;</span><br><span class="line">	&#125;</span><br><span class="line">	a%=c;</span><br><span class="line">	hash.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> t=(<span class="type">int</span>)<span class="built_in">sqrt</span>(c)+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> val=b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)</span><br><span class="line">	hash.<span class="built_in">insert</span>(val,j),val=<span class="number">1ll</span>*val*a%c;</span><br><span class="line">	val=a=<span class="built_in">power</span>(a,t,c);val=<span class="number">1ll</span>*d*val%c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=t;i++)&#123;</span><br><span class="line">		j=hash.<span class="built_in">find</span>(val);val=<span class="number">1ll</span>*val*a%c;</span><br><span class="line">		<span class="keyword">if</span>((~j)&amp;&amp;<span class="number">1ll</span>*i*t-j+k&gt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1ll</span>*i*t-j+k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a,b,c,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;c,&amp;b)==<span class="number">3</span>&amp;&amp;(a||b||c))</span><br><span class="line">	<span class="keyword">if</span>(~(ans=<span class="built_in">exBSGS</span>(a,b,c)))cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No Solution&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="任意模数NTT"><a href="#任意模数NTT" class="headerlink" title="任意模数NTT"></a>任意模数NTT</h2><p>  $\ \ \ \ \ \ \,$在<a href="/2018/12/29/求多项式卷积的变换/">【求多项式卷积的变换】</a>中我们知道，一般NTT只在模数为NTT模数的时候才合法。那么当模数为任意数的时候怎么办呢？</p>
<p>  <strong>$\ \ \ \ \ \ \,$ 一种解法，3模NTT</strong></p>
<p>  $\ \ \ \ \ \ \,$假设在求卷积过后，我们的系数最大为 $A_{max}$，那么我们找若干个NTT模数，求一次NTT变换过后，我们对于这一项，可以得到一个同余方程组：</p>
<p>   $\begin{cases}A_{max}\equiv A_x\ \ ({\rm mod}\ p_1)\\A_{max}\equiv A_x\ \ ({\rm mod}\ p_2)\\A_{max}\equiv A_x\ \ ({\rm mod}\ p_3)\\\ \ \ \ \ \ \ \ \ \ \ \cdots\\A_{max}\equiv A_x\ \ ({\rm mod}\ p_r)\end{cases}$</p>
<p>   $\ \ \ \ \ \ \,$显然，当$\prod_{i-1}^rp_r\geq P$的时候，可以解出$A_{max}$的具体值。这个时候用CRT合并，再模$P$就出来了。</p>
<p>   $\ \ \ \ \ \ \,$下面还是给出模板，这里取的NTT模数为$469762049$，$998244353$，$1004535809$，他们的原根都是 $3$：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> p1=<span class="number">469762049ll</span>,p2=<span class="number">998244353ll</span>,p3=<span class="number">1004535809ll</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a,<span class="type">int</span> f,<span class="type">int</span> n,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;R[i])<span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> gn=<span class="built_in">power</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>),mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">      <span class="type">int</span> g=<span class="number">1</span>,x,y;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> n=<span class="number">0</span>;n&lt;i;++n,g=<span class="number">1ll</span>*g*gn%mod)&#123;</span><br><span class="line">        x=a[j+n],y=<span class="number">1ll</span>*g*a[j+n+i]%mod;</span><br><span class="line">        a[j+n]=(x+y)%mod;a[j+n+i]=(x-y+mod)%mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    <span class="type">int</span> inv=<span class="built_in">power</span>(n,mod<span class="number">-2</span>,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=<span class="number">1ll</span>*a[i]*inv%mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_ntt</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a,<span class="type">long</span> <span class="type">long</span> *b,<span class="type">int</span> n,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">  <span class="built_in">NTT</span>(a,<span class="number">1</span>,n,mod);<span class="built_in">NTT</span>(b,<span class="number">1</span>,n,mod);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mcpy</span><span class="params">(<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) ans[d][i]=lsa[i];</span><br><span class="line">  <span class="keyword">if</span>(d==<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">memset</span>(lsa,<span class="number">0</span>,<span class="built_in">sizeof</span>(lsa));<span class="built_in">memset</span>(lsb,<span class="number">0</span>,<span class="built_in">sizeof</span>(lsb));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) lsa[i]=a[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) lsb[i]=b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ex_merge_NTT</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a,<span class="type">long</span> <span class="type">long</span> *b,<span class="type">int</span> la,<span class="type">int</span> lb,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	n=la,m=lb;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=la;i++) lsa[i]=a[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=lb;i++) lsb[i]=b[i];</span><br><span class="line">	<span class="type">int</span> L=<span class="number">0</span>;<span class="keyword">for</span>(m+=n,n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>)L++;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">  <span class="built_in">merge_ntt</span>(lsa,lsb,n,p1);<span class="built_in">mcpy</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">merge_ntt</span>(lsa,lsb,n,p2);<span class="built_in">mcpy</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">merge_ntt</span>(lsa,lsb,n,p3);<span class="built_in">mcpy</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">NTT</span>(ans[<span class="number">0</span>],<span class="number">-1</span>,n,p1);</span><br><span class="line">  <span class="built_in">NTT</span>(ans[<span class="number">1</span>],<span class="number">-1</span>,n,p2);</span><br><span class="line">  <span class="built_in">NTT</span>(ans[<span class="number">2</span>],<span class="number">-1</span>,n,p3);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=la+lb;i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x=((<span class="built_in">mul</span>(<span class="number">1ll</span>*ans[<span class="number">0</span>][i]*p2%(p1*p2),<span class="built_in">power</span>(p2%p1,p1<span class="number">-2</span>,p1),(p1*p2)))+(<span class="built_in">mul</span>(<span class="number">1ll</span>*ans[<span class="number">1</span>][i]*p1%(p1*p2),<span class="built_in">power</span>(p1%p2,p2<span class="number">-2</span>,p2),(p1*p2))))%(p1*p2);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> y=((((ans[<span class="number">2</span>][i]-x)%p3+p3)%p3)*<span class="built_in">power</span>((p1*p2)%p3,p3<span class="number">-2</span>,p3))%p3;</span><br><span class="line">    a[i]=(<span class="number">1ll</span>*(y%p)*((p1*p2)%p)%p+x%p)%p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> la+lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数学</tag>
        <tag>NTT</tag>
        <tag>CRT</tag>
        <tag>exCRT</tag>
        <tag>Lucas</tag>
        <tag>exLucas</tag>
        <tag>Euler</tag>
        <tag>exEuler</tag>
        <tag>BSGS</tag>
        <tag>exBSGS</tag>
        <tag>任意模数NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量字符串算法——KMP（AC自动机模板）和Manachar</title>
    <url>/2018/12/29/%E8%BD%BB%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95-KMP-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A8%A1%E6%9D%BF-%E5%92%8CManachar/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$一些简单字符串相关算法的复习笔记：</p>
<span id="more"></span>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>$\ \ \ \ \ \ \,$kmp是用来处理字符串匹配的常见简单算法，网上可以找到很多讲解，这里就不细讲了，一笔带过。</p>
<p>$\ \ \ \ \ \ \,$我们知道，暴力匹配两个字符串的复杂度是$O(n^2)$的，很多时候我们都不能接受这个复杂度，考虑如何减小复杂度，我们发现在暴力匹配的过程中，会重复匹配很多地方，所以我们从这里下手，进行优化。</p>
<p>$\ \ \ \ \ \ \,$引入kmp算法最核心的东西—— $ next$ 数组：</p>
<p>$\ \ \ \ \ \ \,$代表当前字符之前的字符串中，有多大长度的相同前缀。例如如果 $next [j] = k$，代表位置 $j$ 之前的字符串中有最大长度为 $k $ 的相同前缀。</p>
<p>$\ \ \ \ \ \ \,$意味着在某个字符失配时，告诉你下一步匹配中，模式串应该跳到哪个位置（$next [j]$ ）。如果 $next [j]$ 等于$-1$，则跳到模式串的开头字符，若 $next [j] = k$ 且 $k &gt; 0$，代表下次匹配跳到 $j$ 之前的某个字符，而不是跳到开头，跳过了 $k$ 个曾经匹配过的字符。</p>
<p>$\ \ \ \ \ \ \,$为什么这 $k$ 个字符就这样逃过了？我们可以这样感性地理解：</p>
<p>$\ \ \ \ \ \ \,$若是在 $j$ 这个位置失配，那么说明在这个位置之前，模式串和文本串是可以匹配的，也就是一样的，那么我们要是可以预处理下次跳到的地方就好了，这个就是我们预处理的结果：$ next$ 数组。</p>
<p>$\ \ \ \ \ \ \,$这样我们的匹配复杂度就降为$O(n)$：</p>
<p>$\ \ \ \ \ \ \,$假设现在文本串$S$匹配到 $i$ 位置，模式串$P$匹配到 $j$ 位置</p>
<ul>
<li><p>如果$j = -1$，或者当前字符匹配成功（即$S[i] = P[j]$），$i$，$j$都加一，继续匹配下一个字符；</p>
</li>
<li><p>如果$j \neq -1$，且当前字符匹配失败（即$S[i] \neq P[j]$），则令 $i$ 不变，$j = next[j]$。此举意味着失配时，模式串P相对于文本串S向右移动了$j - next [j]$ 位。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;slen&amp;&amp;j&lt;plen)&#123;</span><br><span class="line">  <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==p[j])i++,j++;</span><br><span class="line">  <span class="keyword">else</span> j=Next[j];</span><br><span class="line">  <span class="keyword">if</span>(j==plen)j=Next[j];<span class="comment">//到这里就匹配到了一个模式串了。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$那么我们如何快速地求出$ next$ 数组？</p>
<p>$\ \ \ \ \ \ \,$这个过程相当于自己与自己匹配，假设现在对于字符串$p$，已经处理到了 $k$ 位置，和自己匹配到了 $j$ 位置（显然$k&gt;j$）：</p>
<ul>
<li><p>如果$j&gt;0$，并且$p[k]\neq p[j]$，那么就是和自己失配了，$j = next[j]$；</p>
</li>
<li><p>如果$p[k]= p[j]$，那么就是是适配了，$k$，$j$都加一，同时如果下次匹配的时候在 $k+1$ 处失配了，那么我们就跳过枚举前面 $k$ 个元素，直接匹配 $j+1$，所以 $next[k+1]=j+1$。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">  <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;(p[k]!=p[j])) j=next[j];</span><br><span class="line">  j+=(p[k]==p[j]);next[k+<span class="number">1</span>]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$复杂度$O(n)$。</p>
<p>$\ \ \ \ \ \ \,$单字符串匹配的话，就是模板题不说了，kmp最重要的，还是对$ next$ 数组的运用。<del>（多字符串匹配我还是信仰Sam，XD）</del>，还是贴一个AC自动机的模板XD：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AC_Automata</span>&#123;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">26</span>][N],fail[N],appear[N];</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Get_trie</span><span class="params">(<span class="type">char</span> s[],<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!son[s[i]-<span class="string">&#x27;a&#x27;</span>][now])son[s[i]-<span class="string">&#x27;a&#x27;</span>][now]=++size;</span><br><span class="line">			now=son[s[i]-<span class="string">&#x27;a&#x27;</span>][now]; </span><br><span class="line">		&#125;</span><br><span class="line">		appear[now]=id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)<span class="keyword">if</span>(son[i][<span class="number">0</span>]!=<span class="number">0</span>)</span><br><span class="line">		fail[son[i][<span class="number">0</span>]]=<span class="number">0</span>,Q.<span class="built_in">push</span>(son[i][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">			<span class="keyword">if</span>(son[i][u])fail[son[i][u]]=son[i][fail[u]],Q.<span class="built_in">push</span>(son[i][u]);</span><br><span class="line">			<span class="keyword">else</span> son[i][u]=son[i][fail[u]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">      now=son[s[i]-<span class="string">&#x27;a&#x27;</span>][now];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> t=now;t;t=fail[t])</span><br><span class="line">			<span class="comment">//something about appear[t];</span></span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="P3193-HNOI2008-GT考试"><a href="#P3193-HNOI2008-GT考试" class="headerlink" title="P3193 [HNOI2008]GT考试"></a><a href="https://www.luogu.org/problemnew/show/P3193">P3193 [HNOI2008]GT考试</a></h3><p>$\ \ \ \ \ \ \,$很明显的，我们会得到一个DP方程式：</p>
<p>$\ \ \ \ \ \ \,$我们令$f(i,j)$表示我们$X$已经处理到了$i$，其中出现了长度为$j$的连续不吉利数字。</p>
<p>$\ \ \ \ \ \ \,$答案显然就是$\sum_{i=0}^{m-1}f(n,i)$，现在考虑如何转移。</p>
<p>$\ \ \ \ \ \ \,$令$g(i,j)$表示，在长度为$j$的连续不吉利数字后，跟上数字$j$后，不吉利数字的长度。</p>
<p>$\ \ \ \ \ \ \,$那么就有：</p>
<p>$f(i,j)=\sum_{b=0}^{9} f(i,a)[j=g(a,b)]$</p>
<p>$\ \ \ \ \ \ \,$其中$g(a,b)$就可以用kmp的$ next$ 数组找到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> j,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;a[j]!=k)j=next[j];</span><br><span class="line">  <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$我们可以花$O(10\cdot m^2)$的时间把$g$预处理出来，如何$O(nm)$来dp，但是$n$特别大，于是我们用矩阵来优化，完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n,m,mod;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;<span class="type">int</span> n,m;<span class="type">int</span> a[N][N];&#125;A,B;</span><br><span class="line"><span class="keyword">inline</span> Matrix <span class="keyword">operator</span> *(<span class="type">const</span> Matrix &amp;a,<span class="type">const</span> Matrix &amp;b)&#123;</span><br><span class="line">  Matrix ret;</span><br><span class="line">  ret.n=a.n;ret.m=b.m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=b.m;j++)&#123;</span><br><span class="line">    ret.a[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=a.m;k++)</span><br><span class="line">    ret.a[i][j]=(ret.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> next[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> j,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;a[j+<span class="number">1</span>]!=k)j=next[j];</span><br><span class="line">  <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();mod=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">-1</span>,i=<span class="number">1</span>;i&lt;=m;next[i++]=++j)</span><br><span class="line">  <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;a[i]!=a[j+<span class="number">1</span>])j=next[j];</span><br><span class="line">  A.n=<span class="number">0</span>;A.m=m<span class="number">-1</span>;</span><br><span class="line">  B.m=B.n=m<span class="number">-1</span>;</span><br><span class="line">  A.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">  B.a[i][<span class="built_in">g</span>(i,j)]++;</span><br><span class="line">  <span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,B=B*B)<span class="keyword">if</span>(n&amp;<span class="number">1</span>)A=A*B;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) ans=(ans+A.a[<span class="number">0</span>][i])%mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Manachar"><a href="#Manachar" class="headerlink" title="Manachar"></a>Manachar</h2><p>$\ \ \ \ \ \ \,$manachar算法特别单一，就是求回文串用的，题一般也特别裸，比较套路。</p>
<p>$\ \ \ \ \ \ \,$首先，我们知道的，回文串分奇偶，但是如果我们在这个串中每一个字符之间都插入一个特殊字符，那么偶回文串就变成奇回文串了，这样我们就可以只处理奇回文串就行了。</p>
<p>$\ \ \ \ \ \ \,$然后就是$RL$数组，表示以这个字符为中点，回文串的最大半径是多少，manachar算法就是$O(n)$求$RL$数组的算法。下面直接将做法，不讲原理了：</p>
<p>$\ \ \ \ \ \ \,$记我们已经处理的回文串已经处理到的最右端为$MR$，他的对称轴为$pos$，现在要处理的位置为$i$，显然$pos&lt;i$。</p>
<p>$\ \ \ \ \ \ \,$如果$MR&gt;i$，那么我们可以确定，已$i$为中点，回文串的最大半径至少是${\rm min}(RL[2\cdot pos-i],MR-i)$。</p>
<p>$\ \ \ \ \ \ \,$剩下的就是暴力扩展，记得到时候更新一下$MR$和$pos$，模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> RL[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manacher</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> MR=<span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(RL,<span class="number">0</span>,<span class="built_in">sizeof</span>(RL));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(MR&gt;i)RL[i]=<span class="built_in">min</span>(RL[<span class="number">2</span>*pos-i],MR-i);</span><br><span class="line">	<span class="keyword">else</span> RL[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i+RL[i]]==s[i-RL[i]])RL[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i+RL[i]&gt;MR)MR=i+RL[i],pos=i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  len=<span class="built_in">strlen</span>(s);P[<span class="number">0</span>]=<span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len*<span class="number">2</span>+<span class="number">1</span>;i+=<span class="number">2</span>) P[i]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) P[i*<span class="number">2</span>+<span class="number">2</span>]=s[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4555-国家集训队-最长双回文串"><a href="#P4555-国家集训队-最长双回文串" class="headerlink" title="P4555 [国家集训队]最长双回文串"></a><a href="https://www.luogu.org/problemnew/show/P4555">P4555 [国家集训队]最长双回文串</a></h3><p>$\ \ \ \ \ \ \,$在我们求好$RL$后，很明显的有一个dp，我们把对称轴上的信息移动到起始点和终点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">  L[i+RL[i]<span class="number">-1</span>]=<span class="built_in">max</span>(L[i+RL[i]<span class="number">-1</span>],RL[i]<span class="number">-1</span>);</span><br><span class="line">  R[i-RL[i]+<span class="number">1</span>]=<span class="built_in">max</span>(R[i-RL[i]+<span class="number">1</span>],RL[i]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$那么，显然的，答案等于：<br>${\rm Max}_{i=0}^{n-1}L_i+R_i[L_i\neq0,R_i\neq0]$</p>
<p>$\ \ \ \ \ \ \,$代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> RL[N&lt;&lt;<span class="number">1</span>],n;</span><br><span class="line"><span class="type">char</span> s[N],P[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> L[N&lt;&lt;<span class="number">1</span>],R[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manacher</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> MR=<span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(MR&gt;i)RL[i]=<span class="built_in">min</span>(RL[<span class="number">2</span>*pos-i],MR-i);</span><br><span class="line">    <span class="keyword">else</span> RL[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i+RL[i]]==s[i-RL[i]])RL[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i+RL[i]&gt;MR)MR=i+RL[i],pos=i;</span><br><span class="line">    L[i+RL[i]<span class="number">-1</span>]=<span class="built_in">max</span>(L[i+RL[i]<span class="number">-1</span>],RL[i]<span class="number">-1</span>);</span><br><span class="line">  	R[i-RL[i]+<span class="number">1</span>]=<span class="built_in">max</span>(R[i-RL[i]+<span class="number">1</span>],RL[i]<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  len=<span class="built_in">strlen</span>(s);P[<span class="number">0</span>]=<span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len*<span class="number">2</span>+<span class="number">1</span>;i+=<span class="number">2</span>) P[i]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) P[i*<span class="number">2</span>+<span class="number">2</span>]=s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);n=<span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="built_in">insert</span>(s,n);</span><br><span class="line">  <span class="built_in">Manacher</span>(P,n*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>+<span class="number">1</span>;i+=<span class="number">2</span>)R[i]=<span class="built_in">max</span>(R[i],R[i<span class="number">-2</span>]<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n*<span class="number">2</span>+<span class="number">1</span>;i&gt;=<span class="number">1</span>;i-=<span class="number">2</span>)L[i]=<span class="built_in">max</span>(L[i],L[i+<span class="number">2</span>]<span class="number">-2</span>);</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n+<span class="number">1</span>;i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span>(R[i]&amp;&amp;L[i])ans=<span class="built_in">max</span>(ans,L[i]+R[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>AC自动机</tag>
        <tag>Manachar</tag>
      </tags>
  </entry>
  <entry>
    <title>超低能解读群论</title>
    <url>/2018/12/30/%E8%B6%85%E4%BD%8E%E8%83%BD%E8%A7%A3%E8%AF%BB%E7%BE%A4%E8%AE%BA/</url>
    <content><![CDATA[<p>葱花的超低能解读群论 QUQ ，弱哭了1551</p>
<p>前排鸣谢：<br>（<del>PY关系</del>）指导：@<a href="http://psyduck.wang/">Psyduck</a>  （<del>日常%</del>）大jiu~佬：@<a href="https://www.luogu.org/blog/hdxrie/">hdxrie</a></p>
<p>推荐视频：<a href="http://www.bilibili.com/video/av11339177/?share_source=qq&amp;ts=1535624691&amp;share_medium=iphone&amp;bbid=182b868b7e157f70a15090b987621a32">嘿嘿嘿</a></p>
<span id="more"></span>
<h2 id="一、群的定义"><a href="#一、群的定义" class="headerlink" title="一、群的定义"></a><strong>一、群的定义</strong></h2><p>群是<strong><em>一些定义的映射</em></strong> 对于<strong><em>指定的有限集合</em></strong> 的集合；</p>
<p>其中群必须满足以下性质：</p>
<ul>
<li><p>封闭性：集合内元素间的映射不会超过<em>指定的有限集合</em>；</p>
</li>
<li><p>结合律：集合内元素间的映射满足结合律；</p>
</li>
<li><p>单位元：集合内存在一个基底元素，使得集合内所有的元素都可以用基底元素表示；</p>
</li>
<li><p>逆元：集合内必定存在成对的元素，使得经过<em>一些定义的映射</em>成为基地元素。</p>
</li>
</ul>
<p>更严格地讲，群的定义为：<br><img src="https://img-blog.csdnimg.cn/img_convert/e98cda276781b6aaf9485173901ef297.png" alt=""></p>
<p>注意群是<strong><em>映射的集合</em></strong> 不是 <strong><em>一些定义的映射</em></strong> +<strong><em>指定的有限集合</em></strong> 。</p>
<p>一个简单的例子：</p>
<p>实数的加法就是一个群（实数加法群）</p>
<ul>
<li><p><em>一些定义的映射</em>： +，-（加一个负数）；</p>
</li>
<li><p><em>指定的有限集合</em>： 全体实数；</p>
</li>
<li><p>封闭性：一个实数加上一个实数还是一个实数；</p>
</li>
<li><p>结合律：a,b,c为实数，则：$(a+b)+c=a+(b+c)$</p>
</li>
<li><p>单位元：0；</p>
</li>
<li><p>逆元：a为实数，那么a与-a互为彼此的逆元，即：$a+(-a)=0$</p>
</li>
</ul>
<p>然后举一个复杂一点点的例子，以后我们也会用到这个举例：</p>
<p>对于以下集合：（多种正方形）<br><img src="https://img-blog.csdnimg.cn/img_convert/1873425fe9facf08696a51a4b12d0086.png" alt=""></p>
<p>我们定义8种映射关系：<br><img src="https://img-blog.csdnimg.cn/img_convert/fa3432467ea0b19499f222d32fcf7dd5.png" alt=""></p>
<p>易证得，这<strong><em>8种映射关系</em></strong> 对于这个<strong><em>正方形集合</em></strong> 满足：</p>
<p><strong>封闭性</strong>，<strong>结合律</strong>，<strong>单位元</strong>(1号正方形)，<strong>逆元</strong>(2与4,5与5等)；</p>
<p>所以这个映射的集合为群。</p>
<p>具体证明不再赘述。</p>
<h2 id="二、群的模型与置换群"><a href="#二、群的模型与置换群" class="headerlink" title="二、群的模型与置换群"></a><strong>二、群的模型与置换群</strong></h2><p>对于第一部分下面这个集合：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/73b2ac8cec75893b6252939533222d1a.png" alt=""></p>
<p>我们可以发现：</p>
<h3 id="这个群的模型满足一个基本的有向图模型"><a href="#这个群的模型满足一个基本的有向图模型" class="headerlink" title="这个群的模型满足一个基本的有向图模型"></a><strong>这个群的模型满足一个基本的有向图模型</strong></h3><p>我们不妨把它建立出来观察一下它的性质：</p>
<p><strong>（边是映射，点是集合内元素，左上角是映射的类型在图上的颜色）</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1f0509162141be39d5e59534a5e6db78.png" alt=""></p>
<p>看起来很美好，对不对(<del>彩虹！！</del>)？</p>
<p>有点乱？我们可以分开看看：</p>
<p><strong>1. 不变</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7ae575a36a72234063a4532149b9ebdf.png" alt=""></p>
<p><strong>2. 旋转90°</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5cc866a84d940e71fee5b933b3c7e912.png" alt=""></p>
<p><strong>3. 旋转180°</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/91106336127712d5e0ecad51847f805f.png" alt=""></p>
<p><strong>4. 旋转270° </strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b3af25f76db1a4f3a6a7db90885cbfb1.png" alt=""></p>
<p><strong>5. 水平翻转</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7c479a79ba497450cd0034ac7afe4715.png" alt=""></p>
<p><strong>6. 竖直翻转</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7ef47ae9ba232a0472d224fe296a74e6.png" alt=""></p>
<p><strong>7. 45°翻转</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/145c031c3930a00bd99bb70fadc4ecd0.png" alt=""></p>
<p><strong>8. -45°翻转</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e7685a19bef91fa399e9f50d50f1d298.png" alt=""></p>
<h3 id="充分满足对称性的美好-彩虹！！"><a href="#充分满足对称性的美好-彩虹！！" class="headerlink" title="充分满足对称性的美好 (彩虹！！)"></a><strong>充分满足对称性的美好 (<del>彩虹！！</del>)</strong></h3><p>我们可以很轻松观察出这个映射集合的<strong>封闭性</strong>。</p>
<p><strong>结合律</strong>也可以被轻松观察出来看出来，就不举例子了：</p>
<p><strong>逆元</strong>就更显而易见了，除了2和4互为逆元，其他的映射都为自己的逆元：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/96392aa07fdd7171f129920894470175.png" alt=""></p>
<p>下面我们带入一个新的概念：<strong>置换</strong>和<strong>置换群</strong></p>
<p><del>直接上学长的ppt(%%%)</del></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/396b8ac9b47b0dfe9b35c93dbf9d21eb.png" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e04d2e4faade98c809589aab26b8998e.png" alt=""></p>
<p>简单点说，上面我们举例的群，它的八种映射方式，就是<strong>置换</strong>；</p>
<p>而8种置换组成的群，就是<strong>置换群</strong>；</p>
<p>我们举一个例子……hummmm……就比如：</p>
<p><strong>5. 水平翻转</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7c479a79ba497450cd0034ac7afe4715.png" alt=""></p>
<p>它的置换写法就是：</p>
<p>$\binom{1\ 2\ 3\ 4\ 5\ 6\ 7\ 8}{5\ 8\ 6\ 7\ 1\ 3\ 4\ 2}$</p>
<p>这不就是模型中有向图的<strong>边</strong>吗？</p>
<p>很简单？对吧？</p>
<p>那么现在，我们可以进入重点咯？</p>
<h2 id="三、Burnside引理-和-Polya定理"><a href="#三、Burnside引理-和-Polya定理" class="headerlink" title="三、Burnside引理 和 Pólya定理"></a><strong>三、Burnside引理 和 Pólya定理</strong></h2><p>先直接甩Burnside引理的定义：<del>(还是学长的pptOrz)</del></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/eab2ef3a46051c8c125cbfa4cdddab4c.png" alt=""></p>
<p>看上去挺复杂的？我们慢慢来吧。</p>
<p>先引入一个简单的概念：<strong>循环</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/918488795cc1fefdf0e1fdd0e9348324.png" alt=""></p>
<p>下面我们直接举个例子：<strong>置换的循环分解</strong></p>
<p>上一节末尾的例子：</p>
<p><strong>5. 水平翻转</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7c479a79ba497450cd0034ac7afe4715.png" alt=""></p>
<p>它的置换写法是：</p>
<p>$\binom{1\ 2\ 3\ 4\ 5\ 6\ 7\ 8}{5\ 8\ 6\ 7\ 1\ 3\ 4\ 2}$</p>
<p>解出来的循环就是：$(1\ 5)(2\ 8)(3\ 6)(4\ 7)$</p>
<p>放回模型看看呢？我们可以发现：</p>
<p>置换的循环分解就是<strong>模型中有向图的强连通分量</strong></p>
<p>不如我们再放两个例子呢？</p>
<p><strong>4. 旋转270°</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b3af25f76db1a4f3a6a7db90885cbfb1.png" alt=""></p>
<p>它的置换写法就是：</p>
<p>$\binom{1\ 2\ 3\ 4\ 5\ 6\ 7\ 8}{4\ 1\ 2\ 3\ 8\ 7\ 5\ 6}$</p>
<p>分解出来的循环就是：$(1\ 4\ 3\ 2)(5\ 8\ 6\ 7)$</p>
<p><strong>1. 不变</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7ae575a36a72234063a4532149b9ebdf.png" alt=""></p>
<p>它的置换写法就是：</p>
<p>$\binom{1\ 2\ 3\ 4\ 5\ 6\ 7\ 8}{1\ 2\ 3\ 4\ 5\ 6\ 7\ 8}$</p>
<p>分解出来的循环就是：$(1)(2)(3)(4)(5)(6)(7)(8)$</p>
<p>看样子我们的想法没有问题；</p>
<p>那么，现在我们重新给出Burnside引理的内容：</p>
<p><strong>设置大小为$|G|$，由$g$组成的群$G$，作用于有限集合$X$上面，那么$X$在$G$内映射的作用下，$X$的变换结果有这么多种：</strong></p>
<p>$\frac {\sum_{g\in G}^{} {X(g)}} {|G|}$</p>
<p><strong>其中$X(g)$为映射$g$对与集合$X$的操作结果</strong></p>
<p>现在，是不是清楚很多了呢(雾)？</p>
<p>不过我们发现，这个方法的复杂度特别高，不仅要枚举每一个映射，还要对每种映射枚举一次每个置换，所以引入Pólya定理：</p>
<p>先甩定义：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0abd64840b78465cc85c5be09b20ef9a.png" alt=""></p>
<p>即：</p>
<p><strong>设置大小为$|G|$，由$g$组成的群$G$，作用于$k$组合成的有限集合$X$上面，那么$X$在$G$内映射的作用下，$X$的变换结果种类有这么多：</strong></p>
<p>$\frac {\sum_{g\in G}^{} {k^{m(g)}}} {|G|}$</p>
<p><strong>其中$m(g)$为映射$g$对与集合$X$的操作结果</strong></p>
<p><strong>也就是把$X(g)$优化成了$k^{m(g)}$ ，减少了枚举操作。</strong></p>
<p>其中$m(g)$可以$O(n)$求，这个很简单，就是求一个有向图的强连通分量，就不举例子了。</p>
<h2 id="四、例题-Poj1286-Necklace-of-Beads"><a href="#四、例题-Poj1286-Necklace-of-Beads" class="headerlink" title="四、例题 Poj1286 Necklace of Beads"></a><strong>四、例题 <a href="http://poj.org/problem?id=1286">Poj1286 Necklace of Beads</a></strong></h2><h3 id="Necklace-of-Beads"><a href="#Necklace-of-Beads" class="headerlink" title="Necklace of Beads"></a><strong>Necklace of Beads</strong></h3><p>Time Limit: 1000MS    Memory Limit: 10000K</p>
<p><strong>Description</strong></p>
<p>Beads of red, blue or green colors are connected together into a circular necklace of n beads ( n &lt; 24 ). If the repetitions that are produced by rotation around the center of the circular necklace or reflection to the axis of symmetry are all neglected, how many different forms of the necklace are there? </p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/439aa0fd6365704a3b375bca89554514.png" alt=""></p>
<p><strong>Input</strong></p>
<p>The input has several lines, and each line contains the input data n.<br>-1 denotes the end of the input file.<br>Output<br>The output should contain the output data: Number of different forms, in each line correspondent to the input data.</p>
<p><strong>Sample Input</strong></p>
<p>4</p>
<p>5</p>
<p>-1</p>
<p><strong>Sample Output</strong></p>
<p>21</p>
<p>39</p>
<p><strong>题目大意：对于指定n，求得到红，绿，蓝三种颜色珠子串成的长度为n的项链有多少种(首尾相接)</strong></p>
<p>我们先来看一下这个群的映射方式：</p>
<p><strong>旋转，翻转。</strong></p>
<p>我们之前举的例子呢，刚好和$n=4$的情况差不多，建议各位读者巨佬可以自己画一下其他情况的草图仔细观察一下，我们可以发现具体群内的映射有如下规律：</p>
<p><strong>旋转一共有$n$个角度</strong>，顺时针旋转$i$格的置换中，每个循环的长度为$\frac{n}{gcd(i,n)}$，个数为$gcd(i,n)$；</p>
<p><strong>旋转共有$n$个对称轴</strong>，所以当$n$为奇数时，每一个对称轴都有$\left\lceil\frac{n}{2}\right\rceil$个循环；当$n$为偶数时，有一半的对称轴有$\frac{n}{2}$个循环，一半有$\frac{n}{2}+1$个；</p>
<p>利用Pólya定理，我们可以得到答案应该为如下公式：</p>
<p>当$n$为奇数：</p>
<p>$ans(n)=\frac{\sum_{i=1}^{n}3^{gcd(i,n)}+n\times 3^{\lceil\frac{n}{2}\rceil}}{n+n}$</p>
<p>当$n$为偶数：</p>
<p>$ans(n)=\frac{\sum_{i=1}^{n}3^{gcd(i,n)}+\frac{n}{2}\times 3^{\frac{n}{2}}+\frac{n}{2}\times 3^{\frac{n}{2}+1}}{n+n}$</p>
<p>那么代码实现就非常简单了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans=<span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans*=a;a*=a;b&gt;&gt;=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,g,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n)==<span class="number">1</span>&amp;&amp;n!=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)g=<span class="built_in">gcd</span>(n,i),ans+=<span class="built_in">power</span>(<span class="number">3</span>,g);</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans+=n*<span class="built_in">power</span>(<span class="number">3</span>,(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> ans+=(n&gt;&gt;<span class="number">1</span>)*<span class="built_in">power</span>(<span class="number">3</span>,(n+<span class="number">2</span>)&gt;&gt;<span class="number">1</span>),ans+=(n&gt;&gt;<span class="number">1</span>)*<span class="built_in">power</span>(<span class="number">3</span>,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    ans=ans/(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="感谢水本大jiu-蒻的博客QUQ，1551"><a href="#感谢水本大jiu-蒻的博客QUQ，1551" class="headerlink" title="感谢水本大jiu~蒻的博客QUQ，1551~"></a>感谢水本大jiu~蒻的博客QUQ，1551~</h5>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数学</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演经典例题回顾</title>
    <url>/2018/12/30/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$莫比乌斯反演经典例题回顾，思考和题解：</p>
<span id="more"></span>
<h2 id="P2522-HAOI2011-Problem-b"><a href="#P2522-HAOI2011-Problem-b" class="headerlink" title="P2522 [HAOI2011]Problem b"></a><a href="https://www.luogu.org/problemnew/show/P2522">P2522 [HAOI2011]Problem b</a></h2><p>$\sum_{i=a}^b\sum_{j=c}^d[gcd(i,j)=k]$</p>
<h3 id="反演过程："><a href="#反演过程：" class="headerlink" title="反演过程："></a>反演过程：</h3><p>${F(n,m)=\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=k]}$</p>
<p>$ans=F(a,b)-F(a-1,d)-F(b,c-1)+F(a-1,c-1)$</p>
<p>$F(n,m)=$</p>
<p>$\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{k}\right\rfloor}[gcd(i,j)=1]$</p>
<p>$\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{k}\right\rfloor}ϵ(gcd(i,j)=1)$</p>
<p>$\sum_{d=1}^{\left\lfloor\frac{min(n,m)}{k}\right\rfloor}\sum_{d|T}\mu(d){\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}$</p>
<p>$\sum_{d=1}^{\left\lfloor\frac{min(n,m)}{k}\right\rfloor}\mu(d){\left\lfloor\frac{n}{kd}\right\rfloor}{\left\lfloor\frac{m}{kd}\right\rfloor}$</p>
<ul>
<li>$\ \ \ \ \ \,$ $O(n)$预处理$\mu$，每次询问分块，复杂度$O(\sqrt n)$，总复杂度为$O(n+T4\sqrt n)$</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],mu[N],sum[N],k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_mu</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;mu[i]=<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Ans</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    a/=k;b/=k;</span><br><span class="line">  <span class="type">int</span> max_rep=<span class="built_in">min</span>(a,b);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=max_rep;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(a/(a/l),b/(b/l));</span><br><span class="line">    ans+=(<span class="type">long</span> <span class="type">long</span>)(a/l)*(<span class="type">long</span> <span class="type">long</span>)(b/l)*(<span class="type">long</span> <span class="type">long</span>)(sum[r]-sum[l<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line"> 	<span class="built_in">get_mu</span>(N<span class="number">-10</span>);</span><br><span class="line"> 	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line"> 		<span class="type">int</span> a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>(),d=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Ans</span>(b,d)-<span class="built_in">Ans</span>(b,c<span class="number">-1</span>)-<span class="built_in">Ans</span>(a<span class="number">-1</span>,d)+<span class="built_in">Ans</span>(a<span class="number">-1</span>,c<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P2257-YY的GCD"><a href="#P2257-YY的GCD" class="headerlink" title="P2257 YY的GCD"></a><a href="https://www.luogu.org/problemnew/show/P2257">P2257 YY的GCD</a></h2><p>$\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)\rm\ \ is\ \ prime]$</p>
<h3 id="反演过程：-1"><a href="#反演过程：-1" class="headerlink" title="反演过程："></a>反演过程：</h3><p>$\sum_{p=1,[p\rm\ \ is\ \ prime]}\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=p]$</p>
<p>$\sum_{p=1,[p\rm\ \ is\ \ prime]}\sum_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{p}\right\rfloor}[gcd(i,j)=1]$</p>
<p>$\sum_{p=1,[p\rm\ \ is\ \ prime]}\sum_{d=1}^{\left\lfloor\frac{min(n,m)}{p}\right\rfloor}\mu(d){\left\lfloor\frac{n}{pd}\right\rfloor}{\left\lfloor\frac{m}{pd}\right\rfloor}$</p>
<p>$\sum_{T=1}^{min(n,m)}\sum_{d|T}\mu(d){\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}\left[\frac{T}{d}\rm\ \ is\ \ prime\right]$</p>
<p>$\sum_{T=1}^{min(n,m)}{\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}\sum_{d|T,\left[d\rm\ \ is\ \ prime\right]}\mu\left(\frac{T}{d}\right)$</p>
<p>${F(x)=\sum_{d|x,\left[d\rm\ \ is\ \ prime\right]}\mu\left(\frac{x}{d}\right)}$</p>
<p>${\sum_{T=1}^{min(n,m)}{\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}F(T)}$</p>
<ul>
<li>$\ \ \ \ \ \,$ $O(n)$预处理$\mu$，$O(n\log{n})$预处理$F$，每次询问分块，复杂度$O(\sqrt n)$，总复杂度为$O(n\log n+T\sqrt n)$</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],mu[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> F[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_mu</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;mu[i]=<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=prim[<span class="number">0</span>];i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j*prim[i]&lt;=n;j++)F[j*prim[i]]+=(<span class="type">long</span> <span class="type">long</span>)mu[j];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)F[i]+=F[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Ans</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> lim=<span class="built_in">min</span>(n,m);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=lim;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">    ans+=(<span class="type">long</span> <span class="type">long</span>)(n/l)*(<span class="type">long</span> <span class="type">long</span>)(m/l)*(F[r]-F[l<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">get_mu</span>(N<span class="number">-10</span>);</span><br><span class="line">  <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Ans</span>(n,m));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P3312-SDOI2014-数表"><a href="#P3312-SDOI2014-数表" class="headerlink" title="P3312 [SDOI2014]数表"></a><a href="https://www.luogu.org/problemnew/show/P3312">P3312 [SDOI2014]数表</a></h2><p>$\sum_{i=1}^n\sum_{j=1}^m\sum_{k|gcd(i,j)}k\left[\sum_{k|gcd(i,j)}k≤a\right]$</p>
<h3 id="反演过程：-2"><a href="#反演过程：-2" class="headerlink" title="反演过程："></a>反演过程：</h3><p>$F(x)=\sum_{i|x}i$</p>
<p>$\sum_{i=1}^n\sum_{j=1}^mF(gcd(i,j))[F(gcd(i,j))≤a]$</p>
<p>$\sum_{d=1}^{min(n,m)}\sum_{i=1}^n\sum_{j=1}^mF(d)[gcd(i,j)=d][F(d)≤a]$</p>
<p>$\sum_{d=1}^{min(n,m)}F(d)[F(d)≤a]\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]$</p>
<p>$\sum_{d=1}^{min(n,m)}F(d)[F(d)≤a]\sum_{d’=1}^{\left\lfloor\frac{min(n,m)}{d}\right\rfloor}\mu(d’)\left\lfloor\frac{n}{d’d}\right\rfloor\left\lfloor\frac{m}{d’d}\right\rfloor$</p>
<p>$\sum_{T=1}^{min(n,m)}\sum_{d|T}F(d)\mu\left(\frac{T}{d}\right){\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}[F(d)≤a]$</p>
<p>$\sum_{T=1}^{min(n,m)}{\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}\sum_{d|T}F(d)\mu\left(\frac{T}{d}\right)[F(d)≤a]$</p>
<p>$f(x)=\sum_{d|T}F(d)\mu\left(\frac{T}{d}\right)[F(d)≤a]$</p>
<p>$\sum_{T=1}^{min(n,m)}{\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}f(T)$</p>
<ul>
<li>$\ \ \ \ \ \,$ $O(n\log n)$预处理$F$和$\mu$，把每次询问的$a$值离线排序，用树状数组维护$f$，花费时间$O(n\log ^2n)$，询问分块，复杂度$O(\sqrt n\log n)$，总时间复杂度$O(n\log ^2n+T\sqrt n\log n)$</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Q=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],mu[N];</span><br><span class="line"><span class="type">int</span> S=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&#123;<span class="type">int</span> data,id;&#125;F[N];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(Sum a,Sum b)&#123;<span class="keyword">return</span> a.data&lt;b.data;&#125;</span><br><span class="line"><span class="type">int</span> ans[Q];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">for</span>(;i&lt;=N<span class="number">-5</span>;i+=<span class="built_in">lowbit</span>(i))sum[i]+=c;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;i;i-=<span class="built_in">lowbit</span>(i))ans+=sum[i];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ed=((N<span class="number">-5</span>)/i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=ed;++j)</span><br><span class="line">  <span class="built_in">add</span>(i*j,data*mu[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">2</span>;i&lt;=N<span class="number">-5</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;mu[i]=<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=N<span class="number">-5</span>;++j)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-5</span>;++i)&#123;</span><br><span class="line">    F[i].id=i;</span><br><span class="line">    <span class="type">int</span> ed=((N<span class="number">-5</span>)/i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=ed;++j)</span><br><span class="line">    F[i*j].data+=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(F+<span class="number">1</span>,F+<span class="number">1</span>+N<span class="number">-5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;<span class="type">int</span> n,m,a,id;&#125;q[Q];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Query &amp;a,<span class="type">const</span> Query &amp;b)&#123;<span class="keyword">return</span> a.a&lt;b.a;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line">    q[i].n=<span class="built_in">read</span>();q[i].m=<span class="built_in">read</span>();q[i].a=<span class="built_in">read</span>();q[i].id=i;</span><br><span class="line">    <span class="keyword">if</span>(q[i].n&gt;q[i].m)<span class="built_in">swap</span>(q[i].n,q[i].m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(q+<span class="number">1</span>,q+T+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line">    <span class="type">int</span> n=q[i].n,m=q[i].m,a=q[i].a,id=q[i].id;</span><br><span class="line">    <span class="keyword">while</span>(F[S].data&lt;=a)&#123;<span class="built_in">Add</span>(F[S].id,F[S].data);S++;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">      r=<span class="built_in">min</span>(n/(n/l),(m/(m/l)));</span><br><span class="line">      ans[id]+=(n/l)*(m/l)*(<span class="built_in">query</span>(r)-<span class="built_in">query</span>(l<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]&amp;<span class="number">0x7fffffff</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="P3704-SDOI2017-数字表格"><a href="#P3704-SDOI2017-数字表格" class="headerlink" title="P3704 [SDOI2017]数字表格"></a><a href="https://www.luogu.org/problemnew/show/P3704">P3704 [SDOI2017]数字表格</a></h2><p>$\prod_{i=1}^{n}\prod_{j=1}^{m}f\left(gcd(i,j)\right)$</p>
<p>$\ \ \ \ \ \,$ $f$为斐波拉契序列。</p>
<h3 id="反演过程：-3"><a href="#反演过程：-3" class="headerlink" title="反演过程："></a>反演过程：</h3><p>$\prod_{i=1}^{min(n,m)}\prod_{i=1}^{n}\prod_{j=1}^{m}f(d)\left[gcd(i,j)=d\right]$</p>
<p>$\prod_{d=1}^{min(n,m)}f(d)^{\sum_{i=1}^n\sum_{j=1}^{m}\left[gcd(i,j)=d\right]}$</p>
<p>$\prod_{d=1}^{min(n,m)}f(d)^{\sum_{d’=1}^{\left\lfloor\frac{min(n,m)}{d}\right\rfloor}\mu(d’)\left\lfloor\frac{n}{d’d}\right\rfloor\left\lfloor\frac{m}{d’d}\right\rfloor}$</p>
<p>$\prod_{d=1}^{min(n,m)}\prod_{d’=1}^{\left\lfloor\frac{min(n,m)}{d}\right\rfloor}f(d)^{\mu(d’)\left\lfloor\frac{n}{d’d}\right\rfloor\left\lfloor\frac{m}{d’d}\right\rfloor}$</p>
<p>$\prod_{T=1}^{min(n,m)}\prod_{d|T}f(d)^{\mu\left(\frac{T}{d}\right)\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor}$</p>
<p>${C(x)=\prod_{d|T}f(d)^{\mu\left(\frac{T}{d}\right)}}$</p>
<p>$\prod_{T=1}^{min(n,m)}C(T)^{\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor}$</p>
<ul>
<li>$\ \ \ \ \ \,$ $O(n)$预处理$f$和$\mu$，$O(n\log{n})$预处理$C$，每次询问分块，复杂度$O(\sqrt n \log n)$，总复杂度为$O(n\log n+T\sqrt n \log n)$</li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;  </span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1ll</span>;  </span><br><span class="line">  a=a%mod;</span><br><span class="line">  <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%mod;</span><br><span class="line">    b&gt;&gt;=<span class="number">1</span>;a=(a*a)%mod;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],mu[N],sum[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> C[N],g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_mu</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  g[<span class="number">1</span>]=C[<span class="number">0</span>]=C[<span class="number">1</span>]=<span class="number">1ll</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  	g[i]=<span class="built_in">power</span>(f[i],mod<span class="number">-2</span>);C[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;mu[i]=<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mu[i])<span class="keyword">continue</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)</span><br><span class="line">    C[j]=<span class="number">1ll</span>*C[j]*(mu[i]==<span class="number">1</span>?f[j/i]:g[j/i])%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)C[i]=<span class="number">1ll</span>*C[i]*C[i<span class="number">-1</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f[<span class="number">1</span>]=f[<span class="number">2</span>]=<span class="number">1ll</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=N<span class="number">-10</span>;i++)f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>],f[i]%=mod;</span><br><span class="line">  <span class="built_in">get_mu</span>(N<span class="number">-10</span>);</span><br><span class="line">  <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m)<span class="built_in">swap</span>(n,m);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,lim=<span class="number">0</span>;i&lt;=n;i=lim+<span class="number">1</span>)&#123;</span><br><span class="line">      lim=<span class="built_in">min</span>(n/(n/i),m/(m/i));</span><br><span class="line">      ans=<span class="number">1ll</span>*ans*<span class="built_in">power</span>(C[lim]*<span class="built_in">power</span>(C[i<span class="number">-1</span>],mod<span class="number">-2</span>),<span class="number">1ll</span>*(n/i)*(m/i)%(mod<span class="number">-1</span>));</span><br><span class="line">      ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P3327-SDOI2015-约数个数和"><a href="#P3327-SDOI2015-约数个数和" class="headerlink" title="P3327 [SDOI2015]约数个数和"></a><a href="https://www.luogu.org/problemnew/show/P3327">P3327 [SDOI2015]约数个数和</a></h2><p>$\sum_{i=1}^n\sum_{j=1}^m\sum_{k|gcd(i,j)}1$</p>
<h3 id="反演过程：-4"><a href="#反演过程：-4" class="headerlink" title="反演过程："></a>反演过程：</h3><p>$F(x)=\sum_{i|x}1$</p>
<p>$\sum_{i=1}^n\sum_{j=1}^mF(gcd(i,j))$</p>
<p>$\sum_{d=1}^{min(n,m)}\sum_{i=1}^n\sum_{j=1}^mF(d)[gcd(i,j)=d]$</p>
<p>$\sum_{d=1}^{min(n,m)}F(d)\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]$</p>
<p>$\sum_{d=1}^{min(n,m)}F(d)\sum_{d’=1}^{\left\lfloor\frac{min(n,m)}{d}\right\rfloor}\mu(d’)\left\lfloor\frac{n}{d’d}\right\rfloor\left\lfloor\frac{m}{d’d}\right\rfloor$</p>
<p>$\sum_{T=1}^{min(n,m)}\sum_{d|T}F(d)\mu\left(\frac{T}{d}\right){\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}$</p>
<p>$\sum_{T=1}^{min(n,m)}{\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}\sum_{d|T}F(d)\mu\left(\frac{T}{d}\right)$</p>
<p>$f(x)=\sum_{d|T}F(d)\mu\left(\frac{T}{d}\right)$</p>
<p>$\sum_{T=1}^{min(n,m)}{\left\lfloor\frac{n}{T}\right\rfloor}{\left\lfloor\frac{m}{T}\right\rfloor}f(T)$</p>
<ul>
<li>$\ \ \ \ \ \,$ $O(n\log n)$预处理$F$，$f$和$\mu$，询问分块，复杂度$O(\sqrt n\log n)$，总时间复杂度$O(n\log n+T\sqrt n\log n)$，和<a href="https://www.luogu.org/problemnew/show/P3312">P3312 [SDOI2014]数表</a>这道题差不多</li>
</ul>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],mu[N],sum[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_mu</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;mu[i]=<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=i;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">      r=(i/(i/l));</span><br><span class="line">      ans+=<span class="number">1ll</span>*(r-l+<span class="number">1</span>)*<span class="number">1ll</span>*(i/l);</span><br><span class="line">    &#125;</span><br><span class="line">    g[i]=ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Ans</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> max_rep=<span class="built_in">min</span>(n,m);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=max_rep;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">  	ans+=(sum[r]-sum[l<span class="number">-1</span>])*<span class="number">1ll</span>*g[n/l]*<span class="number">1ll</span>*g[m/l];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line"> 	<span class="built_in">get_mu</span>(N<span class="number">-10</span>);</span><br><span class="line"> 	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line"> 		<span class="type">int</span> a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Ans</span>(a,b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="P3455-POI2007-ZAP-Queries"><a href="#P3455-POI2007-ZAP-Queries" class="headerlink" title="P3455 [POI2007]ZAP-Queries"></a><a href="https://www.luogu.org/problemnew/show/P3455">P3455 [POI2007]ZAP-Queries</a></h2><p>$\sum_{i=1}^a\sum_{j=1}^b[gcd(i,j)=c]$</p>
<h3 id="反演过程：-5"><a href="#反演过程：-5" class="headerlink" title="反演过程："></a>反演过程：</h3><p>$\sum_{i=1}^a\sum_{j=1}^b[gcd(i,j)=1]$</p>
<p>$\sum_{i=1}^{\left\lfloor\frac{a}{c}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{b}{c}\right\rfloor}ϵ(gcd(i,j))$</p>
<p>$\sum_{i=1}^{\left\lfloor\frac{a}{c}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{b}{c}\right\rfloor}(\mu*1)(gcd(i,j))$</p>
<p>$\sum_{i=1}^{\left\lfloor\frac{a}{c}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{b}{c}\right\rfloor}\sum_{d|gcd(i,j)}\mu(d)\times 1$</p>
<p>$\sum_{x=1}^{\left\lfloor\frac{min(a,b)}{c}\right\rfloor}\sum_{d|x}\mu(d){\left\lfloor\frac{a}{xc}\right\rfloor}{\left\lfloor\frac{b}{xc}\right\rfloor}$</p>
<p>$\sum_{d=1}^{\left\lfloor\frac{min(a,b)}{c}\right\rfloor}\mu(d){\left\lfloor\frac{a}{dc}\right\rfloor}{\left\lfloor\frac{b}{dc}\right\rfloor}$</p>
<ul>
<li>$\ \ \ \ \ \,$ 裸题啊！模板啊！$O(n)$预处理$\mu$，询问分块，复杂度$O(\sqrt n)$，总时间复杂度$O(n+T\sqrt n)$</li>
</ul>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],mu[N],sum[N],k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_mu</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;mu[i]=<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Ans</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> max_rep=<span class="built_in">min</span>(a,b);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=max_rep;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(a/(a/l),b/(b/l));</span><br><span class="line">    ans+=(<span class="type">long</span> <span class="type">long</span>)(a/(l*k))*(<span class="type">long</span> <span class="type">long</span>)(b/(l*k))*(<span class="type">long</span> <span class="type">long</span>)(sum[r]-sum[l<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	T=<span class="built_in">read</span>();</span><br><span class="line"> 	<span class="built_in">get_mu</span>(N<span class="number">-10</span>);</span><br><span class="line"> 	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line"> 		<span class="type">int</span> a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Ans</span>(a,b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1829-国家集训队-Crash的数字表格-JZPTAB"><a href="#P1829-国家集训队-Crash的数字表格-JZPTAB" class="headerlink" title="P1829 [国家集训队]Crash的数字表格 / JZPTAB"></a><a href="https://www.luogu.org/problemnew/show/P1829">P1829 [国家集训队]Crash的数字表格 / JZPTAB</a></h2><p>$\sum_{i=1}^n\sum_{j=1}^m lca(i,j)$</p>
<h3 id="反演过程：-6"><a href="#反演过程：-6" class="headerlink" title="反演过程："></a>反演过程：</h3><p>$\sum_{i=1}^n\sum_{j=1}^m\frac{ij}{gcd(i,j)}$</p>
<p>$\sum_{d=1}^{min(n,m)}\sum_{i=1}^n\sum_{j=1}^m\frac{ij}{d}[gcd(i,j)=d]$</p>
<p>$\sum_{d=1}^{min(n,m)}\frac{1}{d}\sum_{i=1}^n\sum_{j=1}^mij[gcd(i,j)=d]$</p>
<p>$\sum_{d=1}^{min(n,m)}\frac{1}{d}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}ij\cdot d^2[gcd(i,j)=1]$</p>
<p>$\sum_{d=1}^{min(n,m)}d\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}ij[gcd(i,j)=1]$</p>
<p>$\sum_{d=1}^{min(n,m)}d\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}ijϵ(gcd(i,j))$</p>
<p>$\sum_{d=1}^{min(n,m)}d\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}ij\sum_{k|gcd(i,j)}\mu(k)$</p>
<p>$\sum_{d=1}^{min(n,m)}d\sum_{k=1}^{\left\lfloor\frac{min(n,m)}{d}\right\rfloor}\mu(k)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}ij[k|gcd(i,j)]$</p>
<p>$\sum_{d=1}^{min(n,m)}d\sum_{k=1}^{\left\lfloor\frac{min(n,m)}{d}\right\rfloor}\mu(k)\sum_{i=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{dk}\right\rfloor}ij\cdot k^2$</p>
<p>$\sum_{d=1}^{min(n,m)}d\sum_{k=1}^{\left\lfloor\frac{min(n,m)}{d}\right\rfloor}\mu(k)\cdot k^2\sum_{i=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{dk}\right\rfloor}ij$</p>
<p>$\begin{aligned}F(n,m)=&amp;\sum_{k=1}^{\frac{min(n,m)}{d}}\mu(k)\cdot k^2\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}ij\\=&amp;\sum_{k=1}^{\frac{min(n,m)}{d}}\mu(k)\cdot k^2\cdot\frac{\left\lfloor\frac{n}{k}\right\rfloor\cdot(\left\lfloor\frac{n}{k}\right\rfloor+1)}{2}\times\frac{\left\lfloor\frac{m}{k}\right\rfloor\cdot(\left\lfloor\frac{m}{k}\right\rfloor+1)}{2} \end{aligned}$</p>
<p>$\sum_{d=1}^{min(n,m)}d\times F\left(\left\lfloor\frac{n}{k}\right\rfloor,\left\lfloor\frac{m}{k}\right\rfloor\right)$</p>
<ul>
<li>$\ \ \ \ \ \,$ 感觉很神奇，需要连续提取 $2$ 次公约数，$O(n)$预处理$\mu$，分块询问$F$,$O(\sqrt{\sqrt n})$,答案询问分块，复杂度$O(\sqrt n)$，嵌套起来总时间复杂度$O(n+n^{\frac{3}{4}})$，代码比较丑</li>
</ul>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">20101009</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],mu[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_mu</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;mu[i]=<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  sum[i]=(sum[i<span class="number">-1</span>]+<span class="number">1ll</span>*mu[i]*<span class="number">1ll</span>*i%mod*<span class="number">1ll</span>*i%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line"> 	<span class="keyword">if</span>(n&gt;m)<span class="built_in">swap</span>(n,m);</span><br><span class="line">  <span class="built_in">get_mu</span>(n);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> inv2=(mod+<span class="number">1ll</span>)/<span class="number">2ll</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>;d&lt;=n;d++)&#123;</span><br><span class="line">    <span class="type">int</span> x=n/d,y=m/d,minn=<span class="built_in">min</span>(x,y);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> Sum=<span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=minn;l=r+<span class="number">1ll</span>)&#123;</span><br><span class="line">    	r=<span class="built_in">min</span>(x/(x/l),y/(y/l));</span><br><span class="line">      Sum=(Sum+(sum[r]-sum[l<span class="number">-1</span>])%mod*(((<span class="number">1ll</span>+x/l)%mod*<span class="number">1ll</span>*(x/l)%mod*inv2%mod)%mod)%mod*(((<span class="number">1ll</span>+y/l)%mod*<span class="number">1ll</span>*(y/l)%mod*inv2%mod)%mod)%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ans+Sum*<span class="number">1ll</span>*d)%mod;</span><br><span class="line">  &#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans%mod+mod)%mod);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩展：这个题其实是两道题的融合，上面的方法是过不了JZPTAB的，在bzoj上面是权限题，所以先挖坑，我们下面继续来化简：</li>
</ul>
<p>$\sum_{d=1}^{min(n,m)}d\sum_{k=1}^{\left\lfloor\frac{min(n,m)}{d}\right\rfloor}\mu(k)\cdot k^2\sum_{i=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{dk}\right\rfloor}ij$</p>
<p>$\sum_{d=1}^{min(n,m)}\sum_{k=1}^{\left\lfloor\frac{min(n,m)}{d}\right\rfloor}d\cdot \mu(k)\cdot k^2\sum_{i=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{dk}\right\rfloor}ij$</p>
<p>$\sum_{T=1}^{min(n,m)}\sum_{i=1}^{\left\lfloor\frac{n}{T}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{T}\right\rfloor}ij\sum_{d|T}\frac{T}{d}\cdot \mu(d)\cdot d^2$</p>
<p>$\sum_{T=1}^{min(n,m)}\sum_{i=1}^{\left\lfloor\frac{n}{T}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{T}\right\rfloor}ij\sum_{d|T}T \mu(d) d$</p>
<p>$F(T)=\sum_{d|T}T \mu(d) d$</p>
<p>$\sum_{T=1}^{min(n,m)}\frac{\left\lfloor\frac{n}{T}\right\rfloor\cdot(\left\lfloor\frac{n}{T}\right\rfloor+1)}{2}\times\frac{\left\lfloor\frac{m}{T}\right\rfloor\cdot(\left\lfloor\frac{m}{T}\right\rfloor+1)}{2}\times F(T)$</p>
<ul>
<li><p>$\ \ \ \ \ \,$ 显然，$F$是积性函数，我们最快可以$O(n)$地把他筛出来，具体操作可以看<a href="https://www.luogu.org/blog/Althen-Way-Satan/xian-xing-shai">【积性函数的线性筛】</a>，欧拉筛三步走，询问分块，复杂度$O(\sqrt n)$,总时间复杂度$O(n+T\sqrt n)$</p>
<p>$\tt step1$. 如果$p$是素数：<br>$f(p)=p-p^2$</p>
<p>$\tt step2$. 如果$p$是素数，$i\%p\neq0$：$f(pi)=f(i)\times (p-p^2)$</p>
<p>$\tt step3$. 如果$p$是素数，$i\%p=0$：我们把 $pi$ 分解成 $p^cx$ ：<br>$f(pi)=f(p^cx)=f(x)\times(p^c-p^{c+1})$</p>
</li>
</ul>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">20101009</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> inv2=(mod+<span class="number">1ll</span>)/<span class="number">2ll</span>;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> pri[N],cnt[N],power[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> prime[N],f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Shai</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">  f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)power[i]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">      cnt[i]=<span class="number">1</span>;pri[i]=i;power[i]=i;</span><br><span class="line">      prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">      f[i]=(<span class="number">1ll</span>*i<span class="number">-1ll</span>*i*i%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="number">1</span>,v,pc;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">      v=i*prime[j];</span><br><span class="line">      vis[v]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">        cnt[v]=cnt[i]+<span class="number">1</span>;pri[v]=pri[i];power[v]=(<span class="number">1ll</span>*power[i]*pri[i])%mod;</span><br><span class="line">        f[v]=f[v/power[v]]*(<span class="number">1ll</span>*power[v]<span class="number">-1ll</span>*power[v]*pri[i]%mod+mod)%mod;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cnt[v]=<span class="number">1</span>;pri[v]=prime[j];power[v]=prime[j];</span><br><span class="line">      f[v]=(f[i]*f[prime[j]])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i]=(<span class="number">1ll</span>*f[i]+f[i<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Get_ans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> Sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=x;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(x/(x/l),y/(y/l));</span><br><span class="line">    Sum=(Sum+(<span class="number">1ll</span>*f[r]-f[l<span class="number">-1</span>]+mod)%mod*(((<span class="number">1ll</span>+x/l)%mod*<span class="number">1ll</span>*(x/l)%mod*inv2%mod)%mod)%mod*(((<span class="number">1ll</span>+y/l)%mod*<span class="number">1ll</span>*(y/l)%mod*inv2%mod)%mod)%mod)%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">if</span>(n&gt;m)<span class="built_in">swap</span>(n,m);</span><br><span class="line">  <span class="built_in">Get_Shai</span>(<span class="number">1ll</span>*n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">Get_ans</span>(n,m)%mod+mod)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>再扩展，这道题还可以用杜教筛加速的，具体<a href="https://blog.csdn.net/VictoryCzt/article/details/85054670?tdsourcetag=s_pctim_aiomsg">戳这里</a>，感觉和这道题差不多<a href="https://www.luogu.org/problemnew/show/P3768">P3768</a>，就不贴了。</li>
</ul>
<h2 id="P3768-简单的数学题"><a href="#P3768-简单的数学题" class="headerlink" title="P3768 简单的数学题"></a><a href="https://www.luogu.org/problemnew/show/P3768">P3768 简单的数学题</a></h2><p>$\sum_{i=1}^n\sum_{j=1}^nijgcd(i,j)$</p>
<h3 id="反演过程：-7"><a href="#反演过程：-7" class="headerlink" title="反演过程："></a>反演过程：</h3><p>$\sum_{d=1}^{n}\sum_{i=1}^n\sum_{j=1}^nijd[gcd(i,j)=d]$</p>
<p>$\sum_{d=1}^{n}d\sum_{i=1}^n\sum_{j=1}^nij[gcd(i,j)=d]$</p>
<p>$\sum_{d=1}^{n}{d}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}ij\cdot d^2[gcd(i,j)=1]$</p>
<p>$\sum_{d=1}^{n}{d^3}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}ij[gcd(i,j)=1]$</p>
<p>$\sum_{d=1}^{n}d^3\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}ijϵ(gcd(i,j))$</p>
<p>$\sum_{d=1}^{n}d^3\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}ij\sum_{k|gcd(i,j)}\mu(k)$</p>
<p>$\sum_{d=1}^{n}d^3\sum_{k=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(k)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}ij[k|gcd(i,j)]$</p>
<p>$\sum_{d=1}^{n}d^3\sum_{k=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(k)\sum_{i=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{dk}\right\rfloor}ij\cdot k^2$</p>
<p>$\sum_{d=1}^{n}d^3\sum_{k=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(k)\cdot k^2\sum_{i=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{dk}\right\rfloor}ij$</p>
<p>$\sum_{T=1}^{n}\sum_{i=1}^{\left\lfloor\frac{n}{T}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{T}\right\rfloor}ij\sum_{d|T}d^3\cdot \mu\left(\frac{T}{d}\right)\cdot \left(\frac{T}{d}\right)^2$</p>
<p>$\sum_{T=1}^{n}\sum_{i=1}^{\left\lfloor\frac{n}{T}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{T}\right\rfloor}ij\sum_{d|T}T^2\cdot d\cdot \mu\left(\frac{T}{d}\right)$</p>
<p>$\sum_{T=1}^{n}\sum_{i=1}^{\left\lfloor\frac{n}{T}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{T}\right\rfloor}ijT^2\sum_{d|T}d\cdot \mu\left(\frac{T}{d}\right)$</p>
<p>$\sum_{T=1}^{n}\sum_{i=1}^{\left\lfloor\frac{n}{T}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{T}\right\rfloor}ijT^2(id*\mu)(T)$</p>
<p>$\sum_{T=1}^{n}\sum_{i=1}^{\left\lfloor\frac{n}{T}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{T}\right\rfloor}ijT^2\varphi(T)$</p>
<p>$\sum_{T=1}^{n}\frac{\left\lfloor\frac{n}{T}\right\rfloor\cdot(\left\lfloor\frac{n}{T}\right\rfloor+1)}{2}\times\frac{\left\lfloor\frac{m}{T}\right\rfloor\cdot(\left\lfloor\frac{m}{T}\right\rfloor+1)}{2}\times T^2\varphi(T)$</p>
<ul>
<li><p>$\ \ \ \ \ \,$ 需要连续提取 $2$ 次公约数，和<a href="https://www.luogu.org/problemnew/show/P1829">P1829</a>有异曲同工之妙，杜教筛筛出 $T^2\varphi(T)$ 的前缀和，分块询问答案询问，总时间复杂度$O(n^{\frac{2}{3}})$，杜教筛详见<a href="https://www.luogu.org/blog/Althen-Way-Satan/mu-bi-wu-si-fan-yan-yu-du-jiao-shai">【莫比乌斯反演和杜教筛】</a></p>
<p>$f(x)=x^2\varphi(x)$</p>
<p>$g(x)=x^2\ \ \ ,\sum_{i=1}^{x}g(i)=\frac{x(x+1)(2x+1)}{6}$</p>
<p>$(f<em>g)(x)=x^3\ \ \ ,\sum_{i=1}^{x}(f</em>g)(i)=\frac{x^2(x+1)^2}{4}$</p>
</li>
</ul>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">8000010</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mod,n,inv6,inv4;</span><br><span class="line"><span class="type">int</span> prim[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;f[i]=i<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)&#123;f[i*prim[j]]=f[i]*prim[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">      <span class="keyword">else</span> f[i*prim[j]]=f[i]*(prim[j]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i]=(f[i<span class="number">-1</span>]+<span class="number">1ll</span>*f[i]*i%mod*i%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%mod;a=a*a%mod;b&gt;&gt;=<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Sumfg</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;x%=mod;<span class="keyword">return</span> x*(x+<span class="number">1</span>)%mod*x%mod*(x+<span class="number">1</span>)%mod*inv4%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Sumg</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;x%=mod;<span class="keyword">return</span> x*(x+<span class="number">1</span>)%mod*(x+x+<span class="number">1</span>)%mod*inv6%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Sumf</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=<span class="built_in">min</span>(N<span class="number">-10</span>,(<span class="type">int</span>)n))<span class="keyword">return</span> f[x];</span><br><span class="line">  <span class="keyword">if</span>(mp[x])<span class="keyword">return</span> mp[x];</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ret=<span class="built_in">Sumfg</span>(x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">  	j=x/(x/i);</span><br><span class="line">  	ret=(ret-(<span class="built_in">Sumg</span>(j)-<span class="built_in">Sumg</span>(i<span class="number">-1</span>)+mod)%mod*<span class="built_in">Sumf</span>(x/i)%mod+mod)%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mp[x]=(ret+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mod=<span class="built_in">read</span>();n=<span class="built_in">read</span>();</span><br><span class="line">  inv4=<span class="built_in">power</span>(<span class="number">4</span>,mod<span class="number">-2</span>);</span><br><span class="line">  inv6=<span class="built_in">power</span>(<span class="number">6</span>,mod<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">get_f</span>(<span class="built_in">min</span>(N<span class="number">-10</span>,(<span class="type">int</span>)n));</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">    j=n/(n/i);</span><br><span class="line">    ans=(ans+(<span class="built_in">Sumf</span>(j)-<span class="built_in">Sumf</span>(i<span class="number">-1</span>))%mod*<span class="built_in">Sumfg</span>(n/i)%mod)%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans+mod)%mod);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="P4240-毒瘤之神的考验"><a href="#P4240-毒瘤之神的考验" class="headerlink" title="P4240 毒瘤之神的考验"></a><a href="https://www.luogu.org/problemnew/show/P4240">P4240 毒瘤之神的考验</a></h2><p>$\sum_{i=1}^n\sum_{j=1}^m\varphi(ij)$</p>
<h3 id="反演过程：-8"><a href="#反演过程：-8" class="headerlink" title="反演过程："></a>反演过程：</h3><p>$\sum_{i=1}^n\sum_{j=1}^m\frac{\varphi(i)\varphi(j)gcd(i,j)}{\varphi(gcd(i,j))}$</p>
<p>$\sum_{d=1}^{min(n,m)}\sum_{i=1}^n\sum_{j=1}^m\frac{\varphi(i)\varphi(j)d}{\varphi(d)}[gcd(i,j)=d]$</p>
<p>$\sum_{d=1}^{min(n,m)}\frac{d}{\varphi(d)}\sum_{i=1}^n\sum_{j=1}^m\varphi(i)\varphi(j)[gcd(i,j)=d]$</p>
<p>$\sum_{d=1}^{min(n,m)}\frac{d}{\varphi(d)}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\varphi(di)\varphi(dj)[gcd(i,j)=1]$</p>
<p>$\sum_{d=1}^{min(n,m)}\frac{d}{\varphi(d)}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\varphi(di)\varphi(dj)ϵ(gcd(i,j))$</p>
<p>$\sum_{d=1}^{min(n,m)}\frac{d}{\varphi(d)}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\varphi(di)\varphi(dj)\sum_{k|gcd(i,j)}\mu(k)$</p>
<p>$\sum_{d=1}^{min(n,m)}\frac{d}{\varphi(d)}\sum_{k=1}^{\left\lfloor\frac{min(n,m)}{dk}\right\rfloor}\mu(k)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\varphi(di)\varphi(dj)[k|gcd(i,j)]$</p>
<p>$\sum_{d=1}^{min(n,m)}\frac{d}{\varphi(d)}\sum_{k=1}^{\left\lfloor\frac{min(n,m)}{dk}\right\rfloor}\mu(k)\sum_{i=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{dk}\right\rfloor}\varphi(dik)\varphi(djk)$</p>
<p>$\sum_{T=1}^{min(n,m)}\sum_{i=1}^{\left\lfloor\frac{n}{T}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{T}\right\rfloor}\varphi(iT)\varphi(jT)\sum_{d|T}\frac{d}{\varphi(d)}\mu(\frac{T}{d})$</p>
<ul>
<li>$\ \ \ \ \ \,$ $O(n)$预处理出$\mu$,$\varphi$，$O(n\log n)$预处理出后面的$\sum_{d|T}\frac{d}{\varphi(d)}\mu(\frac{T}{d})$，然后对前面的进行分块操作，会发现要存很多东西，于是我们一边分块，一边操作，总复杂度很玄学，大约是$O(n\log n+nT^{\frac{2}{3}}+T(\sqrt n+\left\lfloor\frac{n}{T^{\frac{1}{3}}}\right\rfloor))$,能过就行了XD,<del>(代码加了信仰fread)</del></li>
</ul>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">15</span>],*S=buf,*TT=buf;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">getch</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> S==TT&amp;&amp;(TT=(S=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">15</span>,stdin),S==TT)?<span class="number">0</span>:*S++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getch</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getch</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getch</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B=<span class="number">35</span>;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],phi[N],mu[N],inv[N];</span><br><span class="line"><span class="type">int</span> F[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],T[B+<span class="number">1</span>][B+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_phi_mu_inv</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>]=mu[<span class="number">1</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])phi[i]=i<span class="number">-1</span>,mu[i]=<span class="number">-1</span>,prim[++prim[<span class="number">0</span>]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>]&amp;&amp;i*prim[j]&lt;=n;j++)&#123;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)&#123;phi[i*prim[j]]=phi[i]*prim[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">      <span class="keyword">else</span> phi[i*prim[j]]=phi[i]*(prim[j]<span class="number">-1</span>),mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">    inv[i]=<span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)</span><br><span class="line">  F[j]=(F[j]+(<span class="number">1ll</span>*mu[j/i]*i*inv[phi[i]]%mod+mod)%mod)%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    G[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n/i;j++)</span><br><span class="line">    G[i].<span class="built_in">push_back</span>((G[i][j<span class="number">-1</span>]+phi[i*j])%mod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=B;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=B;k++)&#123;</span><br><span class="line">    <span class="type">int</span> len=n/<span class="built_in">max</span>(j,k);</span><br><span class="line">    T[j][k].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    T[j][k].<span class="built_in">push_back</span>((T[j][k][i<span class="number">-1</span>]+<span class="number">1ll</span>*F[i]*G[i][j]%mod*G[i][k]%mod)%mod);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ed=m/B;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ed;i++)</span><br><span class="line">  res=(res+<span class="number">1ll</span>*F[i]*G[i][n/i]%mod*G[i][m/i]%mod)%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> l=m/B+<span class="number">1</span>,r,ln,lm;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">  	ln=n/l,lm=m/l;</span><br><span class="line">    r=<span class="built_in">min</span>(n/ln,m/lm);</span><br><span class="line">    res=(res+(T[ln][lm][r]-T[ln][lm][l<span class="number">-1</span>]+mod)%mod)%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">get_phi_mu_inv</span>(<span class="number">100000</span>);<span class="built_in">init</span>(<span class="number">100000</span>);</span><br><span class="line">  <span class="type">int</span> t=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();<span class="keyword">if</span>(n&gt;m)<span class="built_in">swap</span>(n,m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Solve</span>(n,m));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="P1587-NOI2016-循环之美"><a href="#P1587-NOI2016-循环之美" class="headerlink" title="P1587 [NOI2016]循环之美"></a><a href="https://www.luogu.org/problemnew/show/P1587">P1587 [NOI2016]循环之美</a></h2><p>$\ \ \ \ \ \,$对于一个$K$进制下的无限循环小数，在最简形态下，分母一定和$K$互质，所以这道题，就是求:<br>$\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=1][gcd(j,K)=1]$</p>
<h3 id="反演过程：-9"><a href="#反演过程：-9" class="headerlink" title="反演过程："></a>反演过程：</h3><p>$\sum_{j=1}^m[gcd(j,K)=1]\sum_{i=1}^n[gcd(i,j)=1]$</p>
<p>$\sum_{j=1}^m[gcd(j,K)=1]\sum_{i=1}^nϵ(gcd(i,j))$</p>
<p>$\sum_{j=1}^m[gcd(j,K)=1]\sum_{i=1}^n\sum_{k|gcd(i,j)}\mu(k)$</p>
<p>$\sum_{k=1}^{min(n,m)}\mu(k)\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}[gcd(jk,K)=1]$</p>
<p>$\sum_{k=1}^{min(n,m)}\mu(k)[gcd(k,K)=1]\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}[gcd(j,K)=1]$</p>
<p>$\sum_{k=1}^{min(n,m)}\mu(k)[gcd(k,K)=1]\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}[gcd(j,K)=1]\sum_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}$</p>
<p>$\sum_{k=1}^{min(n,m)}\mu(k)[gcd(k,K)=1]\sum_{j=1}^{\left\lfloor\frac{m}{k}\right\rfloor}[gcd(j,K)=1]{\left\lfloor\frac{n}{k}\right\rfloor}$</p>
<p>$f(x,K)=\sum_{i=1}^{x}\mu(i)[gcd(i,K)=1]$</p>
<p>$s(x)=\sum_{i=1}^{x}[gcd(i,K)=1]$</p>
<p>$\sum_{k=1}^{min(n,m)}\mu(k)[gcd(k,K)=1]{\left\lfloor\frac{n}{k}\right\rfloor}s\left(\left\lfloor\frac{m}{k}\right\rfloor\right)$</p>
<p>$\ \ \ \ \ \,$然而还没有完，我们求出$f$和$s$，也就是方便分块操作，现在我们得化简它们:</p>
<ul>
<li><p>$s(x)$<br>$s(x)=\sum_{i=1}^{x}[gcd(i,K)=1]$<br>因为若是 $gcd(a,K)=1$，那么就有 $gcd(a+bk,K)=1$。<br>所以有：<br>$s(x)=\left\lfloor\frac{x}{k}\right\rfloor s(k)+s(x\%k)$<br>所以只需要暴力求出$k$以内的$s$就可以了。</p>
</li>
<li><p>$f(x,K)$</p>
<p>$\sum_{i=1}^{x}\mu(i)[gcd(i,K)=1]$</p>
<p>$\sum_{i=1}^{x}\mu(i)ϵ(gcd(i,K))$</p>
<p>$\sum_{i=1}^{x}\mu(i)\sum_{d|gcd(i,K)}\mu(d)$</p>
<p>$\sum_{d=1}^{min(x,K)}\mu(d)\sum_{i=1}^x\mu(i)[d|gcd(i,K)]$</p>
<p>$\sum_{d=1}^{min(x,K)}\mu(d)\sum_{i=1}^{\left\lfloor\frac{x}{d}\right\rfloor}\mu(id)[d|gcd(id,K)]$</p>
<p>$\sum_{d=1}^{min(x,K)}\mu(d)\sum_{i=1}^{\left\lfloor\frac{x}{d}\right\rfloor}\mu(id)[d|K]$</p>
<p>$\sum_{d|K}\mu(d)\sum_{i=1}^{\left\lfloor\frac{x}{d}\right\rfloor}\mu(id)$</p>
<p>$\sum_{d|K}\mu(d)\sum_{i=1,gcd(i,d)=1}^{\left\lfloor\frac{x}{d}\right\rfloor}\mu(d)\mu(i)$</p>
<p>$\sum_{d|K}\mu(d)^2\sum_{i=1,gcd(i,d)=1}^{\left\lfloor\frac{x}{d}\right\rfloor}\mu(i)$</p>
<p>$\sum_{d|K}\mu(d)^2\sum_{i=1}^{\left\lfloor\frac{x}{d}\right\rfloor}\mu(i)[gcd(i,d)=1]$</p>
<p>$\sum_{d|K}\mu(d)^2f\left({\left\lfloor\frac{x}{d}\right\rfloor},d\right)$</p>
<p>这个怎么办啊？每次递归求解，但是当$K=1$的时候，就没有办法了，我们试一试化一下$K=1$的情况:</p>
<p>$\sum_{i=1}^{x}\mu(i)[gcd(i,1)=1]$</p>
<p>$\sum_{i=1}^{x}\mu(i)$</p>
<p>一个杜教筛就完了。</p>
<p>复杂度大概是$O(n^{\frac{2}{3}})$</p>
</li>
<li><p>感觉题目还是比较难的，反正我一开始是没有想出来，翻了题解，主要是对于$s$的处理，有多加一维描述，还有递归处理，程序的最终复杂度呢，大概就在$O(n^{\frac{2}{3}})$的样子</p>
</li>
</ul>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10000010</span>;</span><br><span class="line"><span class="type">int</span> n,K,m;</span><br><span class="line"><span class="type">int</span> pr[<span class="number">2010</span>];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> prim[N],mu[N],Sum_mu[N];</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt; used;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)pr[i]=pr[i<span class="number">-1</span>]+(<span class="built_in">gcd</span>(i,K)==<span class="number">1</span>);</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;N;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;mu[i]=<span class="number">-1</span>;prim[++prim[<span class="number">0</span>]]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=prim[<span class="number">0</span>];j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i*prim[j]&gt;=N) <span class="keyword">break</span>;</span><br><span class="line">      vis[i*prim[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)&#123;mu[i*prim[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)Sum_mu[i]=Sum_mu[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> pr[x%K]+<span class="number">1ll</span>*(x/K)*pr[K];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!k||!x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;x&lt;N)<span class="keyword">return</span> Sum_mu[x];</span><br><span class="line">  <span class="keyword">if</span>(used[<span class="built_in">make_pair</span>(x,k)])<span class="keyword">return</span> used[<span class="built_in">make_pair</span>(x,k)];</span><br><span class="line">  <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">  	<span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>,r;l&lt;=x;l=r+<span class="number">1</span>)</span><br><span class="line">    r=x/(x/l),ret-=(r-l+<span class="number">1</span>)*<span class="built_in">f</span>(x/l,<span class="number">1</span>);</span><br><span class="line">  	<span class="keyword">return</span> used[<span class="built_in">make_pair</span>(x,k)]=ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=k;i++)<span class="keyword">if</span>(k%i==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(mu[i])ret+=<span class="built_in">f</span>(x/i,i);</span><br><span class="line">    <span class="keyword">if</span>(i*i!=k&amp;&amp;mu[k/i])</span><br><span class="line">    ret+=<span class="built_in">f</span>(x/(k/i),k/i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> used[<span class="built_in">make_pair</span>(x,k)]=ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();K=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="built_in">min</span>(n,m);l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">    ans+=<span class="number">1ll</span>*(<span class="built_in">f</span>(r,K)-<span class="built_in">f</span>(l<span class="number">-1</span>,K))*(n/l)*<span class="built_in">s</span>(m/l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>【SCOI2016】Day1初略题解</title>
    <url>/2019/02/13/SCOI2016-Day1%E5%88%9D%E7%95%A5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \,$做一套省选题来练练手（Day1）。</p>
<span id="more"></span>
<h2 id="【T1-背单词】"><a href="#【T1-背单词】" class="headerlink" title="【T1 背单词】"></a><a href="https://www.luogu.org/problemnew/show/P3294">【T1 背单词】</a></h2><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$ 由题意可以得到，如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 n*n 颗泡椒，这显然是很不合算的。要优先填入后缀。</p>
<p>$\ \ \ \ \ \,$第一个问题是如何找后缀，我们可以把串反过来插入 $Trie$ 树，然后按照$Trie$ 树上的父子关系新建树，按照一种神奇的 $DFS$ 序来依次填入。</p>
<p>$\ \ \ \ \ \,$ 现在的问题是如何处理这个 $DFS$ 序，手玩一点小样例可以发现，优先走子树小的较优，现在我们得到了填入顺序，每个点的填入序号减去他父亲的和，就是我们的答案，复杂度 $O(|len|+3n)$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510010</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],appear[N];</span><br><span class="line"><span class="type">int</span> id[N],cnt2,rt,cnt,n,size[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> size[x]&lt;size[y];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);<span class="type">int</span> now=rt,v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!son[now][s[i]-<span class="string">&#x27;a&#x27;</span>])son[now][s[i]-<span class="string">&#x27;a&#x27;</span>]=++cnt;</span><br><span class="line">		now=son[now][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	appear[now]=id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(appear[rt])&#123;a[fa].<span class="built_in">push_back</span>(appear[rt]);fa=appear[rt];&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)<span class="keyword">if</span>(son[rt][i])</span><br><span class="line">	id[son[rt][i]]=id[rt],<span class="built_in">dfs1</span>(son[rt][i],fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	size[rt]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a[rt].<span class="built_in">size</span>();i++)</span><br><span class="line">	<span class="built_in">dfs2</span>(a[rt][i]),size[rt]+=size[a[rt][i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ans</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	id[rt]=++cnt2;</span><br><span class="line">	<span class="built_in">sort</span>(a[rt].<span class="built_in">begin</span>(),a[rt].<span class="built_in">end</span>(),cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a[rt].<span class="built_in">size</span>();i++)</span><br><span class="line">	ans+=cnt2+<span class="number">1</span>-id[rt],<span class="built_in">get_ans</span>(a[rt][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;word.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;word.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),<span class="built_in">insert</span>(s,i);</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">get_ans</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="【T2-幸运数字】"><a href="#【T2-幸运数字】" class="headerlink" title="【T2 幸运数字】"></a><a href="https://www.luogu.org/problemnew/show/P3292">【T2 幸运数字】</a></h2><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$ 一眼可以看出来是实数异或线性基，不会这个的话就完全不能做这道题的。</p>
<p>$\ \ \ \ \ \,$下面的问题是，如何高效地处理路径问题？</p>
<p>$\ \ \ \ \ \,$我第一个想到的是树链剖分，复杂度为 $O(Q \log^2n)$，算上线性基合并的复杂度 $60\times 60$ 的常数有点吃不消。询问次数很大，我们可以试着多预处理一点。</p>
<p>$\ \ \ \ \ \,$倍增的复杂度为$O(Q \log n)$，加上一些蜜汁卡常数技巧，比如说去掉结构体啊什么的，就过了，空间还算充裕，没有那么卡。代码比较丑：</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> V[N],res;</span><br><span class="line"><span class="type">int</span> head[N],p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> last,v;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	G[++p]=(ss)&#123;head[a],b&#125;;head[a]=p;</span><br><span class="line">	G[++p]=(ss)&#123;head[b],a&#125;;head[b]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lb[N][<span class="number">19</span>][<span class="number">61</span>],ans[<span class="number">61</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a,<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	<span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))</span><br><span class="line">	<span class="keyword">if</span>(!a[i])&#123;a[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">else</span> x^=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">querymax</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">	<span class="keyword">if</span>((res^a[i])&gt;res)res^=a[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a,<span class="type">long</span> <span class="type">long</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++)<span class="keyword">if</span>(b[i])<span class="built_in">insert</span>(a,b[i]);&#125;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">19</span>],deep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	fa[a][<span class="number">0</span>]=f;deep[a]=deep[f]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=head[a];i;i=G[i].last)</span><br><span class="line">	<span class="keyword">if</span>(G[i].v!=f)<span class="built_in">dfs</span>(G[i].v,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">	<span class="keyword">if</span>(deep[a]&gt;deep[b])<span class="built_in">swap</span>(a,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	<span class="keyword">if</span>(deep[a]&lt;=deep[b]-(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">    <span class="built_in">merge</span>(ans,lb[b][i]),b=fa[b][i];</span><br><span class="line">	<span class="keyword">if</span>(a==b)&#123;<span class="built_in">merge</span>(ans,lb[a][<span class="number">0</span>]);<span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(fa[a][i]!=fa[b][i])&#123;</span><br><span class="line">  		<span class="built_in">merge</span>(ans,lb[a][i]),<span class="built_in">merge</span>(ans,lb[b][i]);</span><br><span class="line">    	a=fa[a][i],b=fa[b][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">merge</span>(ans,lb[a][<span class="number">0</span>]),<span class="built_in">merge</span>(ans,lb[b][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">merge</span>(ans,lb[fa[a][<span class="number">0</span>]][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;lucky.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;lucky.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=(<span class="type">int</span>)<span class="built_in">read</span>();m=(<span class="type">int</span>)<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)V[i]=<span class="built_in">read</span>(),<span class="built_in">insert</span>(lb[i][<span class="number">0</span>],V[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)</span><br><span class="line">    a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),<span class="built_in">add</span>(a,b);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">18</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	fa[i][j]=fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">  		<span class="built_in">memcpy</span>(lb[i][j],lb[i][j<span class="number">-1</span>],<span class="built_in">sizeof</span>(lb[i][j<span class="number">-1</span>]));</span><br><span class="line">    	<span class="built_in">merge</span>(lb[i][j],lb[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)&#123;</span><br><span class="line">    	a=(<span class="type">int</span>)<span class="built_in">read</span>();b=(<span class="type">int</span>)<span class="built_in">read</span>();</span><br><span class="line">    	<span class="built_in">query</span>(a,b);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">querymax</span>(ans));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="【T3-萌萌哒】"><a href="#【T3-萌萌哒】" class="headerlink" title="【T3 萌萌哒】"></a><a href="https://www.luogu.org/problemnew/show/P3295">【T3 萌萌哒】</a></h2><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$ 这道题前$30$分做法很显然吧，两段相关联的各个元素，我们可以用并查集并在一起，因为他们必须一定是同一种。最后统计并查集个数就好了，设个数为$cnt$，那么我们的答案是$9\times 10^{cnt-1}$，因为包含第一个数位的只有$1$-$9$，其他可以取$0$-$9$。复杂度$O(n^2)$</p>
<p>$\ \ \ \ \ \,$ 我们可以通过类似于势能分析来操作，来降低复杂度到$O(n\log n)$，操作很骚，一开始没想到，也没有在其他地方见到过。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cnt,n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="number">1ll</span>*a*a%mod)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=<span class="number">1ll</span>*a*ans%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">20</span>][N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inv(x) power(x,mod-2)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> f[k][x]==x?x:f[k][x]=<span class="built_in">find</span>(k,f[k][x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">log_2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ret=<span class="number">0</span>;x;x&gt;&gt;=<span class="number">1</span>,ret++);</span><br><span class="line">	<span class="keyword">return</span> ret<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> xx,<span class="type">int</span> yy)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> r1=<span class="built_in">find</span>(k,xx),r2=<span class="built_in">find</span>(k,yy);</span><br><span class="line">	<span class="keyword">if</span>(r1==r2) <span class="keyword">return</span>;</span><br><span class="line">	f[k][r1]=r2;</span><br><span class="line">	<span class="keyword">if</span>(!k)&#123;cnt--;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">solve</span>(k<span class="number">-1</span>,xx,yy);</span><br><span class="line">	<span class="built_in">solve</span>(k<span class="number">-1</span>,xx+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>),yy+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;moe.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;moe.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	cnt=n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">18</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	f[i][j]=j;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l1=<span class="built_in">read</span>(),r1=<span class="built_in">read</span>(),l2=<span class="built_in">read</span>(),r2=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(l1&gt;l2) <span class="built_in">swap</span>(l1,l2),<span class="built_in">swap</span>(r1,r2);</span><br><span class="line">		<span class="type">int</span> t=<span class="built_in">log_2</span>(r1-l1+<span class="number">1</span>);</span><br><span class="line">    	<span class="built_in">solve</span>(t,l1,l2);</span><br><span class="line">    	<span class="built_in">solve</span>(t,r1-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>,r2-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">9ll</span>*<span class="built_in">power</span>(<span class="number">10</span>,cnt<span class="number">-1</span>)%mod);</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>异或</tag>
        <tag>Trie树</tag>
        <tag>数据结构</tag>
        <tag>线性基</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
