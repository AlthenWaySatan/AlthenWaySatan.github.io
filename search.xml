<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【CF487E】 Tourists 简易题解</title>
    <url>/2019/03/20/CF487E-Tourists-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/CF487E">【CF487E】 Tourists</a></p>
<span id="more"></span>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>$\ \ \ \ \ \ \,$ 给你 $n$ 个点和 $m$条边的无向图，没有自环，没有重边，每个点上面有点权。</p>
<p>$\ \ \ \ \ \ \,$ 每次可能有两种操作：修改一个点的点权，或者询问两个点之间的路径上最小可能的点权是多少。</p>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>$\ \ \ \ \ \ \,$有一个很显然的贪心想法，询问的时候肯定优先走较小权值路径，也就是在有分叉（点双）的时候走较小权值的那一侧，而只有可能最小的会造成贡献。</p>
<p>$\ \ \ \ \ \ \,$所以说我们可以尝试将每个点双之间建一个堆，记录最小的点权。</p>
<p>$\ \ \ \ \ \ \,$也就是建出一棵圆方树，方点上面一个堆，记录与他向连的圆点的权值最小值。</p>
<p>$\ \ \ \ \ \ \,$每次询问就只需要考虑经过唯一路径上面 <strong>圆点点权</strong> 和 <strong>方点堆顶</strong> 的最小值就行了，这个可以用树链剖分搞。</p>
<p>$\ \ \ \ \ \ \,$然后考虑修改，便是修改与这个 <strong>圆点</strong> 相连的方点上面的堆就好了，删除原来的点权，加入新点权。但是这样子我们不能保证其复杂度，要是圆方树建成一个菊花图就会 $T$ 飞了。</p>
<p>$\ \ \ \ \ \ \,$我们再考虑一下，我们树链剖分往上跳的时候，其实已经计算过  <strong>走过的方点</strong> 的父亲了（圆点），会有计算重复的地方。所以说 <strong>方点的堆</strong> 里面不需要记录其父亲的权值，换句话说，对于一个圆点，他的值只需要被他的 <strong>方点父亲</strong> 的堆记录，这样子每次修改，只需要修改他父亲的，加上线段树和堆的复杂度也不过一次 $O(\log n)$。</p>
<p>$\ \ \ \ \ \ \,$但是每次询问的是两个圆点，其$LCA$有可能是方点，这个时候少计算了一个 <strong>方点$LCA$</strong> 的父亲，需要注意加入判断一下。<del>（第一个样第一次例询问输出为2有可能就是这样死的）</del></p>
<p>$\ \ \ \ \ \ \,$然后就是 <strong>圆方树+树链剖分+线段树+可删堆</strong> 套模板了，可删堆我是用 $fhq_Treap$ 实现的，所以说代码比较丑。</p>
<p>$\ \ \ \ \ \ \,$预处理复杂度$O(n\log n)$，修改操作复杂度$O(\log n)$，询问操作复杂度$O(\log^2 n)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">200</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],E[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_E</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;E[x].<span class="built_in">push_back</span>(y);E[y].<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_G</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;G[x].<span class="built_in">push_back</span>(y);G[y].<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"><span class="type">int</span> sta[N],top,Size;</span><br><span class="line"><span class="type">int</span> tim,dfn[N],low[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  	dfn[u]=low[u]=++tim;</span><br><span class="line">  	sta[++top]=u;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])&#123;</span><br><span class="line">    	<span class="keyword">if</span>(dfn[v]) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    	<span class="keyword">else</span>&#123;</span><br><span class="line">      		<span class="built_in">tarjan</span>(v),low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">      		<span class="keyword">if</span>(low[v]&gt;=dfn[u])&#123;</span><br><span class="line">        		++Size;<span class="type">int</span> p;</span><br><span class="line">        		<span class="keyword">while</span>((p=sta[top])!=v)<span class="built_in">add_G</span>(p,Size),top--;</span><br><span class="line">        		p=sta[top],<span class="built_in">add_G</span>(p,Size),top--;</span><br><span class="line">        		<span class="built_in">add_G</span>(u,Size);</span><br><span class="line">      		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> ls,rs,key,size,val;&#125;T[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson T[rt].ls</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson T[rt].rs</span></span><br><span class="line"><span class="type">int</span> node_cnt;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;Rub;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> rt;</span><br><span class="line">	<span class="keyword">if</span>(!Rub.<span class="built_in">empty</span>())rt=Rub.<span class="built_in">front</span>(),Rub.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">else</span> rt=++node_cnt;</span><br><span class="line">	lson=rson=<span class="number">0</span>;</span><br><span class="line">	T[rt].key=<span class="built_in">rand</span>();T[rt].val=x;T[rt].size=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_Treap</span>&#123;</span><br><span class="line">	<span class="type">int</span> root;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;T[rt].size=T[lson].size+T[rson].size+<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!a||!b)<span class="keyword">return</span> a|b;</span><br><span class="line">		<span class="keyword">if</span>(T[a].key&lt;T[b].key)&#123;T[a].rs=<span class="built_in">merge</span>(T[a].rs,b);<span class="built_in">pushup</span>(a);<span class="keyword">return</span> a;&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;T[b].ls=<span class="built_in">merge</span>(a,T[b].ls);<span class="built_in">pushup</span>(b);<span class="keyword">return</span> b;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!rt)&#123;a=b=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(T[rt].val&lt;=x)&#123;a=rt;<span class="built_in">split</span>(rson,x,rson,b);&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;b=rt;<span class="built_in">split</span>(lson,x,a,lson);&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">		<span class="type">int</span> rt=<span class="built_in">newnode</span>(x);</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,rt),b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">split</span>(root,x,a,c);</span><br><span class="line">		<span class="built_in">split</span>(a,x<span class="number">-1</span>,a,b);</span><br><span class="line">		b=<span class="built_in">merge</span>(T[b].ls,T[b].rs);</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Min</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> rt=root;</span><br><span class="line">		<span class="keyword">while</span>(lson)rt=lson;</span><br><span class="line">		<span class="keyword">return</span> T[rt].val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Treap[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos[N],w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment_Tree</span>&#123;</span><br><span class="line">  	<span class="meta">#<span class="keyword">define</span> Lson l,mid,rt&lt;&lt;1</span></span><br><span class="line">  	<span class="meta">#<span class="keyword">define</span> Rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line">  	<span class="type">int</span> sum[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;sum[rt]=<span class="built_in">min</span>(sum[rt&lt;&lt;<span class="number">1</span>],sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">if</span>(l==r)&#123;sum[rt]=w[pos[l]];<span class="keyword">return</span>;&#125;</span><br><span class="line">  		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  		<span class="built_in">build</span>(Lson);<span class="built_in">build</span>(Rson);</span><br><span class="line">  		<span class="built_in">pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> c,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(l==r)&#123;sum[rt]=c;<span class="keyword">return</span>;&#125;</span><br><span class="line">    	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(id&lt;=mid)<span class="built_in">Update</span>(id,c,Lson);</span><br><span class="line">    	<span class="keyword">else</span> <span class="built_in">Update</span>(id,c,Rson);</span><br><span class="line">		<span class="built_in">pushup</span>(rt);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)<span class="keyword">return</span> sum[rt];</span><br><span class="line">    	<span class="type">int</span> ret=<span class="number">1e9</span>,mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(L&lt;=mid)ret=<span class="built_in">min</span>(ret,<span class="built_in">Query</span>(L,R,Lson));</span><br><span class="line">    	<span class="keyword">if</span>(R&gt;mid)ret=<span class="built_in">min</span>(ret,<span class="built_in">Query</span>(L,R,Rson));</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;Seg;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree_Chain_Dissection</span>&#123;</span><br><span class="line">	<span class="type">int</span> idx[N];</span><br><span class="line">	<span class="type">int</span> deep[N],fa[N],son[N],size[N];</span><br><span class="line">	<span class="type">int</span> cnt,top[N];</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">		deep[u]=dep;fa[u]=f;size[u]=<span class="number">1</span>;</span><br><span class="line">		Treap[fa[u]].<span class="built_in">Insert</span>(w[u]);</span><br><span class="line">		<span class="type">int</span> maxson=<span class="number">-1</span>;</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])<span class="keyword">if</span>(v!=f)&#123;</span><br><span class="line">		  	size[u]+=<span class="built_in">dfs1</span>(v,u,dep+<span class="number">1</span>);</span><br><span class="line">		  	<span class="keyword">if</span>(size[v]&gt;maxson)maxson=size[v],son[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> size[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">		idx[u]=++cnt;top[u]=topf;</span><br><span class="line">		pos[cnt]=u;</span><br><span class="line">		<span class="keyword">if</span>(!son[u])<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])<span class="keyword">if</span>(!idx[v])<span class="built_in">dfs2</span>(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=Size;++i)w[i]=Treap[i].<span class="built_in">Min</span>();</span><br><span class="line">		Seg.<span class="built_in">build</span>(<span class="number">1</span>,Size,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">if</span>(fa[u])&#123;</span><br><span class="line">	    	Treap[fa[u]].<span class="built_in">Delete</span>(w[u]);</span><br><span class="line">	    	Treap[fa[u]].<span class="built_in">Insert</span>(val);</span><br><span class="line">	    	Seg.<span class="built_in">Update</span>(idx[fa[u]],Treap[fa[u]].<span class="built_in">Min</span>(),<span class="number">1</span>,Size,<span class="number">1</span>);</span><br><span class="line">	  	&#125;</span><br><span class="line">	  	w[u]=val;</span><br><span class="line">		Seg.<span class="built_in">Update</span>(idx[u],val,<span class="number">1</span>,Size,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	  	<span class="type">int</span> ans=inf;</span><br><span class="line">	  	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">	    	<span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">	    	ans=<span class="built_in">min</span>(ans,Seg.<span class="built_in">Query</span>(idx[top[x]],idx[x],<span class="number">1</span>,Size,<span class="number">1</span>));</span><br><span class="line">	    	x=fa[top[x]];</span><br><span class="line">	  	&#125;</span><br><span class="line">	 	<span class="keyword">if</span>(deep[x]&gt;deep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">	  	ans=<span class="built_in">min</span>(ans,Seg.<span class="built_in">Query</span>(idx[x],idx[y],<span class="number">1</span>,Size,<span class="number">1</span>));</span><br><span class="line">    	<span class="keyword">if</span>(x&lt;=n)<span class="keyword">return</span> ans;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(ans,w[fa[x]]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;TCD;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	Size=n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();Q=<span class="built_in">read</span>();w[<span class="number">0</span>]=inf;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">read</span>();</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;++i)</span><br><span class="line">	a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),<span class="built_in">add_E</span>(a,b);</span><br><span class="line">  	<span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">  	TCD.<span class="built_in">init</span>();</span><br><span class="line">  	<span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();</span><br><span class="line">    	<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)TCD.<span class="built_in">Update</span>(a,b);</span><br><span class="line">    	<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,TCD.<span class="built_in">Query</span>(a,b));</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>图论</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title>【CF438E】 The Child and Binary Tree 简易题解</title>
    <url>/2019/02/23/CF438E-The-Child-and-Binary-Tree-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/CF438E">【CF438E】 The Child and Binary Tree</a></p>
<span id="more"></span>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>$\ \ \ \ \ \ \,$给你 $n$ 和 $m$，和大小为 $n$ 的集合 $C$。</p>
<p>$\ \ \ \ \ \ \,$需要你统计点权在集合 $C$ 内，且点权之和分别为 $[1,m]$ 的二叉树个数。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>$\ \ \ \ \ \ \,$根据题目，我们可以想到$DP$公式求解：</p>
<p>$<br> f(n)=<br> \begin{cases}<br> 1, &amp; \text {$(n=0)$} \\<br>\sum_{i=1}^{n}g(i)\sum_{j=0}^{n-i}f(j)\cdot f(n-i-j), &amp; \text{$(n &gt; 0)$}<br>  \end{cases}<br> $</p>
<p>$\ \ \ \ \ \ \,$其中：</p>
<ul>
<li>$f(i)$意思是且点权之和 $i$ 的二叉树个数。</li>
<li>$g(i)$意思是集合 $C$ 中是否含有元素 $i$，既 $g(i)=[i\in C]$ 。</li>
</ul>
<p>$\ \ \ \ \ \ \,$怎么得到这个公式的就不说了，还是比较显然的 <del>（雾</del> 。但是很明显复杂度过不去。我们把它们写成生成函数会好一些 <del>（计数题套路？）</del>：</p>
<p>$\ \ \ \ \ \ \,$令函数 $F$ 为序列 $f(x)$ 的生成函数，函数 $G$ 为序列 $g(x)$的生成函数。</p>
<p>$\ \ \ \ \ \ \,$可以得到：</p>
<p>$F=G*F^2+1$</p>
<p>$\ \ \ \ \ \ \,$解得：</p>
<p>$F=\frac{2}{1\pm\sqrt{1-4G}}$</p>
<p>$\ \ \ \ \ \ \,$那么是加号还是减号啊？已知$F_0=1$。而题目保证 $(1\leq c_i \leq 10^5)$，所以有$G_0=0$。那么带入可以得到应该是取加号。</p>
<p>$\ \ \ \ \ \ \,$所以说只需要求出多项式$\frac{2}{1+\sqrt{1-4G}}$的$[1,m]$项就好了。</p>
<p>$\ \ \ \ \ \ \,$格式挺清新的，需要求逆和开根，模板直接往上套就好了呢：<a href="https://blog.csdn.net/weixin_43973966/article/details/87864851">【多项式的操作大赏】</a>。我写的开根比较麻烦，还要写 $\ln$ 和 $\exp$，然后 $\ln$ 还要写求积分和求导。所以说……基本上……所有模板都用到了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>,mod_g=<span class="number">3</span>,N=<span class="number">1600000</span>;</span><br><span class="line"><span class="type">int</span> R[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="number">1ll</span>*a*a%mod)</span><br><span class="line">	<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=<span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">  	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Inv(x) power(x,mod-2)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Polynomial_init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len;<span class="keyword">for</span>(len=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> f,<span class="type">int</span> la)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=la;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;R[i])<span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="type">int</span> gn=<span class="built_in">power</span>(mod_g,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">      		<span class="type">int</span> g=<span class="number">1</span>;</span><br><span class="line">      		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++,g=<span class="number">1ll</span>*g*gn%mod)&#123;</span><br><span class="line">	        	<span class="type">int</span> x=a[j+k],y=<span class="number">1ll</span>*g*a[i+j+k]%mod;</span><br><span class="line">	        	a[j+k]=(x+y)%mod;a[i+j+k]=(x-y+mod)%mod;</span><br><span class="line">	      	&#125;</span><br><span class="line">    	&#125; </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span>(f==<span class="number">-1</span>)&#123;</span><br><span class="line">   		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    	<span class="type">int</span> inv=<span class="built_in">Inv</span>(n);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)a[i]=<span class="number">1ll</span>*a[i]*inv%mod;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Convolution</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> la,<span class="type">int</span> lb)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=la,m=lb;</span><br><span class="line">	<span class="type">int</span> L=<span class="number">0</span>;<span class="keyword">for</span>(m+=n,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>)L++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">1</span>,n);<span class="built_in">NTT</span>(b,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">-1</span>,n);</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> C[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inverse</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(len==<span class="number">1</span>)&#123;b[<span class="number">0</span>]=<span class="built_in">Inv</span>(a[<span class="number">0</span>]);<span class="keyword">return</span>;&#125;</span><br><span class="line">  	<span class="built_in">Inverse</span>(a,b,(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  	<span class="type">int</span> L=<span class="number">0</span>,n=<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(;n&lt;(len&lt;&lt;<span class="number">1</span>);n&lt;&lt;=<span class="number">1</span>)L++;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)C[i]=a[i];</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;n;i++)C[i]=<span class="number">0</span>;</span><br><span class="line">  	<span class="built_in">NTT</span>(C,<span class="number">1</span>,n);<span class="built_in">NTT</span>(b,<span class="number">1</span>,n);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)b[i]=<span class="number">1ll</span>*(<span class="number">2ll</span><span class="number">-1ll</span>*C[i]*b[i]%mod+mod)%mod*b[i]%mod;</span><br><span class="line">  	<span class="built_in">NTT</span>(b,<span class="number">-1</span>,n);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;n;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derivation</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">  	b[i<span class="number">-1</span>]=<span class="number">1ll</span>*i*a[i]%mod;</span><br><span class="line">	b[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Integral</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">  	b[i]=<span class="number">1ll</span>*<span class="built_in">Inv</span>(i)*a[i<span class="number">-1</span>]%mod;</span><br><span class="line">	b[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A[N],B[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logarithmic</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="built_in">sizeof</span>(A));</span><br><span class="line">	<span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="built_in">sizeof</span>(B));</span><br><span class="line">  	<span class="built_in">Derivation</span>(a,A,len);</span><br><span class="line">  	<span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="built_in">sizeof</span>(C));</span><br><span class="line">  	<span class="built_in">Inverse</span>(a,B,len);</span><br><span class="line">  	<span class="built_in">Convolution</span>(A,B,len,len);</span><br><span class="line">  	<span class="built_in">Integral</span>(A,b,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> D[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exponential</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(len==<span class="number">1</span>)&#123;b[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">  	<span class="built_in">Exponential</span>(a,b,len&gt;&gt;<span class="number">1</span>),<span class="built_in">Logarithmic</span>(b,D,len);</span><br><span class="line">  	D[<span class="number">0</span>]=(<span class="number">1ll</span>*a[<span class="number">0</span>]+<span class="number">1ll</span>-D[<span class="number">0</span>]+mod)%mod;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;++i) D[i]=(<span class="number">1ll</span>*a[i]-D[i]+mod)%mod;</span><br><span class="line">  	<span class="built_in">Convolution</span>(b,D,len&lt;&lt;<span class="number">1</span>,len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;(len&lt;&lt;<span class="number">1</span>);++i) b[i]=D[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> E[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kth_root</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="built_in">Logarithmic</span>(a,E,len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)E[i]=<span class="number">499122177ll</span>*E[i]%mod;</span><br><span class="line">	<span class="built_in">Exponential</span>(E,b,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,F[N],G[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)++G[<span class="built_in">read</span>()];</span><br><span class="line">  	<span class="type">int</span> len=<span class="built_in">Polynomial_init</span>(m);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)G[i]=(mod-(<span class="number">4ll</span>*G[i]%mod))%mod;</span><br><span class="line">  	++G[<span class="number">0</span>];</span><br><span class="line">  	<span class="built_in">Kth_root</span>(G,F,len,<span class="number">2</span>);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)G[i]=<span class="number">0</span>;</span><br><span class="line">  	F[<span class="number">0</span>]=(F[<span class="number">0</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">  	<span class="built_in">Inverse</span>(F,G,len);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;++i)G[i]=(<span class="number">2ll</span>*G[i])%mod;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,G[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>DP</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>FhqTreap各种操作模板大赏</title>
    <url>/2019/01/06/FhqTreap%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%E5%A4%A7%E8%B5%8F/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于Splay操作的复习笔记：</p>
<p>$\ \ \ \ \ \ \ \,$一些平衡树操作和都是一样的，详见<a href="/2019/01/05/Splay各种操作模板大赏/">【Splay各种操作模板大赏】</a>。</p>
<span id="more"></span>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_Treap</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">  	<span class="type">int</span> size[N],key[N],sum[N],val[N];</span><br><span class="line">  	<span class="type">int</span> ls[N],rs[N],cnt;</span><br><span class="line">  	<span class="type">int</span> root;</span><br><span class="line">  	<span class="type">bool</span> lazy[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>$\tt root$ ：根；</li>
<li>$\tt cnt$ ：下标大小；</li>
<li>$\tt key[]$ ：关键值；</li>
<li>$\tt ls[]\&amp;rs[]$ ：左右儿子；</li>
<li>$\tt sum[]$ ：子树权值；</li>
<li>$\tt val[]$ ：节点权值；</li>
<li>$\tt size[]$ ：节点大小；</li>
<li>$\tt lazy[]$ ：下传标记。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>手写随机($Rand$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> seed=<span class="number">233</span>;</span><br><span class="line">    <span class="keyword">return</span> seed=<span class="built_in">int</span>(seed*<span class="number">48271LL</span>%<span class="number">20020207</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>标记上传 ($pushup$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">	sum[rt]=sum[lson]+sum[rson]+val[rt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>标记下传 ($pushdown$)，根据情况会不一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(lson,rson);</span><br><span class="line">    lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">    lazy[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分裂($split$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//权值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      	<span class="keyword">if</span>(val[rt]&lt;=x)a=rt,<span class="built_in">split</span>(rson,x,rs[a],b);</span><br><span class="line">      	<span class="keyword">else</span> b=rt,<span class="built_in">split</span>(lson,x,a,ls[b]);</span><br><span class="line">      	<span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(size[ls[rt]]&lt;x)a=rt,<span class="built_in">split</span>(rson,x-size[ls[rt]]<span class="number">-1</span>,rs[a],b);</span><br><span class="line">      	<span class="keyword">else</span> b=rt,<span class="built_in">split</span>(lson,x,a,ls[b]);</span><br><span class="line">      	<span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>合并($merge$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(key[x]&lt;key[y])&#123;<span class="built_in">pushdown</span>(x);rs[x]=<span class="built_in">merge</span>(rs[x],y);<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">pushdown</span>(y);ls[y]=<span class="built_in">merge</span>(x,ls[y]);<span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li>新建节点 ($newnode$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  	sum[++cnt]=val[cnt]=v;size[cnt]=<span class="number">1</span>;key[cnt]=<span class="built_in">Rand</span>();</span><br><span class="line">  	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>插入($Insert$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">    <span class="type">int</span> rt=<span class="built_in">newnode</span>(v);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,rt),b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除($Delete$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);<span class="built_in">split</span>(a,x<span class="number">-1</span>,a,c);</span><br><span class="line">    c=<span class="built_in">merge</span>(ls[c],rs[c]);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,c),b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>区间修改（翻转）($revse$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    lazy[y]^=<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h2><ul>
<li><p>查找排名第k的值($QueryRank$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueryRank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(x==size[lson]+<span class="number">1</span>)<span class="keyword">return</span> val[rt];</span><br><span class="line">      	<span class="keyword">if</span>(size[lson]&gt;=x)rt=lson;</span><br><span class="line">      	<span class="keyword">else</span> x-=size[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找某个值的排名($Rank$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]&gt;=x)rt=lson;</span><br><span class="line">    	<span class="keyword">else</span> res+=size[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>前驱($Numpre$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Numpre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">QueryRank</span>(<span class="built_in">Rank</span>(x)<span class="number">-1</span>);&#125;</span><br></pre></td></tr></table></figure></li>
<li>后继($Numnex$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Numnex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">QueryRank</span>(<span class="built_in">Rank</span>(x+<span class="number">1</span>));&#125;</span><br></pre></td></tr></table></figure></li>
<li>区间查询（权值和）($Numnex$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=sum[y];</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="两个模板题："><a href="#两个模板题：" class="headerlink" title="两个模板题："></a>两个模板题：</h2><ul>
<li><a href="https://www.luogu.org/problemnew/show/P3369">P3369 【模板】普通平衡树</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_Treap</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Rand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> seed=<span class="number">233</span>;</span><br><span class="line">    <span class="keyword">return</span> seed=<span class="built_in">int</span>(seed*<span class="number">48271LL</span>%<span class="number">20020207</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> size[N],key[N],val[N];</span><br><span class="line">  <span class="type">int</span> ls[N],rs[N],cnt,sum[N];</span><br><span class="line">  <span class="type">int</span> root;</span><br><span class="line">  <span class="type">bool</span> lazy[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">        sum[rt]=sum[lson]+sum[rson]+val[rt];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  	++cnt;</span><br><span class="line">    size[cnt]=size[b];key[cnt]=key[b];val[cnt]=val[b];</span><br><span class="line">    ls[cnt]=ls[b];rs[cnt]=rs[b],lazy[cnt]=lazy[b];sum[cnt]=sum[b];</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(lson,rson);</span><br><span class="line">    lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">    lazy[rt]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(key[x]&lt;key[y])&#123;<span class="built_in">pushdown</span>(x);rs[x]=<span class="built_in">merge</span>(rs[x],y);<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">pushdown</span>(y);ls[y]=<span class="built_in">merge</span>(x,ls[y]);<span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//权值</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      <span class="keyword">if</span>(val[rt]&lt;=x)a=rt,<span class="built_in">split</span>(rson,x,rs[a],b);</span><br><span class="line">      <span class="keyword">else</span> b=rt,<span class="built_in">split</span>(lson,x,a,ls[b]);</span><br><span class="line">      <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">    val[++cnt]=x;size[cnt]=<span class="number">1</span>;key[cnt]=<span class="built_in">Rand</span>();</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,cnt),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);<span class="built_in">split</span>(a,x<span class="number">-1</span>,a,c);</span><br><span class="line">    c=<span class="built_in">merge</span>(ls[c],rs[c]);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,c),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Rank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]&gt;=x)rt=lson;</span><br><span class="line">    	<span class="keyword">else</span> res+=size[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QueryRank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x==size[lson]+<span class="number">1</span>)<span class="keyword">return</span> val[rt];</span><br><span class="line">      <span class="keyword">if</span>(size[lson]&gt;=x)rt=lson;</span><br><span class="line">      <span class="keyword">else</span> x-=size[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Numpre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">QueryRank</span>(<span class="built_in">Rank</span>(x)<span class="number">-1</span>);&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Numnex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">QueryRank</span>(<span class="built_in">Rank</span>(x+<span class="number">1</span>));&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    lazy[y]^=<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=sum[y];</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Fhq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    <span class="type">int</span> opt=<span class="built_in">read</span>(),x=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;Fhq.<span class="built_in">Insert</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;Fhq.<span class="built_in">Delete</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Fhq.<span class="built_in">Rank</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">4</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Fhq.<span class="built_in">QueryRank</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">5</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Fhq.<span class="built_in">Numpre</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">6</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Fhq.<span class="built_in">Numnex</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://www.luogu.org/problemnew/show/P3391">P3391 【模板】文艺平衡树（Splay）</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_Treap</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Rand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> seed=<span class="number">233</span>;</span><br><span class="line">    <span class="keyword">return</span> seed=<span class="built_in">int</span>(seed*<span class="number">48271LL</span>%<span class="number">20020207</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> size[N],key[N],val[N],w[N];</span><br><span class="line">  <span class="type">int</span> ls[N],rs[N],cnt;</span><br><span class="line">  <span class="type">int</span> root;</span><br><span class="line">  <span class="type">bool</span> lazy[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(lson,rson);</span><br><span class="line">    lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">    lazy[rt]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(key[x]&lt;key[y])&#123;<span class="built_in">pushdown</span>(x);rs[x]=<span class="built_in">merge</span>(rs[x],y);<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">pushdown</span>(y);ls[y]=<span class="built_in">merge</span>(x,ls[y]);<span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//位置</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(size[ls[rt]]&lt;x)a=rt,<span class="built_in">split</span>(rson,x-size[ls[rt]]<span class="number">-1</span>,rs[a],b);</span><br><span class="line">      <span class="keyword">else</span> b=rt,<span class="built_in">split</span>(lson,x,a,ls[b]);</span><br><span class="line">      <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);++cnt;</span><br><span class="line">    val[cnt]=v;size[cnt]=<span class="number">1</span>;key[cnt]=<span class="built_in">Rand</span>();</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,cnt),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,r,x,z);</span><br><span class="line">    <span class="built_in">split</span>(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">    lazy[y]^=<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Fhq;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  Fhq.<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  <span class="keyword">if</span>(Fhq.lson)<span class="built_in">write</span>(Fhq.lson);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Fhq.val[rt]);</span><br><span class="line">  <span class="keyword">if</span>(Fhq.rson)<span class="built_in">write</span>(Fhq.rson); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)Fhq.<span class="built_in">Insert</span>(i<span class="number">-1</span>,i);</span><br><span class="line"> 	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">  	Fhq.<span class="built_in">Reverse</span>(l,r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write</span>(Fhq.root);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Fhq_Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>【CF888G】 Xor-MST 简易题解</title>
    <url>/2019/02/26/CF888G-Xor-MST-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/CF888G">【CF888G】 Xor-MST</a></p>
<span id="more"></span>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>$\ \ \ \ \ \ \,$给你一个 $n$ 个节点的完全图，第 $i$ 个点的权值为 $a_i$ ，两点的之间边权为这两个点权值的异或值，求最小生成树的权值。</p>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>$\ \ \ \ \ \ \,$其实这道题没有那么复杂，还是好想的。</p>
<p>$\ \ \ \ \ \ \,$最小生成树的话，我们显然有一个基于贪心的$Kruskal$ 算法，复杂度 $O(n^2\log n)$，想想还是算了吧。</p>
<p>$\ \ \ \ \ \ \,$而遇到关于异或的题呢，我们一般会有两种想法：整形异或线性基，$Trie$ 树。</p>
<p>$\ \ \ \ \ \ \,$容易想到的，这道题当然和线性基没有关系了，我们思考一下 $Trie$ 树，首先，我们先把第一个样例从高位到低位插入线性基看看：</p>
<p><img src="https://img-blog.csdnimg.cn/20190226084314824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3Mzk2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>$\ \ \ \ \ \ \,$容易发现，对于每个叶子节点，既每个点值之间，要是需要互相连边，那么求 <strong>他们 $Lca$ 以后的边的亦或值</strong> 即可。</p>
<p>$\ \ \ \ \ \ \,$由此可得，若是 $Lca$ 的深度越深，便约优。因为我们是从高位到低位插入的，所以浅的点权值较大，要尽量避免选择浅的点。</p>
<p>$\ \ \ \ \ \ \,$我们不妨把可能是 $Lca$ 的点拉出来瞅瞅：</p>
<p><img src="https://img-blog.csdnimg.cn/20190226085043371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3Mzk2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>$\ \ \ \ \ \ \,$惊喜地发现，刚好有 $4$ 个点，也就是所有拥有两个儿子的点一共有 $4$ 个，可以证明，如果 $a_i$ 两两不等的话，那么这种点一共有 $n-1$ 个，那么答案就呼之欲出了：</p>
<p>$\ \ \ \ \ \ \,$我们每找到这样的点，就暴力贪心 $DFS$ 下去：</p>
<ul>
<li>每次尽量同时走左儿子或右儿子；</li>
<li>如果两个都有，就两个都走，然后返回值取 $min$ 。</li>
<li>如果两个只有不一样的儿子，就在返回值加上这一深度$bit$的值，然后继续走</li>
</ul>
<p>$\ \ \ \ \ \ \,$最终答案就是他们的 $DFS$ 值的和。</p>
<p>$\ \ \ \ \ \ \,$那如果 $a_i$ 不是两两不等的话怎么办呢，如果 $a_u=a_v$ 的话，我们当然首先建一条边连接 $u$，$v$，权值为 $0$，对答案完全没有影响，所以我们正常建，正常搜，是不会有问题的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">2</span>][<span class="number">200000</span>*<span class="number">30</span>+<span class="number">10</span>],tot;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> now=<span class="number">0</span>,id;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">	    	id=(a&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">	    	<span class="keyword">if</span>(!son[id][now])son[id][now]=++tot;</span><br><span class="line">	    	now=son[id][now];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> r1,<span class="type">int</span> r2,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> a1=<span class="number">-1</span>,a2=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(son[<span class="number">0</span>][r1]&amp;&amp;son[<span class="number">0</span>][r2]) a1=<span class="built_in">Find</span>(son[<span class="number">0</span>][r1],son[<span class="number">0</span>][r2],b<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(son[<span class="number">1</span>][r1]&amp;&amp;son[<span class="number">1</span>][r2]) a2=<span class="built_in">Find</span>(son[<span class="number">1</span>][r1],son[<span class="number">1</span>][r2],b<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(~a1&amp;&amp;~a2) <span class="keyword">return</span> <span class="built_in">min</span>(a1,a2);</span><br><span class="line">		<span class="keyword">if</span>(~a1) <span class="keyword">return</span> a1;<span class="keyword">if</span>(~a2) <span class="keyword">return</span> a2;</span><br><span class="line">		<span class="keyword">if</span>(son[<span class="number">1</span>][r1]&amp;&amp;son[<span class="number">0</span>][r2]) a1=<span class="built_in">Find</span>(son[<span class="number">1</span>][r1],son[<span class="number">0</span>][r2],b<span class="number">-1</span>)+(<span class="number">1</span>&lt;&lt;b);</span><br><span class="line">		<span class="keyword">if</span>(son[<span class="number">0</span>][r1]&amp;&amp;son[<span class="number">1</span>][r2]) a2=<span class="built_in">Find</span>(son[<span class="number">0</span>][r1],son[<span class="number">1</span>][r2],b<span class="number">-1</span>)+(<span class="number">1</span>&lt;&lt;b);</span><br><span class="line">		<span class="keyword">if</span>(~a1&amp;&amp;~a2) <span class="keyword">return</span> <span class="built_in">min</span>(a1,a2);</span><br><span class="line">		<span class="keyword">if</span>(~a1) <span class="keyword">return</span> a1;<span class="keyword">if</span>(~a2) <span class="keyword">return</span> a2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(T.son[<span class="number">0</span>][a]&amp;&amp;T.son[<span class="number">1</span>][a]) ans+=<span class="number">1ll</span>*T.<span class="built_in">Find</span>(T.son[<span class="number">0</span>][a],T.son[<span class="number">1</span>][a],b<span class="number">-1</span>)+(<span class="number">1ll</span>&lt;&lt;b);</span><br><span class="line">	<span class="keyword">if</span>(T.son[<span class="number">0</span>][a]) <span class="built_in">dfs</span>(T.son[<span class="number">0</span>][a],b<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(T.son[<span class="number">1</span>][a]) <span class="built_in">dfs</span>(T.son[<span class="number">1</span>][a],b<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)T.<span class="built_in">Insert</span>(<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>异或</tag>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2016]生成魔咒 简易题解</title>
    <url>/2019/03/12/SDOI2016-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P4070">[SDOI2016]生成魔咒</a></p>
<span id="more"></span>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>$\ \ \ \ \ \ \,$一看这个题目：</p>
<ul>
<li>只是单调在后面加字符；</li>
<li>只是统计子串数量。</li>
</ul>
<p>$\ \ \ \ \ \ \,$哇！这不是 $SAM$ 的裸题吗，周道感动得要哭了，根据<a href="/2018/12/29/后缀自动机/">【后缀自动机的性质】</a>：</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \ \,$点$i$上面表示子串的数量为:$len[fa[i]]−len[i]$<br>$\ \ \ \ \ \ \,$所以我们每次插入一个点，把新加的子串个数记累加就好了。</p>
<p>$\ \ \ \ \ \ \,$但是一看这个字符集大小……</p>
<p>$\ \ \ \ \ \ \,$不过我们知道，虽然字符集这么大，但是每个节点上面的儿子个数却是远远达不到字符集那么大的，所以我们试着用 $map$ 代替数组来记录儿子：</p>
<p>$\ \ \ \ \ \ \,$然后……就过了……</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Suffix_Automaton</span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;ch[N];</span><br><span class="line">  	<span class="type">int</span> last=<span class="number">1</span>,cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> len[N],fa[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> np=++cnt,p=last;last=np;</span><br><span class="line">		len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;p&amp;&amp;!ch[p][c];p=fa[p])ch[p][c]=np;</span><br><span class="line">		<span class="keyword">if</span>(!p)fa[np]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> q=ch[p][c];</span><br><span class="line">			<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>)fa[np]=q;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> nq=++cnt;len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">				ch[nq]=ch[q];</span><br><span class="line">				fa[nq]=fa[q];fa[q]=fa[np]=nq;</span><br><span class="line">				<span class="keyword">for</span>(;ch[p][c]==q;p=fa[p])ch[p][c]=nq;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=<span class="number">1ll</span>*len[np]-len[fa[np]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Sam;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="built_in">read</span>();</span><br><span class="line">		Sam.<span class="built_in">insert</span>(a);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #536 (Div. 2)【己亥年农历新年赛】简略题解</title>
    <url>/2019/02/15/Codeforces-Round-536-Div-2-%E5%B7%B1%E4%BA%A5%E5%B9%B4%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%E8%B5%9B-%E7%AE%80%E7%95%A5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="【题目地址】"><a href="#【题目地址】" class="headerlink" title="【题目地址】"></a><a href="https://codeforces.com/contest/1106">【题目地址】</a></h2><hr>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>$\ \ \ \ \ \ \,$这场比赛是wc2019回家那天晚上举办的，从8点到10点刚好在动车上，饥寒交迫，还拉肚子（吃不惯粤菜），就没有参加，是后面写的。</p>
<p>$\ \ \ \ \ \ \,$这套题在洛谷上面五颜六色的，很有意思啊（除了没有红的），题目也算可做，感觉很过年很快乐呢（<del>嘤嘤</del></p>
<span id="more"></span>
<p><img src="https://img-blog.csdnimg.cn/20190215201821828.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3Mzk2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h2 id="A-Lunar-New-Year-and-Cross-Counting"><a href="#A-Lunar-New-Year-and-Cross-Counting" class="headerlink" title="A. Lunar New Year and Cross Counting"></a><a href="https://codeforces.com/contest/1106/problem/A">A. Lunar New Year and Cross Counting</a></h2><p>$\ \ \ \ \ \ \,$模拟？暴力？可以不解释吗……</p>
<p><img src="https://img-blog.csdnimg.cn/20190215202145632.jpg" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> mp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x+<span class="number">2</span>&gt;n||y+<span class="number">2</span>&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mp[x][y]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">if</span>(mp[x][y+<span class="number">2</span>]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mp[x+<span class="number">1</span>][y+<span class="number">1</span>]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mp[x+<span class="number">2</span>][y]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">if</span>(mp[x+<span class="number">2</span>][y+<span class="number">2</span>]!=<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	ans+=<span class="built_in">check</span>(i,j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="B-Lunar-New-Year-and-Food-Ordering"><a href="#B-Lunar-New-Year-and-Food-Ordering" class="headerlink" title="B. Lunar New Year and Food Ordering"></a><a href="https://codeforces.com/contest/1106/problem/B">B. Lunar New Year and Food Ordering</a></h2><p>$\ \ \ \ \ \ \,$这个也是模拟吧，我们把菜品排个序，用一个指针跳就好了吧……（敷衍<br><img src="https://img-blog.csdnimg.cn/20190215203257557.jpg" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,z=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> rk[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> a,c,id;&#125;di[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.c&lt;b.c||(a.c==b.c&amp;&amp;a.id&lt;b.id);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)di[i].a=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)di[i].c=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)di[i].id=i;</span><br><span class="line">	<span class="built_in">sort</span>(di+<span class="number">1</span>,di+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rk[di[i].id]=i;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> kind=<span class="built_in">read</span>(),cnt=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(di[rk[kind]].a&gt;=cnt)&#123;</span><br><span class="line">			di[rk[kind]].a-=cnt;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*di[rk[kind]].c*cnt);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> ls=<span class="number">0ll</span>;</span><br><span class="line">		<span class="keyword">if</span>(di[rk[kind]].a)&#123;</span><br><span class="line">			cnt-=di[rk[kind]].a;</span><br><span class="line">			ls+=<span class="number">1ll</span>*di[rk[kind]].c*di[rk[kind]].a;</span><br><span class="line">			di[rk[kind]].a=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(cnt)&#123;</span><br><span class="line">			<span class="keyword">if</span>((!di[z].a)&amp;&amp;z&lt;=n)z++;</span><br><span class="line">			<span class="keyword">if</span>(z&gt;n)&#123;ls=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(di[z].a&gt;=cnt)&#123;</span><br><span class="line">					di[z].a-=cnt;</span><br><span class="line">					ls+=<span class="number">1ll</span>*di[z].c*cnt;</span><br><span class="line">					cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					cnt-=di[z].a;</span><br><span class="line">					ls+=<span class="number">1ll</span>*di[z].c*di[z].a;</span><br><span class="line">					di[z].a=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ls);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="C-Lunar-New-Year-and-Number-Division"><a href="#C-Lunar-New-Year-and-Number-Division" class="headerlink" title="C. Lunar New Year and Number Division"></a><a href="https://codeforces.com/contest/1106/problem/C">C. Lunar New Year and Number Division</a></h2><p>$\ \ \ \ \ \ \,$根据二项式定理，当然是两个两个分为一组最合算了（$n$ 范围明示</p>
<p>$\ \ \ \ \ \ \,$我们展开可得：</p>
<p>$(a+b)^2=a^2+b^2+2ab$</p>
<p>$\ \ \ \ \ \ \,$那么我们就想要两个成积较小的分一组最好，就是排序过后，最小的和最大的分一组好了呀。</p>
<p><img src="https://img-blog.csdnimg.cn/20190215204003943.jpg" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=n;i&lt;=j;i++,j--)</span><br><span class="line">	ans+=<span class="number">1ll</span>*(a[i]+a[j])*(a[i]+a[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="D-Lunar-New-Year-and-a-Wander"><a href="#D-Lunar-New-Year-and-a-Wander" class="headerlink" title="D. Lunar New Year and a Wander"></a><a href="https://codeforces.com/contest/1106/problem/D">D. Lunar New Year and a Wander</a></h2><p>$\ \ \ \ \ \ \,$BFS……</p>
<p>$\ \ \ \ \ \ \,$并不是，其实也差不多吧，当前可以走到的点，我们把他放进堆里面，然后每次走堆里最小的这个样子。</p>
<p>$\ \ \ \ \ \ \,$（因为题意没看懂翻车了几次</p>
<p><img src="https://img-blog.csdnimg.cn/20190215204454189.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3Mzk2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();</span><br><span class="line">		G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		G[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(),G[i].<span class="built_in">end</span>());</span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="number">-1</span>);used[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=-Q.<span class="built_in">top</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])<span class="keyword">if</span>(!used[v])</span><br><span class="line">		Q.<span class="built_in">push</span>(-v),used[v]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="E-Lunar-New-Year-and-Red-Envelopes"><a href="#E-Lunar-New-Year-and-Red-Envelopes" class="headerlink" title="E. Lunar New Year and Red Envelopes"></a><a href="https://codeforces.com/contest/1106/problem/E">E. Lunar New Year and Red Envelopes</a></h2><p>$\ \ \ \ \ \ \,$后面两道题就开始有讲的意思了，反正这道题我并没有独自写出来（我怀疑题都没有怎么读懂（我好菜呀<br><img src="https://img-blog.csdnimg.cn/20190215204926766.jpg" alt="在这里插入图片描述"></p>
<p>$\ \ \ \ \ \ \,$题目做法是DP，我们定义$f_{i,j}$，表示被打扰了 $i$ 次，现在时间是 $j$ 的最小收益。转移方程呢就是：</p>
<p>$f_{i,j+1}=f_{i-1,j}$</p>
<p>$f_{i,a_l.d+1}=f_{i-1,k}+a_l.w$</p>
<p>$\ \ \ \ \ \ \,$我们预处理数当前时间用那个红包好，就可以降低复杂度到$O(nm)$，具体来说，就是哪个钱多哪个好，钱一样多的话就是哪个冷却时间长哪个好。具体操作看的<a href="https://blog.csdn.net/g21glf/article/details/86743023"><strong>这里</strong></a>，其实很多地方没有必要这么麻烦，但是自己确实是太菜了，没有自己独立做出来。<br><img src="https://img-blog.csdnimg.cn/20190215210921828.jpg" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> d,w,t;&#125;sta[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.w&gt;b.w||(a.w==b.w&amp;&amp;a.d&gt;b.d);&#125;</span><br><span class="line">vector&lt;node&gt; e[N];</span><br><span class="line">map&lt;node,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(node a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mp.<span class="built_in">count</span>(a))mp[a]++;</span><br><span class="line">	<span class="keyword">else</span> mp[a]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(node a)</span></span>&#123;</span><br><span class="line">	mp[a]--;</span><br><span class="line">	<span class="keyword">if</span>(!mp[a])mp.<span class="built_in">erase</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">2</span>][N],ans=(<span class="number">1ll</span>&lt;&lt;<span class="number">62</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,s,t,d,w;i&lt;=k;i++)&#123;</span><br><span class="line">		s=<span class="built_in">read</span>(),t=<span class="built_in">read</span>(),d=<span class="built_in">read</span>(),w=<span class="built_in">read</span>();</span><br><span class="line">		e[s].<span class="built_in">push_back</span>((node)&#123;d,w,<span class="number">1</span>&#125;);</span><br><span class="line">		e[t+<span class="number">1</span>].<span class="built_in">push_back</span>((node)&#123;d,w,<span class="number">-1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> p:e[i])</span><br><span class="line">			<span class="keyword">if</span>(~p.t)<span class="built_in">Insert</span>(p);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">Delete</span>(p);</span><br><span class="line">		<span class="keyword">if</span>(mp.<span class="built_in">size</span>())sta[i]=(*mp.<span class="built_in">begin</span>()).first;</span><br><span class="line">		<span class="keyword">else</span> sta[i]=(node)&#123;i,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> cas=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f[cas],<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f[cas]));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			f[cas][i+<span class="number">1</span>]=<span class="built_in">min</span>(f[cas][i+<span class="number">1</span>],f[cas^<span class="number">1</span>][i]);</span><br><span class="line">			f[cas^<span class="number">1</span>][sta[i].d+<span class="number">1</span>]=<span class="built_in">min</span>(f[cas^<span class="number">1</span>][sta[i].d+<span class="number">1</span>],f[cas^<span class="number">1</span>][i]+sta[i].w);</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,f[cas^<span class="number">1</span>][n+<span class="number">1</span>]);cas^=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="F-Lunar-New-Year-and-a-Recursive-Sequence"><a href="#F-Lunar-New-Year-and-a-Recursive-Sequence" class="headerlink" title="F. Lunar New Year and a Recursive Sequence"></a><a href="https://codeforces.com/contest/1106/problem/F">F. Lunar New Year and a Recursive Sequence</a></h2><p>$\ \ \ \ \ \ \,$感觉这道题操作比E题麻烦一点，但是确实比E题好想呢。</p>
<p><img src="https://img-blog.csdnimg.cn/20190215213423624.jpg" alt="在这里插入图片描述"></p>
<p>$\ \ \ \ \ \ \,$看到是一个有 $k$ 项的递推式，马上就可以想到矩乘，而前 $k-1$ 项已经确定了是 $1$，我们不妨设要求的 $f_k$ 为 $a$ 。根据他给的式子啊，我们就容易发现，这个递推式的每一项都应该是 $a^x$ 的形式，知道第 $n$ 项是 $a$ 的多少次方就要好处理一些了。</p>
<p>$\ \ \ \ \ \ \,$这样子稍微观察一下矩阵乘法就定义好了：</p>
<p>$\ \ \ \ \ \ \,$转移矩阵：$A=$</p>
<p>$<br>\begin{bmatrix}0&amp;0&amp;\cdots&amp;0&amp;b_k\\ 1&amp;0&amp;\cdots&amp;0&amp;b_{k-1}\\0&amp;1&amp;\cdots&amp;0&amp;b_{k-2}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\0&amp;0&amp;\cdots&amp;1&amp;b_1\end{bmatrix}<br>$</p>
<p>$\ \ \ \ \ \ \,$初始矩阵：$S=$</p>
<p>$<br>\begin{bmatrix}0,0,\cdots,0,1\end{bmatrix}<br>$</p>
<p>$\ \ \ \ \ \ \,$那么第 $n$ 项的指数，就是 $S\cdot A^{n-k}$ 的第 $k$ 项，矩阵乘法取模的时候，根据欧拉定理，因为模数是素数，直接每次模 $mod-1$ 就好了。</p>
<p>$\ \ \ \ \ \ \,$现在问题是，我们知道 $x$，$m$，$mod$，$a^x\%mod=m$，如何求 $a$ 呢？</p>
<p>$\ \ \ \ \ \ \,$好在他给我们的模数很特殊，我们很清楚他的原根为 $3$ ，那么我们可以重新把 $a$ 定义为 $3^s\%mod$，所以原式化为:</p>
<p>$3^{sx}\%mod=m$</p>
<p>$\ \ \ \ \ \ \,$我们可以很轻松用 BSGS 算法知道 $sx\%(mod-1)$的取值，而我们又知道 $x\%(mod-1)$ 的取值，扩展GCD处理一下就好咯~</p>
<p><img src="https://img-blog.csdnimg.cn/20190215213335919.jpg" alt="在这里插入图片描述"></p>
<p>$\ \ \ \ \ \ \,$然后我们就知道 $s$ 的取值了（也有可能无解），那么答案也就出来了：$f_k=3^s$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> K,m,n;</span><br><span class="line">matrix S,A,T;</span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix m1,matrix m2)&#123;</span><br><span class="line">	matrix t;t.x=m1.x;t.y=m2.y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m1.x;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m2.y;j++)&#123;</span><br><span class="line">	  	t.a[i][j]=<span class="number">0</span>;</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m1.y;k++)</span><br><span class="line">	  	t.a[i][j]=(<span class="number">1ll</span>*t.a[i][j]+<span class="number">1ll</span>*m1.a[i][k]*m2.a[k][j])%(mod<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">power</span><span class="params">(matrix a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	matrix ans=a;b--;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a;</span><br><span class="line">		a=a*a;b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(<span class="number">1ll</span>*ans*a)%mod;</span><br><span class="line">		a=(<span class="number">1ll</span>*a*a)%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">BSGS</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c)</span></span>&#123;</span><br><span class="line">  	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;hash.<span class="built_in">clear</span>();b%=c;</span><br><span class="line">  	<span class="type">int</span> t=(<span class="type">int</span>)<span class="built_in">sqrt</span>(c)+<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">    	<span class="type">int</span> val=(<span class="type">int</span>)(b*<span class="built_in">power</span>(a,j,c)%c);</span><br><span class="line">    	hash[val]=j;</span><br><span class="line">  	&#125;</span><br><span class="line">  	a=<span class="built_in">power</span>(a,t,c);</span><br><span class="line">  	<span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;i++)&#123;</span><br><span class="line">    	<span class="type">int</span> val=<span class="built_in">power</span>(a,i,c);</span><br><span class="line">    	<span class="type">int</span> j=hash.<span class="built_in">find</span>(val)==hash.<span class="built_in">end</span>()?<span class="number">-1</span>:hash[val];</span><br><span class="line">    	<span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;i*t-j&gt;=<span class="number">0</span>)<span class="keyword">return</span> i*t-j;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> &amp;d,<span class="type">long</span> <span class="type">long</span> &amp;x,<span class="type">long</span> <span class="type">long</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)&#123;d=a;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">exgcd</span>(b,a%b,d,y,x);y-=x*(a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	K=<span class="built_in">read</span>();S.x=<span class="number">1</span>;</span><br><span class="line">	A.x=A.y=S.y=K;S.a[<span class="number">1</span>][K]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=K;i++)A.a[i][i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=K;i&gt;=<span class="number">1</span>;i--)A.a[i][K]=<span class="built_in">read</span>();</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	T=S*<span class="built_in">power</span>(A,n-K);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> t=<span class="built_in">BSGS</span>(<span class="number">3ll</span>,<span class="number">1ll</span>*m,mod);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> g,x,y;</span><br><span class="line">	<span class="built_in">exgcd</span>(T.a[<span class="number">1</span>][K],mod<span class="number">-1</span>,g,x,y);</span><br><span class="line">  	<span class="keyword">if</span>(t%g)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  	<span class="keyword">else</span>&#123;</span><br><span class="line">   		x=(t/g*x%(mod<span class="number">-1</span>)+mod<span class="number">-1</span>)%(mod<span class="number">-1</span>);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">power</span>(<span class="number">3</span>,x,mod));</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p><img src="https://img-blog.csdnimg.cn/20190215213506253.gif" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>修勾勾</tag>
        <tag>暴力模拟</tag>
        <tag>贪心</tag>
        <tag>动态规划</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>【SCOI2016】Day1初略题解</title>
    <url>/2019/02/13/SCOI2016-Day1%E5%88%9D%E7%95%A5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \,$做一套省选题来练练手（Day1）。</p>
<span id="more"></span>
<h2 id="【T1-背单词】"><a href="#【T1-背单词】" class="headerlink" title="【T1 背单词】"></a><a href="https://www.luogu.org/problemnew/show/P3294">【T1 背单词】</a></h2><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$ 由题意可以得到，如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 n*n 颗泡椒，这显然是很不合算的。要优先填入后缀。</p>
<p>$\ \ \ \ \ \,$第一个问题是如何找后缀，我们可以把串反过来插入 $Trie$ 树，然后按照$Trie$ 树上的父子关系新建树，按照一种神奇的 $DFS$ 序来依次填入。</p>
<p>$\ \ \ \ \ \,$ 现在的问题是如何处理这个 $DFS$ 序，手玩一点小样例可以发现，优先走子树小的较优，现在我们得到了填入顺序，每个点的填入序号减去他父亲的和，就是我们的答案，复杂度 $O(|len|+3n)$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510010</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],appear[N];</span><br><span class="line"><span class="type">int</span> id[N],cnt2,rt,cnt,n,size[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> size[x]&lt;size[y];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);<span class="type">int</span> now=rt,v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!son[now][s[i]-<span class="string">&#x27;a&#x27;</span>])son[now][s[i]-<span class="string">&#x27;a&#x27;</span>]=++cnt;</span><br><span class="line">		now=son[now][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	appear[now]=id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(appear[rt])&#123;a[fa].<span class="built_in">push_back</span>(appear[rt]);fa=appear[rt];&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)<span class="keyword">if</span>(son[rt][i])</span><br><span class="line">	id[son[rt][i]]=id[rt],<span class="built_in">dfs1</span>(son[rt][i],fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	size[rt]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a[rt].<span class="built_in">size</span>();i++)</span><br><span class="line">	<span class="built_in">dfs2</span>(a[rt][i]),size[rt]+=size[a[rt][i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ans</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	id[rt]=++cnt2;</span><br><span class="line">	<span class="built_in">sort</span>(a[rt].<span class="built_in">begin</span>(),a[rt].<span class="built_in">end</span>(),cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a[rt].<span class="built_in">size</span>();i++)</span><br><span class="line">	ans+=cnt2+<span class="number">1</span>-id[rt],<span class="built_in">get_ans</span>(a[rt][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;word.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;word.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),<span class="built_in">insert</span>(s,i);</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">get_ans</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="【T2-幸运数字】"><a href="#【T2-幸运数字】" class="headerlink" title="【T2 幸运数字】"></a><a href="https://www.luogu.org/problemnew/show/P3292">【T2 幸运数字】</a></h2><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$ 一眼可以看出来是实数异或线性基，不会这个的话就完全不能做这道题的。</p>
<p>$\ \ \ \ \ \,$下面的问题是，如何高效地处理路径问题？</p>
<p>$\ \ \ \ \ \,$我第一个想到的是树链剖分，复杂度为 $O(Q \log^2n)$，算上线性基合并的复杂度 $60\times 60$ 的常数有点吃不消。询问次数很大，我们可以试着多预处理一点。</p>
<p>$\ \ \ \ \ \,$倍增的复杂度为$O(Q \log n)$，加上一些蜜汁卡常数技巧，比如说去掉结构体啊什么的，就过了，空间还算充裕，没有那么卡。代码比较丑：</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> V[N],res;</span><br><span class="line"><span class="type">int</span> head[N],p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> last,v;&#125;G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	G[++p]=(ss)&#123;head[a],b&#125;;head[a]=p;</span><br><span class="line">	G[++p]=(ss)&#123;head[b],a&#125;;head[b]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lb[N][<span class="number">19</span>][<span class="number">61</span>],ans[<span class="number">61</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a,<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	<span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))</span><br><span class="line">	<span class="keyword">if</span>(!a[i])&#123;a[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">else</span> x^=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">querymax</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">	<span class="keyword">if</span>((res^a[i])&gt;res)res^=a[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a,<span class="type">long</span> <span class="type">long</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++)<span class="keyword">if</span>(b[i])<span class="built_in">insert</span>(a,b[i]);&#125;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">19</span>],deep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	fa[a][<span class="number">0</span>]=f;deep[a]=deep[f]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=head[a];i;i=G[i].last)</span><br><span class="line">	<span class="keyword">if</span>(G[i].v!=f)<span class="built_in">dfs</span>(G[i].v,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">	<span class="keyword">if</span>(deep[a]&gt;deep[b])<span class="built_in">swap</span>(a,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	<span class="keyword">if</span>(deep[a]&lt;=deep[b]-(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">    <span class="built_in">merge</span>(ans,lb[b][i]),b=fa[b][i];</span><br><span class="line">	<span class="keyword">if</span>(a==b)&#123;<span class="built_in">merge</span>(ans,lb[a][<span class="number">0</span>]);<span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(fa[a][i]!=fa[b][i])&#123;</span><br><span class="line">  		<span class="built_in">merge</span>(ans,lb[a][i]),<span class="built_in">merge</span>(ans,lb[b][i]);</span><br><span class="line">    	a=fa[a][i],b=fa[b][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">merge</span>(ans,lb[a][<span class="number">0</span>]),<span class="built_in">merge</span>(ans,lb[b][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">merge</span>(ans,lb[fa[a][<span class="number">0</span>]][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;lucky.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;lucky.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=(<span class="type">int</span>)<span class="built_in">read</span>();m=(<span class="type">int</span>)<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)V[i]=<span class="built_in">read</span>(),<span class="built_in">insert</span>(lb[i][<span class="number">0</span>],V[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;n;i++)</span><br><span class="line">    a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),<span class="built_in">add</span>(a,b);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">18</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	fa[i][j]=fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">  		<span class="built_in">memcpy</span>(lb[i][j],lb[i][j<span class="number">-1</span>],<span class="built_in">sizeof</span>(lb[i][j<span class="number">-1</span>]));</span><br><span class="line">    	<span class="built_in">merge</span>(lb[i][j],lb[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)&#123;</span><br><span class="line">    	a=(<span class="type">int</span>)<span class="built_in">read</span>();b=(<span class="type">int</span>)<span class="built_in">read</span>();</span><br><span class="line">    	<span class="built_in">query</span>(a,b);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">querymax</span>(ans));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="【T3-萌萌哒】"><a href="#【T3-萌萌哒】" class="headerlink" title="【T3 萌萌哒】"></a><a href="https://www.luogu.org/problemnew/show/P3295">【T3 萌萌哒】</a></h2><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$ 这道题前$30$分做法很显然吧，两段相关联的各个元素，我们可以用并查集并在一起，因为他们必须一定是同一种。最后统计并查集个数就好了，设个数为$cnt$，那么我们的答案是$9\times 10^{cnt-1}$，因为包含第一个数位的只有$1$-$9$，其他可以取$0$-$9$。复杂度$O(n^2)$</p>
<p>$\ \ \ \ \ \,$ 我们可以通过类似于势能分析来操作，来降低复杂度到$O(n\log n)$，操作很骚，一开始没想到，也没有在其他地方见到过。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cnt,n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="number">1ll</span>*a*a%mod)<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=<span class="number">1ll</span>*a*ans%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">20</span>][N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inv(x) power(x,mod-2)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> f[k][x]==x?x:f[k][x]=<span class="built_in">find</span>(k,f[k][x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">log_2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ret=<span class="number">0</span>;x;x&gt;&gt;=<span class="number">1</span>,ret++);</span><br><span class="line">	<span class="keyword">return</span> ret<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> xx,<span class="type">int</span> yy)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> r1=<span class="built_in">find</span>(k,xx),r2=<span class="built_in">find</span>(k,yy);</span><br><span class="line">	<span class="keyword">if</span>(r1==r2) <span class="keyword">return</span>;</span><br><span class="line">	f[k][r1]=r2;</span><br><span class="line">	<span class="keyword">if</span>(!k)&#123;cnt--;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">solve</span>(k<span class="number">-1</span>,xx,yy);</span><br><span class="line">	<span class="built_in">solve</span>(k<span class="number">-1</span>,xx+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>),yy+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;moe.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;moe.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	cnt=n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">18</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	f[i][j]=j;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l1=<span class="built_in">read</span>(),r1=<span class="built_in">read</span>(),l2=<span class="built_in">read</span>(),r2=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(l1&gt;l2) <span class="built_in">swap</span>(l1,l2),<span class="built_in">swap</span>(r1,r2);</span><br><span class="line">		<span class="type">int</span> t=<span class="built_in">log_2</span>(r1-l1+<span class="number">1</span>);</span><br><span class="line">    	<span class="built_in">solve</span>(t,l1,l2);</span><br><span class="line">    	<span class="built_in">solve</span>(t,r1-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>,r2-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">9ll</span>*<span class="built_in">power</span>(<span class="number">10</span>,cnt<span class="number">-1</span>)%mod);</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>异或</tag>
        <tag>Trie树</tag>
        <tag>并查集</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>【SCOI2016】Day2初略题解</title>
    <url>/2019/02/15/SCOI2016-Day2%E5%88%9D%E7%95%A5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \,$做一套省选题来练练手（Day2）。</p>
<span id="more"></span>
<h2 id="【T1-妖怪】"><a href="#【T1-妖怪】" class="headerlink" title="【T1 妖怪】"></a><a href="https://www.luogu.org/problemnew/show/P3291">【T1 妖怪】</a></h2><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$ 对于一个妖怪的两个属性，为了方便我们把它定义为 $x$，$y$，而要求的一个妖怪的战斗力应该为：</p>
<p>$(\frac{b}{a}+1)x+(\frac{a}{b}+1)y$</p>
<p>$\ \ \ \ \ \,$ 既：</p>
<p>$\frac{b}{a}x+\frac{a}{b}y+x+y$</p>
<p>$\ \ \ \ \ \,$ 由于 $x$，$y$ 已经确定，所以我们需要找的是 $\frac{b}{a}x+\frac{a}{b}y$ 最大的最小。</p>
<p>$\ \ \ \ \ \,$容易得到这是个<strong>对勾函数</strong>，对于一个怪物，当$\frac{b}{a}=\sqrt{\frac{y}{x}}$ 时，战斗力最小。</p>
<p>$\ \ \ \ \ \,$所以我们以 $x$，$y$ 为横纵坐标做个上凸壳，那么答案就一定是在凸壳上面，就会存在下面两种情况：</p>
<ul>
<li>在点上：$\frac{b}{a}=\sqrt{\frac{y}{x}}$</li>
<li>在边上：需要满足：<br>$(\frac{b}{a}+1)x_1+(\frac{a}{b}+1)y_1=(\frac{b}{a}+1)x_2+(\frac{a}{b}+1)y_2$<br>解得：$\frac{b}{a}=\frac{y_1-y_2}{x_2-x_1}$</li>
</ul>
<p>$\ \ \ \ \ \,$就这样扫一遍过去就行了，复杂度 $O(n \log n)$。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;<span class="type">long</span> <span class="type">long</span> x,y;&#125;p[N],f[N];</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> (Point)&#123;a.x+b.x,a.y+b.y&#125;;&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> (Point)&#123;a.x-b.x,a.y-b.y&#125;;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Cross</span><span class="params">(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Solve</span><span class="params">(Point *P,<span class="type">int</span> n,Point *F)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(P+<span class="number">1</span>,P+n+<span class="number">1</span>);<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(;top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">Cross</span>(F[top]-F[top<span class="number">-1</span>],P[i]-F[top<span class="number">-1</span>])&gt;=<span class="number">0</span>;top--);</span><br><span class="line">    	F[++top]=P[i];</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">const</span> Point &amp;a,<span class="type">double</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> k&lt;=<span class="number">0</span>?inf:(<span class="type">double</span>)a.x+a.y+k*a.x+a.y/k;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Getval_point</span><span class="params">(<span class="type">const</span> Point &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="type">double</span>)a.y/a.x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Getval_line</span><span class="params">(<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a.x==b.x?-inf:((<span class="type">double</span>)(a.y-b.y)/(<span class="type">double</span>)(b.x-a.x));&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;monster.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;monster.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)p[i].x=<span class="number">1ll</span>*<span class="built_in">read</span>(),p[i].y=<span class="number">1ll</span>*<span class="built_in">read</span>();</span><br><span class="line">	m=<span class="built_in">Solve</span>(p,n,f);</span><br><span class="line">	<span class="keyword">if</span>(m&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.4lf&quot;</span>,<span class="built_in">solve</span>(f[<span class="number">1</span>],<span class="built_in">Getval_point</span>(f[<span class="number">1</span>])));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">double</span> k1,k2,k3,ans=inf;</span><br><span class="line">		k1=<span class="built_in">Getval_point</span>(f[<span class="number">1</span>]),k2=<span class="built_in">Getval_line</span>(f[<span class="number">1</span>],f[<span class="number">2</span>]);</span><br><span class="line">		<span class="keyword">if</span>(k1&lt;=k2)ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[<span class="number">1</span>],k1));</span><br><span class="line">		k1=<span class="built_in">Getval_point</span>(f[m]),k2=<span class="built_in">Getval_line</span>(f[m<span class="number">-1</span>],f[m]);</span><br><span class="line">		<span class="keyword">if</span>(k1&gt;=k2)ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[m],k1));</span><br><span class="line">  		ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[m],k2));</span><br><span class="line">  		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">2</span>;i&lt;m;++i)&#123;</span><br><span class="line">  			k1=<span class="built_in">Getval_line</span>(f[i<span class="number">-1</span>],f[i]);</span><br><span class="line">  			k2=<span class="built_in">Getval_line</span>(f[i],f[i+<span class="number">1</span>]);</span><br><span class="line">  			k3=<span class="built_in">Getval_point</span>(f[i]);</span><br><span class="line">  			ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[i],k1));</span><br><span class="line">  			<span class="keyword">if</span>(k1&lt;=k3&amp;&amp;k3&lt;=k2)</span><br><span class="line">  			ans=<span class="built_in">min</span>(ans,<span class="built_in">solve</span>(f[i],k3));</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="【T2-美味】"><a href="#【T2-美味】" class="headerlink" title="【T2 美味】"></a><a href="https://www.luogu.org/problemnew/show/P3293">【T2 美味】</a></h2><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \,$又是异或最大呢，不是线性基就是贪心了，day1才搞了线性基，可以排除，我们看看怎么贪心。</p>
<p>$\ \ \ \ \ \,$首先可以看到他有一个取值范围的限制，我们可以用到可持久化数据结构维护。</p>
<p>$\ \ \ \ \ \,$然后我们可以贪心地想，从高位到低为维护 $a_i$ 的存在性。这个可持久化数据结构需要满足下面的操作：</p>
<ul>
<li>插入一个数；</li>
<li>删除一个数；</li>
<li>统计某个取值范围的数数量是多少。</li>
</ul>
<p>$\ \ \ \ \ \,$我最后选择了权值主席树。</p>
<p>$\ \ \ \ \ \,$现在对于每一次询问，我们贪心一下，从高位到低位枚举，如果$b$这一位为$1$，我们就找 $0$ ，反之找 $1$。</p>
<p>$\ \ \ \ \ \,$怎么找呢？我们令当前找到第$i$位， $ans$ 等于当前最优的 $a_i+x$，那么我们就找当前 $[l,r]$ 范围内，是否存在有数次在区间（$1/0$为当前要找的数）：</p>
<p>$[ans+(1/0&lt;&lt;i)-x,ans+(1/0&lt;&lt;i)-x+(1&lt;&lt;i)-1]$</p>
<p>$\ \ \ \ \ \,$存在的话就更新$ans$为 $ans+(1/0&lt;&lt;i)$，不然退而求其次，取 $ans+(0/1&lt;&lt;i)$。</p>
<p>$\ \ \ \ \ \,$这样我们可以保证在完成贪心，取到第0位之时，$ans$ 等于最优的 $a_i+x$。（并不关心是哪个$a_i$，反正是拼出来了。</p>
<p>$\ \ \ \ \ \,$复杂度$O(n \log a_{max}+m\log^2 a_{max})$</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,p=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) p=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c&amp;<span class="number">15</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N],root[N];</span><br><span class="line"><span class="type">int</span> n,m,nn;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CM_Tree</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson l,mid,ls[rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson mid+1,r,rs[rt]</span></span><br><span class="line">	<span class="type">int</span> ls[N*<span class="number">20</span>],rs[N*<span class="number">20</span>],sum[N*<span class="number">20</span>],size;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">copy</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		ls[++size]=ls[rt];</span><br><span class="line">		rs[size]=rs[rt];</span><br><span class="line">		sum[size]=sum[rt];</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt)</span></span>&#123;</span><br><span class="line">    	rt=<span class="built_in">copy</span>(rt);sum[rt]++;</span><br><span class="line">    	<span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(id&lt;=mid)<span class="built_in">update</span>(id,lson);</span><br><span class="line">    	<span class="keyword">else</span> <span class="built_in">update</span>(id,rson);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> rt2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)<span class="keyword">return</span> sum[rt2]-sum[rt];</span><br><span class="line">    	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ret=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span>(L&lt;=mid)ret+=<span class="built_in">query</span>(L,R,lson,ls[rt2]);</span><br><span class="line">    	<span class="keyword">if</span>(mid&lt;R)ret+=<span class="built_in">query</span>(L,R,rson,rs[rt2]);</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	L=<span class="built_in">max</span>(<span class="number">0</span>,L);R=<span class="built_in">min</span>(R,nn);</span><br><span class="line">	<span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> tree.<span class="built_in">query</span>(L,R,<span class="number">0</span>,nn,root[i],root[j])&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getbit(a,i) ((a&gt;&gt;i)&amp;1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;food.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;food.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>(),nn=<span class="built_in">max</span>(nn,a[i]);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)root[i]=root[i<span class="number">-1</span>],tree.<span class="built_in">update</span>(a[i],<span class="number">0</span>,nn,root[i]);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    	<span class="type">int</span> b=<span class="built_in">read</span>(),x=<span class="built_in">read</span>(),l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(),ans=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">17</span>,ls;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(!<span class="built_in">getbit</span>(b,i))ls=ans+(<span class="number">1</span>&lt;&lt;i)-x;</span><br><span class="line">    		<span class="keyword">else</span> ls=ans-x;</span><br><span class="line">      		<span class="keyword">if</span>(<span class="built_in">check</span>(l<span class="number">-1</span>,r,ls,ls+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>))ans=ls+x;</span><br><span class="line">      		<span class="keyword">else</span> ans+=<span class="built_in">getbit</span>(b,i)&lt;&lt;i;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans^b);</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(stdin);</span><br><span class="line">	<span class="built_in">fclose</span>(stdout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="【T3-围棋】"><a href="#【T3-围棋】" class="headerlink" title="【T3 围棋】"></a><a href="https://www.luogu.org/problemnew/show/P3290">【T3 围棋】</a></h2><p>$\ \ \ \ \ \,$插头dp是不会做插头dp的，这辈子不可能做插头dp的。写起来又怪麻烦，就是打打傻逼暴力，才能骗得了分这样子。</p>
<p>$\ \ \ \ \ \,$（逃</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>贪心</tag>
        <tag>计算几何</tag>
        <tag>凸壳</tag>
        <tag>数形结合</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>tarjian算法的运用</title>
    <url>/2019/01/02/tarjian%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$tarjian算法及其相关算法的复习笔记：</p>
<span id="more"></span>
<h2 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h2><p>$\ \ \ \ \ \ \ \,$对于一个有向图，能互相到达的点在一个连通分量，很多时候一个连通分量的点对答案没有影响，或者可以统一安排，那么我们就用tarjan算法把它们缩在一起。</p>
<p>$\ \ \ \ \ \ \ \,$这样就把有向图转换为了一个DAG，会方便处理很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> U[N],V[N],p;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;U[++p]=a;V[p]=b;G[a].<span class="built_in">push_back</span>(b);&#125;</span><br><span class="line"><span class="type">int</span> sta[N],top;</span><br><span class="line"><span class="type">int</span> low[N],dfn[N],tim;</span><br><span class="line"><span class="type">int</span> col[N],mark;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  sta[++top]=x;</span><br><span class="line">  low[x]=dfn[x]=++tim;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!dfn[v])<span class="built_in">tarjan</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(!col[v])low[x]=<span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">    mark++; </span><br><span class="line">    <span class="keyword">while</span>(sta[top+<span class="number">1</span>]!=x)col[sta[top]]=mark,top--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main():</span></span><br><span class="line"><span class="comment">//  for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//  if(!dfn[i]) tarjan(i);</span></span><br></pre></td></tr></table></figure>
<h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><p>$\ \ \ \ \ \ \ \,$在一个无向图中，去掉一个点，使得图不连通，这个点就叫割点（sta[]中）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;G[a].<span class="built_in">push_back</span>(b);G[b].<span class="built_in">push_back</span>(a);&#125;</span><br><span class="line"><span class="type">int</span> sta[N],top;</span><br><span class="line"><span class="type">int</span> low[N],dfn[N],tim;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  low[x]=dfn[x]=++tim;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v,rt);</span><br><span class="line">      low[x]=<span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">      <span class="keyword">if</span>(low[v]&gt;=dfn[x]&amp;&amp;x!=rt&amp;&amp;used[x]==<span class="number">0</span>)</span><br><span class="line">      &#123;sta[++top]=x;used[x]=<span class="number">1</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(x==rt)cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    low[x]=<span class="built_in">min</span>(low[x],dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x==rt&amp;&amp;cnt&gt;=<span class="number">2</span>&amp;&amp;used[x]==<span class="number">0</span>)</span><br><span class="line">  &#123;sta[++top]=x;used[x]=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main():</span></span><br><span class="line"><span class="comment">//  for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//  if(!dfn[i]) tarjan(i,i);</span></span><br></pre></td></tr></table></figure>
<h2 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h2><p>$\ \ \ \ \ \ \ \,$专门处理仙人掌的做法，把一个环转换为一个方点，把一个仙人掌转换为一棵树，方便处理：</p>
<p>$\ \ \ \ \ \ \ \,$（方点之间连接的圆点为割点）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sta[N],top,size,tim,dfn[N],low[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],E[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;G[a].<span class="built_in">push_back</span>(b);G[b].<span class="built_in">push_back</span>(a);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;E[a].<span class="built_in">push_back</span>(b);E[b].<span class="built_in">push_back</span>(a);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  dfn[x]=low[x]=++tim;</span><br><span class="line">  sta[++top]=x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v),low[x]=<span class="built_in">min</span>(low[x],low[v]);</span><br><span class="line">      <span class="keyword">if</span>(low[v]&gt;=dfn[x])&#123;</span><br><span class="line">        ++size;</span><br><span class="line">        <span class="keyword">while</span>(sta[top+<span class="number">1</span>]!=v)<span class="built_in">add2</span>(sta[top],size),top--;</span><br><span class="line">        <span class="built_in">add2</span>(x,size);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		low[x]=<span class="built_in">min</span>(low[x],dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>图论</tag>
        <tag>圆方树</tag>
        <tag>Tarjian</tag>
        <tag>连通分量</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机</title>
    <url>/2018/12/29/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于后缀自动机性质的复习笔记：</p>
<span id="more"></span>
<p>$\ \ \ \ \ \ \ \,$后缀自动机是一个可以解决大多数字符串问题的字符串数据结构，可以识别该字符串的所有子串，其时空复杂度也比较优秀，对于一个字符集大小为$m$，长度为$n$的字符串，建立一个后缀自动机的时间复杂度为$O(nm)$，空间复杂度为 $O(2nm)$。</p>
<p>$\ \ \ \ \ \ \ \,$讲后缀自动机的博客很多，这里直接给出模板，重点讲讲后缀自动机长什么样子，怎么用它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Suffix_Automaton</span>&#123;</span><br><span class="line">  <span class="type">int</span> len[N&lt;&lt;<span class="number">1</span>],fa[N&lt;&lt;<span class="number">1</span>],son[N&lt;&lt;<span class="number">1</span>][<span class="number">26</span>];</span><br><span class="line">  <span class="type">int</span> size,last;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;size=last=<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> s=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  	<span class="type">int</span> p=last,np=++size;last=np;</span><br><span class="line">  	len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(;p&amp;&amp;!son[p][s];p=fa[p])son[p][s]=np;</span><br><span class="line">  	<span class="keyword">if</span>(!p)fa[np]=<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">else</span>&#123;</span><br><span class="line">  		<span class="type">int</span> q=son[p][s];</span><br><span class="line">  		<span class="keyword">if</span>(len[p]+<span class="number">1</span>==len[q])fa[np]=q;</span><br><span class="line">  		<span class="keyword">else</span>&#123;</span><br><span class="line">  			<span class="type">int</span> nq=++size;len[nq]=len[p]+<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">memcpy</span>(son[nq],son[q],<span class="built_in">sizeof</span>(son[q]));</span><br><span class="line">  			fa[nq]=fa[q];fa[q]=fa[np]=nq;</span><br><span class="line">  			<span class="keyword">for</span>(;son[p][s]==q;p=fa[p])son[p][s]=nq;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">Init</span>();</span><br><span class="line">  	<span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">  	<span class="built_in">insert</span>(s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;Sam;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$对于一个串 $abcabbca$，我们建立的后缀自动机就是这个样子的：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7d92af985e9c0bc856c6540d026440d2.png" alt="FgcB5V.md.png"><br>（注意点12到点6少了一条边b）</p>
<p>$\ \ \ \ \ \ \ \,$其中我们如下规定：</p>
<ul>
<li><p>红色，蓝色，绿色的边构成一个尾部收束的$Trie$树，用来高效表示这个串的后缀集合，就是$son$数组构成的。并且我们把红色的链叫做主链，蓝色叫做扩展链，同一水平面的点叫做扩展点对（在模板中，每个$last$的取值都是主链，每个$np$和$nq$都是扩展点对）<del>（都是我自己取的名字）</del></p>
</li>
<li><p>黄色构成$parents$树，就是$fa$数组构成的，这棵树爸爸不认儿子，儿子认爸爸。</p>
</li>
<li><p>在点旁边的灰色数字就是$len$数组。</p>
</li>
</ul>
<p>$\ \ \ \ \ \ \ \,$其实这张图看上去还是挺麻烦的，我们不如将它分开来看：</p>
<h2 id="尾部收束的-Trie-树："><a href="#尾部收束的-Trie-树：" class="headerlink" title="尾部收束的$Trie$树："></a>尾部收束的$Trie$树：</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/1f18cdea677c5f50e8046a4ded937fb9.png" alt="Fgc7xe.md.png"><br>（注意点12到点6少了一条边b）</p>
<p>$\ \ \ \ \ \ \ \,$尾部收束的$Trie$树，用来高效表示这个串的后缀集合，可以发现，我们从节点 $1$ 开始走，在走到没有儿子的节点的时候，必然是原串的一个后缀，并且是覆盖完了的，换句话说，<strong>这个串的任意子串都可以在这棵树上表示出来，且仅有这个串的子串才能表示</strong>。</p>
<p>$\ \ \ \ \ \ \ \,$不妨来观察一下，每一个节点上都有哪些子串的信息：</p>
<p><strong> 2：a </strong></p>
<p><strong> 3：ab </strong></p>
<p><strong> 4：abc </strong></p>
<p><strong> 5：abca </strong></p>
<p><strong> 6：abcab，bcab，cab </strong></p>
<p><strong> 7：abcabb，bcabb，cabb，abb，bb </strong></p>
<p><strong> 8：b </strong></p>
<p><strong> 9：abcabbc，bcabbc，cabbc，abbc，bbc </strong></p>
<p><strong> 10：bc，c </strong></p>
<p><strong> 11：abcabbca，bcabbca，cabbca，abbca，bbca </strong></p>
<p><strong> 12：bca，ca </strong></p>
<p>$\ \ \ \ \ \ \ \,$这样一来，很多性质都出来了：</p>
<p><strong> 在$Trie$上，父亲是儿子上的子串的公共前缀<del>（废话）</del>； </strong></p>
<p><strong> 在主链上的点，最长的子串都是原串的前缀； </strong></p>
<p><strong> 在一个点上的子串，短的为长的的后缀； </strong></p>
<p><strong> $len$数组表示的是这个节上的子串最长长度； </strong></p>
<p><strong> 扩展点对一个在主链上一个在扩展链上，在扩展链上的点上的子串是在主链上的点上的子串的公共后缀。 </strong></p>
<h2 id="parents-树："><a href="#parents-树：" class="headerlink" title="$parents$树："></a>$parents$树：</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/c3221ce482a1ff2ce6b53fb9b1d20638.png" alt="Fg2dhV.png"></p>
<p>$\ \ \ \ \ \ \ \,$这样看起来好像不是特别方便，我们把他整合一下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3da88966e5b248626cf33b5c6d868c74.png" alt="Fg26B9.png"></p>
<p>$\ \ \ \ \ \ \ \,$回想一下每一个节点上都有哪些子串的信息和出现次数，顺便看看每个子串出现的终点：</p>
<p><strong> 2：a (3：1,4,8) </strong></p>
<p><strong> 3：ab (2：2,5) </strong></p>
<p><strong> 4：abc (1：3) </strong></p>
<p><strong> 5：abca (1：4) </strong></p>
<p><strong> 6：abcab (1：5)，bcab (1：5)，cab (1：5) </strong></p>
<p><strong> 7：abcabb (1：6)，bcabb (1：6)，cabb (1：6)，abb (1：6)，bb (1：6) </strong></p>
<p><strong> 8：b (3：2,5,6) </strong></p>
<p><strong> 9：abcabbc (1：7)，bcabbc (1：7)，cabbc (1：7)，abbc (1：7)，bbc (1：7) </strong></p>
<p><strong> 10：bc (2：3,7)，c (2：3,7) </strong></p>
<p><strong> 11：abcabbca (1：8)，bcabbca (1：8)，cabbca (1：8)，abbca (1：8)，bbca (1：8) </strong></p>
<p><strong> 12：bca (2：4,8)，ca (2：4,8) </strong></p>
<p>$\ \ \ \ \ \ \ \,$很多性质又都出来了：</p>
<p><strong> 在$parents$上，父亲是儿子上的子串的公共后缀； </strong></p>
<p><strong> 叶子节点都是主链上的节点； </strong></p>
<p><strong> 主链上的节点上的子串的出现终点，都有$len$数组描述的位置； </strong></p>
<p><strong> 一个节点上的子串出现次数是一样的； </strong></p>
<p><strong> 父亲上的子串出现次数，是儿子上的子串出现次数之和； </strong></p>
<p><strong> 儿子上的子串出现的终点，是父亲上的子串出现的终点的子集； </strong></p>
<p><strong> 点$i$上面表示子串的数量为$len[fa[i]]-len[i]$。 </strong></p>
<hr>
<p>$\ \ \ \ \ \ \ \,$最后我们总结一下：<br><strong> 在$Trie$上，父亲是儿子上的子串的公共前缀； </strong></p>
<p><strong> 在$parents$上，父亲是儿子上的子串的公共后缀； </strong></p>
<p><strong> 在一个点上的子串，短的为长的的后缀； </strong></p>
<p><strong> 一个节点上的子串出现次数是一样的； </strong></p>
<p><strong> $len$数组表示的是这个节上的子串最长长度； </strong></p>
<p><strong> $parents$上叶子节点都是主链上的节点； </strong></p>
<p><strong> 在主链上的点，最长的子串都是原串的前缀； </strong></p>
<p><strong> 主链上的节点上的子串的出现终点，都有$len$数组描述的位置； </strong></p>
<p><strong> 扩展点对一个在主链上一个在扩展链上，在扩展链上的点上的子串是在主链上的点上的子串的公共后缀； </strong></p>
<p><strong> $parents$上父亲上的子串出现次数，是儿子上的子串出现次数之和，如果父亲在主链上，就再加一； </strong></p>
<p><strong> $parents$上儿子上的子串出现的终点，是父亲上的子串出现的终点的子集； </strong></p>
<p><strong> 点$i$上面表示子串的数量为$len[fa[i]]-len[i]$。 </strong></p>
<hr>
<p>$\ \ \ \ \ \ \ \,$如此多的性质，我们就可以拿后缀自动机解决很多问题了：</p>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>  文本串建立后缀自动机，模式串在$Trie$上面跑一次，跑完了就匹配到了，利用了$Trie$上面包含了原串所有子串的性质，多文本串的话，就在文本串之间插入奇怪字符，然后一起建立后缀自动机就行了就可以解决了，或者建广义后缀自动机。</p>
<h2 id="子串查询出现次数"><a href="#子串查询出现次数" class="headerlink" title="子串查询出现次数"></a>子串查询出现次数</h2><p>  文本串建立后缀自动机，然后在$parents$上做$dp$，询问就让模式串在$Trie$上面跑一次，找到自动机上点，输出就好了，利用了$parents$上父亲上的子串出现次数，是儿子上的子串出现次数之和的性质。因为$parents$上是儿子认爸爸，爸爸不认儿子，所以我们需要跑个拓扑，拓扑序就是$y$的倒叙了啊：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)x[len[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)x[i]+=x[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)y[x[len[i]]--]=i;</span><br><span class="line"><span class="comment">//for(int i=size;i&gt;=1;i--)tim[fa[y[i]]]+=tim[y[i]];</span></span><br></pre></td></tr></table></figure>
<h2 id="子串查询出现位置"><a href="#子串查询出现位置" class="headerlink" title="子串查询出现位置"></a>子串查询出现位置</h2><p>  文本串建立后缀自动机，让模式串在$Trie$上面跑一次，找到自动机上点，再从这个点开始，在$parents$上跑，遇到在主链上的点，它的$len$值就是终点了，要是求起点坐标，终点减去长度加上$1$就好了。</p>
<h2 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h2><p>  文本串倍增，后半截翻转，查询子串出现次数大于$2$，并且位置换算一下，如果相解就是合法，取最大值就好了，实现起来略复杂，没有Manacher算法优秀。</p>
<h2 id="子串的子串"><a href="#子串的子串" class="headerlink" title="子串的子串"></a>子串的子串</h2><p>  子串的子串要么是它的前缀的后缀，要么是它的前缀，要么是他的后缀，所以说只需要找到子串这个点，他在$parents$上的子树和他在$Trie$的祖先，还有他在$parents$上的子树的$Trie$的祖先，都是他的子串。</p>
<h2 id="后缀自动机的合并（广义后缀自动机）"><a href="#后缀自动机的合并（广义后缀自动机）" class="headerlink" title="后缀自动机的合并（广义后缀自动机）"></a>后缀自动机的合并（广义后缀自动机）</h2><p>  后缀自动机的合并，我们可以理解为，在后缀自动机上新加入一个字符串，其实只需要将 $last$ 重新赋为 $1$ ，注意新串的点打上不一样的标记，这个差不多就是广义后缀自动机，广义后缀自动机还有一步判断这个点有没有被建过的操作，但个人感觉实际上没有必要，最坏空间复杂度依然是$O(2nm)$的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">  col++;last=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">  <span class="built_in">insert</span>(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$还有很多关于子串，前缀，后缀的问题或者可以转换为子串，前缀，后缀的问题，用后缀自动机在大多数情况下都是不二之选，一般字符串的字符集都比较小，所以复杂度也很优秀，但要是字符集大小太大的话，还是仔细想想其他算法吧。</p>
<p>$\ \ \ \ \ \ \ \,$还有，后缀自动机处理的字符串是静态的，最多就是在后面加后缀，要是需要处理动态的字符串的话，多半也是不合算的，需要考虑其他算法。</p>
<p>$\ \ \ \ \ \ \ \,$不过，后缀自动机依然是一个优秀的字符串数据结构，代码量小，适用性高，是一个万金油算法。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay各种操作模板大赏</title>
    <url>/2019/01/05/Splay%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF%E5%A4%A7%E8%B5%8F/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于Splay操作的复习笔记：</p>
<p>$\ \ \ \ \ \ \ \,$依然的，只记录模板，不讲原理，关于Splay出门左拐百度。</p>
<span id="more"></span>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson son[0][rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson son[1][rt]</span></span><br><span class="line">	<span class="type">int</span> root,cnt;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">2</span>][N],sum[N],val[N],size[N],fa[N];</span><br><span class="line">	<span class="type">int</span> lazy[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>$\tt root$ ：根；</li>
<li>$\tt cnt$ ：下标大小；</li>
<li>$\tt son[0/1][]$ ：左右儿子；</li>
<li>$\tt sum[]$ ：子树大小；</li>
<li>$\tt val[]$ ：节点权值；</li>
<li>$\tt size[]$ ：节点大小；</li>
<li>$\tt fa[]$ ：节点父亲；</li>
<li>$\tt lazy[]$ ：下传标记。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>标记上传 ($pushup$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!rt)<span class="keyword">return</span>;</span><br><span class="line">	sum[rt]=sum[lson]+sum[rson]+size[rt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>标记下传 ($pushdown$)，根据情况会不一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">  	lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">  	lazy[rt]=<span class="number">0</span>;</span><br><span class="line">  	<span class="built_in">swap</span>(lson,rson);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>左旋+右旋 ($rotate$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> y=fa[x];<span class="type">int</span> z=fa[y];</span><br><span class="line">  	<span class="type">int</span> k=son[<span class="number">1</span>][y]==x;</span><br><span class="line">  	son[son[<span class="number">1</span>][z]==y][z]=x;</span><br><span class="line">  	fa[x]=z;</span><br><span class="line">  	son[k][y]=son[k^<span class="number">1</span>][x];</span><br><span class="line">  	fa[son[k^<span class="number">1</span>][x]]=y;</span><br><span class="line">  	son[k^<span class="number">1</span>][x]=y;</span><br><span class="line">  	fa[y]=x;</span><br><span class="line">	<span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将$x$旋转到$goal$下 ($splay$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> goal)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line">  		<span class="type">int</span> y=fa[x];<span class="type">int</span> z=fa[y];</span><br><span class="line">  		<span class="keyword">if</span>(z!=goal)</span><br><span class="line">  		(son[<span class="number">1</span>][z]==y)^(son[<span class="number">1</span>][y]==x)?<span class="built_in">rotate</span>(x):<span class="built_in">rotate</span>(y);</span><br><span class="line">  		<span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(goal==<span class="number">0</span>)root=x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li>新建节点 ($newnode$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=++cnt;</span><br><span class="line">    size[rt]=<span class="number">1</span>;sum[rt]=<span class="number">1</span>;val[rt]=v;</span><br><span class="line">    fa[rt]=f;lson=rson=<span class="number">0</span>;lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>清空节点 ($clean$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    lson=rson=<span class="number">0</span>;fa[rt]=<span class="number">0</span>;</span><br><span class="line">    val[rt]=<span class="number">0</span>;sum[rt]=size[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>建立 ($Build$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> &amp;rt,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span>;</span><br><span class="line">  	<span class="type">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  	rt=<span class="built_in">newnode</span>(f,a[mid]);</span><br><span class="line">  	<span class="built_in">Build</span>(lson,L,mid<span class="number">-1</span>,rt);</span><br><span class="line">  	<span class="built_in">Build</span>(rson,mid+<span class="number">1</span>,R,rt);</span><br><span class="line">  	<span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>插入($Insert$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;root=<span class="built_in">newnode</span>(<span class="number">0</span>,v);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> now=root,rt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(now);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(val[now]==v)&#123;</span><br><span class="line">  			++size[now];</span><br><span class="line">        <span class="built_in">pushup</span>(now);<span class="built_in">pushup</span>(rt);</span><br><span class="line">        <span class="built_in">splay</span>(now,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      rt=now;</span><br><span class="line">      val[rt]&lt;v?now=rson:now=lson;</span><br><span class="line">    	<span class="built_in">pushdown</span>(now);</span><br><span class="line">      <span class="keyword">if</span>(!now)&#123;</span><br><span class="line">        now=<span class="built_in">newnode</span>(rt,v);</span><br><span class="line">  	    val[rt]&lt;v?rson=now:lson=now;</span><br><span class="line">        <span class="built_in">pushup</span>(rt);<span class="built_in">splay</span>(now,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除节点($delete_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_pos</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(size[rt]&gt;<span class="number">1</span>)&#123;--size[rt];<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> now;</span><br><span class="line">    <span class="keyword">if</span>(!lson||!rson)&#123;</span><br><span class="line">      now=rson+lson;<span class="built_in">pushdown</span>(now);</span><br><span class="line">      <span class="keyword">if</span>(!now)&#123;<span class="built_in">clean</span>(rt);root=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="built_in">clean</span>(rt);root=now;fa[now]=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">pushup</span>(now);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    now=<span class="built_in">pre_pos</span>(rt);</span><br><span class="line">    <span class="built_in">pushdown</span>(now);</span><br><span class="line">    <span class="built_in">splay</span>(now,rt);</span><br><span class="line">    fa[now]=<span class="number">0</span>;son[<span class="number">1</span>][now]=rson;fa[rson]=now;</span><br><span class="line">    root=now;<span class="built_in">clean</span>(rt);</span><br><span class="line">    <span class="built_in">pushup</span>(rson);<span class="built_in">pushup</span>(now);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除($Delete$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    v=<span class="built_in">QueryRank_pos</span>(v);</span><br><span class="line">    <span class="built_in">pushdown</span>(v);</span><br><span class="line">    <span class="built_in">delete_pos</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除第k($Delete_QueryRank$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete_QueryRank</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    v=<span class="built_in">Rank_pos</span>(v);</span><br><span class="line">    <span class="built_in">pushdown</span>(v);</span><br><span class="line">    <span class="built_in">delete_pos</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>区间修改（翻转）($revse$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">revse</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	a=<span class="built_in">find</span>(a);</span><br><span class="line">  	b=<span class="built_in">find</span>(b+<span class="number">2</span>);</span><br><span class="line">  	<span class="built_in">splay</span>(a,<span class="number">0</span>);<span class="built_in">splay</span>(b,a);</span><br><span class="line">  	lazy[son[<span class="number">0</span>][son[<span class="number">1</span>][root]]]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h2><ul>
<li>查找某个值的节点编号($QueryRank_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueryRank_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]==x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> rt;&#125; </span><br><span class="line">    	<span class="keyword">if</span>(val[rt]&lt;x)rt=rson;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(val[rt]&gt;x)rt=lson;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查找某个排名的节点编号($Rank_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rank_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> rt=root;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  	<span class="keyword">if</span>(sum[lson]&gt;=x)&#123;rt=lson;<span class="keyword">continue</span>;&#125;</span><br><span class="line">  	x-=sum[lson];</span><br><span class="line">    	<span class="keyword">if</span>(size[rt]&gt;=x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">    	x-=size[rt];</span><br><span class="line">    	rt=rson;</span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查找排名第k的值($QueryRank$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueryRank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(sum[lson]&gt;=x)&#123;rt=lson;<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	x-=sum[lson];</span><br><span class="line">    	<span class="keyword">if</span>(size[rt]&gt;=x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">    	x-=size[rt];</span><br><span class="line">    	rt=rson;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找某个值的排名($Rank$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rank</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]==num)&#123;ans=ans+sum[lson]+<span class="number">1</span>;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> ans;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(val[rt]&lt;num)ans+=sum[lson]+size[rt],rt=rson;</span><br><span class="line">     	<span class="keyword">else</span> <span class="keyword">if</span>(val[rt]&gt;num)rt=lson;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>集合内前驱的节点编号($pre_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(!(rt=son[<span class="number">0</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">while</span>(rson)<span class="built_in">pushdown</span>(rt),rt=rson;</span><br><span class="line">    <span class="keyword">return</span> rt;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>集合内后继的节点编号($nex_pos$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nex_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(!(rt=son[<span class="number">1</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">while</span>(lson)<span class="built_in">pushdown</span>(rt),rt=lson;</span><br><span class="line">    <span class="keyword">return</span> rt;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>集合内前驱的值($pre$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(!(rt=son[<span class="number">0</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">while</span>(rson)<span class="built_in">pushdown</span>(rt),rt=rson;</span><br><span class="line">    <span class="keyword">return</span> val[rt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>集合内后继的值($nex$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(!(rt=son[<span class="number">1</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">while</span>(lson)<span class="built_in">pushdown</span>(rt),rt=lson;</span><br><span class="line">    <span class="keyword">return</span> val[rt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>前驱($Numpre$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Numpre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Insert</span>(x);</span><br><span class="line">    <span class="type">int</span> y=x;x=<span class="built_in">QueryRank_pos</span>(x);</span><br><span class="line">    <span class="type">int</span> ls=<span class="built_in">pre</span>(x);</span><br><span class="line">    <span class="built_in">Delete</span>(y);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>后继($Numnex$)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Numnex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Insert</span>(x);</span><br><span class="line">    <span class="type">int</span> y=x;x=<span class="built_in">QueryRank_pos</span>(x);</span><br><span class="line">    <span class="type">int</span> ls=<span class="built_in">nex</span>(x);</span><br><span class="line">    <span class="built_in">Delete</span>(y);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查找某个值的节点编号($find$)，不改变结构<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> rt=root;</span><br><span class="line">  	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  		<span class="keyword">if</span>(sum[lson]&gt;=k)rt=lson;</span><br><span class="line">  		<span class="keyword">else</span> <span class="keyword">if</span>(sum[lson]+<span class="number">1</span>==k)<span class="keyword">return</span> rt;</span><br><span class="line">  		<span class="keyword">else</span> k-=sum[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="完整模板"><a href="#完整模板" class="headerlink" title="完整模板"></a>完整模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson son[0][rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson son[1][rt]</span></span><br><span class="line">	<span class="type">int</span> root,cnt;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">2</span>][N],sum[N],val[N],size[N],fa[N];</span><br><span class="line">  	<span class="type">bool</span> lazy[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  		<span class="keyword">if</span>(!lazy[rt])<span class="keyword">return</span>;</span><br><span class="line">  		lazy[lson]^=<span class="number">1</span>;lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">  		lazy[rt]=<span class="number">0</span>;</span><br><span class="line">  		<span class="built_in">swap</span>(lson,rson);</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">if</span>(!rt)<span class="keyword">return</span>;</span><br><span class="line">	  	sum[rt]=sum[lson]+sum[rson]+size[rt];</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	  	<span class="type">int</span> y=fa[x];<span class="type">int</span> z=fa[y];</span><br><span class="line">	  	<span class="type">int</span> k=son[<span class="number">1</span>][y]==x;</span><br><span class="line">	  	son[son[<span class="number">1</span>][z]==y][z]=x;</span><br><span class="line">	  	fa[x]=z;</span><br><span class="line">	  	son[k][y]=son[k^<span class="number">1</span>][x];</span><br><span class="line">	  	fa[son[k^<span class="number">1</span>][x]]=y;</span><br><span class="line">	  	son[k^<span class="number">1</span>][x]=y;</span><br><span class="line">	  	fa[y]=x;</span><br><span class="line">	  	<span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> goal)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line">	  		<span class="type">int</span> y=fa[x];<span class="type">int</span> z=fa[y];</span><br><span class="line">	  		<span class="keyword">if</span>(z!=goal)</span><br><span class="line">	  		(son[<span class="number">1</span>][z]==y)^(son[<span class="number">1</span>][y]==x)?<span class="built_in">rotate</span>(x):<span class="built_in">rotate</span>(y);</span><br><span class="line">	  		<span class="built_in">rotate</span>(x);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span>(goal==<span class="number">0</span>)root=x;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	    <span class="type">int</span> rt=++cnt;</span><br><span class="line">	    size[rt]=<span class="number">1</span>;sum[rt]=<span class="number">1</span>;val[rt]=v;</span><br><span class="line">	    fa[rt]=f;lson=rson=<span class="number">0</span>;lazy[rt]=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">return</span> rt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	    lson=rson=<span class="number">0</span>;fa[rt]=<span class="number">0</span>;</span><br><span class="line">	    val[rt]=<span class="number">0</span>;sum[rt]=size[rt]=<span class="number">0</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> &amp;rt,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span>;</span><br><span class="line">	  	<span class="type">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	  	rt=<span class="built_in">newnode</span>(f,a[mid]);</span><br><span class="line">	  	<span class="built_in">Build</span>(lson,L,mid<span class="number">-1</span>,rt);</span><br><span class="line">	  	<span class="built_in">Build</span>(rson,mid+<span class="number">1</span>,R,rt);</span><br><span class="line">	  	<span class="built_in">pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(!root)&#123;root=<span class="built_in">newnode</span>(<span class="number">0</span>,v);<span class="keyword">return</span>;&#125;</span><br><span class="line">    	<span class="type">int</span> now=root,rt=<span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">pushdown</span>(now);</span><br><span class="line">   		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      		<span class="keyword">if</span>(val[now]==v)&#123;</span><br><span class="line">	  			++size[now];</span><br><span class="line">	        	<span class="built_in">pushup</span>(now);<span class="built_in">pushup</span>(rt);</span><br><span class="line">	        	<span class="built_in">splay</span>(now,<span class="number">0</span>);</span><br><span class="line">	        	<span class="keyword">break</span>;</span><br><span class="line">	      	&#125;</span><br><span class="line">	      	rt=now;</span><br><span class="line">	      	val[rt]&lt;v?now=rson:now=lson;</span><br><span class="line">	    	<span class="built_in">pushdown</span>(now);</span><br><span class="line">	      	<span class="keyword">if</span>(!now)&#123;</span><br><span class="line">	        	now=<span class="built_in">newnode</span>(rt,v);</span><br><span class="line">	  	    	val[rt]&lt;v?rson=now:lson=now;</span><br><span class="line">	        	<span class="built_in">pushup</span>(rt);<span class="built_in">splay</span>(now,<span class="number">0</span>);</span><br><span class="line">	        	<span class="keyword">break</span>;</span><br><span class="line">	      	&#125;</span><br><span class="line">   	 	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">QueryRank_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="type">int</span> rt=root;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      		<span class="keyword">if</span>(val[rt]==x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> rt;&#125; </span><br><span class="line">      		<span class="keyword">if</span>(val[rt]&lt;x)rt=rson;</span><br><span class="line">      		<span class="keyword">else</span> <span class="keyword">if</span>(val[rt]&gt;x)rt=lson;</span><br><span class="line">    	&#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Rank_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      <span class="keyword">if</span>(sum[lson]&gt;=x)&#123;rt=lson;<span class="keyword">continue</span>;&#125;</span><br><span class="line">      x-=sum[lson];</span><br><span class="line">      <span class="keyword">if</span>(size[rt]&gt;=x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">      x-=size[rt];</span><br><span class="line">      rt=rson;</span><br><span class="line">    &#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">QueryRank</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="type">int</span> rt=root;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">     		<span class="keyword">if</span>(sum[lson]&gt;=x)&#123;rt=lson;<span class="keyword">continue</span>;&#125;</span><br><span class="line">     		x-=sum[lson];</span><br><span class="line">      		<span class="keyword">if</span>(size[rt]&gt;=x)&#123;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">      		x-=size[rt];</span><br><span class="line">      		rt=rson;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">Rank</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    	<span class="type">int</span> rt=root,ans=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">      		<span class="keyword">if</span>(val[rt]==num)&#123;ans=ans+sum[lson]+<span class="number">1</span>;<span class="built_in">splay</span>(rt,<span class="number">0</span>);<span class="keyword">return</span> ans;&#125;</span><br><span class="line">     		<span class="keyword">if</span>(val[rt]&lt;num)ans+=sum[lson]+size[rt],rt=rson;</span><br><span class="line">      		<span class="keyword">else</span> <span class="keyword">if</span>(val[rt]&gt;num)rt=lson;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">pre_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    	<span class="built_in">pushdown</span>(x);</span><br><span class="line">    	<span class="keyword">if</span>(!(rt=son[<span class="number">0</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    	<span class="keyword">while</span>(rson)<span class="built_in">pushdown</span>(rt),rt=rson;</span><br><span class="line">    	<span class="keyword">return</span> rt;	</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">nex_pos</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    	<span class="built_in">pushdown</span>(x);</span><br><span class="line">    	<span class="keyword">if</span>(!(rt=son[<span class="number">1</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    	<span class="keyword">while</span>(lson)<span class="built_in">pushdown</span>(rt),rt=lson;</span><br><span class="line">    	<span class="keyword">return</span> rt;	</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    	<span class="built_in">pushdown</span>(x);</span><br><span class="line">    	<span class="keyword">if</span>(!(rt=son[<span class="number">0</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    	<span class="keyword">while</span>(rson)<span class="built_in">pushdown</span>(rt),rt=rson;</span><br><span class="line">    	<span class="keyword">return</span> val[rt];</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">nex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(x,<span class="number">0</span>);<span class="type">int</span> rt;</span><br><span class="line">    	<span class="built_in">pushdown</span>(x);</span><br><span class="line">    	<span class="keyword">if</span>(!(rt=son[<span class="number">1</span>][x]))<span class="keyword">return</span> val[x];</span><br><span class="line">    	<span class="keyword">while</span>(lson)<span class="built_in">pushdown</span>(rt),rt=lson;</span><br><span class="line">    	<span class="keyword">return</span> val[rt];</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">delete_pos</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">splay</span>(rt,<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">if</span>(size[rt]&gt;<span class="number">1</span>)&#123;--size[rt];<span class="keyword">return</span>;&#125;</span><br><span class="line">    	<span class="type">int</span> now;</span><br><span class="line">    	<span class="keyword">if</span>(!lson||!rson)&#123;</span><br><span class="line">      		now=rson+lson;<span class="built_in">pushdown</span>(now);</span><br><span class="line">      		<span class="keyword">if</span>(!now)&#123;<span class="built_in">clean</span>(rt);root=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">      		<span class="built_in">clean</span>(rt);root=now;fa[now]=<span class="number">0</span>;</span><br><span class="line">      		<span class="built_in">pushup</span>(now);<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	now=<span class="built_in">pre_pos</span>(rt);</span><br><span class="line">    	<span class="built_in">pushdown</span>(now);</span><br><span class="line">    	<span class="built_in">splay</span>(now,rt);</span><br><span class="line">    	fa[now]=<span class="number">0</span>;son[<span class="number">1</span>][now]=rson;fa[rson]=now;</span><br><span class="line">    	root=now;<span class="built_in">clean</span>(rt);</span><br><span class="line">    	<span class="built_in">pushup</span>(rson);<span class="built_in">pushup</span>(now);	</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    	v=<span class="built_in">QueryRank_pos</span>(v);</span><br><span class="line">    	<span class="built_in">pushdown</span>(v);</span><br><span class="line">    	<span class="built_in">delete_pos</span>(v);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">Delete_QueryRank</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    	v=<span class="built_in">Rank_pos</span>(v);</span><br><span class="line">    	<span class="built_in">pushdown</span>(v);</span><br><span class="line">    	<span class="built_in">delete_pos</span>(v);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">Numpre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">Insert</span>(x);</span><br><span class="line">    	<span class="type">int</span> y=x;x=<span class="built_in">QueryRank_pos</span>(x);</span><br><span class="line">    	<span class="type">int</span> ls=<span class="built_in">pre</span>(x);</span><br><span class="line">    	<span class="built_in">Delete</span>(y);</span><br><span class="line">    	<span class="keyword">return</span> ls;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">Numnex</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="built_in">Insert</span>(x);</span><br><span class="line">    	<span class="type">int</span> y=x;x=<span class="built_in">QueryRank_pos</span>(x);</span><br><span class="line">    	<span class="type">int</span> ls=<span class="built_in">nex</span>(x);</span><br><span class="line">    	<span class="built_in">Delete</span>(y);</span><br><span class="line">    	<span class="keyword">return</span> ls;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  		<span class="type">int</span> rt=root;</span><br><span class="line">  		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  			<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  			<span class="keyword">if</span>(sum[lson]&gt;=k)rt=lson;</span><br><span class="line">  			<span class="keyword">else</span> <span class="keyword">if</span>(sum[lson]+<span class="number">1</span>==k)<span class="keyword">return</span> rt;</span><br><span class="line">  			<span class="keyword">else</span> k-=sum[lson]+<span class="number">1</span>,rt=rson;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">revse</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		a=<span class="built_in">find</span>(a);</span><br><span class="line">  		b=<span class="built_in">find</span>(b+<span class="number">2</span>);</span><br><span class="line">  		<span class="built_in">splay</span>(a,<span class="number">0</span>);<span class="built_in">splay</span>(b,a);</span><br><span class="line">  		lazy[son[<span class="number">0</span>][son[<span class="number">1</span>][root]]]^=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Spl;</span><br></pre></td></tr></table></figure>
<h2 id="两个模板题："><a href="#两个模板题：" class="headerlink" title="两个模板题："></a>两个模板题：</h2><ul>
<li><a href="https://www.luogu.org/problemnew/show/P3369">P3369 【模板】普通平衡树</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span>-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;Spl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">  	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    	<span class="type">int</span> opt=<span class="built_in">read</span>(),x=<span class="built_in">read</span>();</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;Spl.<span class="built_in">Insert</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;Spl.<span class="built_in">Delete</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Spl.<span class="built_in">Rank</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">4</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Spl.<span class="built_in">QueryRank</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">5</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Spl.<span class="built_in">Numpre</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span>(opt==<span class="number">6</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Spl.<span class="built_in">Numnex</span>(x));<span class="keyword">continue</span>;&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://www.luogu.org/problemnew/show/P3391">P3391 【模板】文艺平衡树（Splay）</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span>-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;Spl;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  	Spl.<span class="built_in">pushdown</span>(rt);</span><br><span class="line">  	<span class="keyword">if</span>(Spl.lson)<span class="built_in">write</span>(Spl.lson);</span><br><span class="line">  	<span class="keyword">if</span>(Spl.val[rt]&gt;<span class="number">1</span>&amp;&amp;Spl.val[rt]&lt;n+<span class="number">2</span>)</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Spl.val[rt]<span class="number">-1</span>);</span><br><span class="line">  	<span class="keyword">if</span>(Spl.rson)<span class="built_in">write</span>(Spl.rson); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++)a[i]=i;</span><br><span class="line"> 	Spl.<span class="built_in">Build</span>(Spl.root,<span class="number">1</span>,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"> 	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    	<span class="type">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">  		Spl.<span class="built_in">revse</span>(l,r);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="built_in">write</span>(Spl.root);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>关于DP的优化</title>
    <url>/2018/12/29/%E5%85%B3%E4%BA%8EDP%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$动态规划及其相优化方法的复习笔记：</p>
<span id="more"></span>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>$\ \ \ \ \ \ \,$很多时候我们的dp式子如下形式，是一个递推形式$f_{(m,n)}$：</p>
<p>$f_{(i,j)}=a_{(1,j)}\cdot f_{(i-1,1)}+a_{(2,j)}\cdot f_{(i-1,2)}+\cdots+a_{(n,j)}\cdot f_{(i-1,n)}$</p>
<p>$\ \ \ \ \ \ \,$显然，若是$a_{(i,j)}$参数确定,复杂度也是$O(mn^2)$的，多数情况下不会达到这个复杂度，但是也是接受不了的，有些题目$m$给的特别大，$n$比较小，我们就考虑矩阵优化：</p>
<p>$\ \ \ \ \ \ \,$首先设定初始矩阵$A$，也就是原dp式子的初始化项：</p>
<p>$A= \begin{bmatrix} f_{(0,1)} &amp; f_{(0,2)} &amp; \cdots &amp; f_{(0,n)}\\ \end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$然后设定转移矩阵$B$：</p>
<p>$B= \begin{bmatrix} a_{(1,1)} &amp; a_{(1,2)} &amp; \cdots &amp; a_{(1,n)}\\a_{(2,1)} &amp; a_{(2,2)} &amp; \cdots &amp; a_{(2,n)}\\\vdots\\a_{(n,1)} &amp; a_{(n,2)} &amp; \cdots &amp; a_{(n,n)}\\ \end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$根据矩阵乘法的定义，很容易得到：</p>
<p>$A\times B=\begin{bmatrix} f_{(1,1)} &amp; f_{(1,2)} &amp; \cdots &amp; f_{(1,n)}\\ \end{bmatrix}$</p>
<p>$\ \ \ \ \ \ \,$推广得到：</p>
<p>$A\times B^m=\begin{bmatrix} f_{(m,1)} &amp; f_{(m,2)} &amp; \cdots &amp; f_{(m,n)}\\ \end{bmatrix}$</p>
<p>$\ \ \ \ \ \ \,$根据矩阵乘法满足交换律，所以我们可以先算出$B^m$，再$A$乘之，即可得到答案，矩阵快速幂如下，复杂度优化到$O(\log m \cdot n^3)$：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;<span class="type">int</span> n,m,a[N][N];&#125;;</span><br><span class="line"><span class="keyword">inline</span> matrix <span class="keyword">operator</span> *(<span class="type">const</span> matrix &amp;a,<span class="type">const</span> matrix &amp;b)&#123;</span><br><span class="line">	matrix ret;ret.n=a.n;ret.m=b.m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a.n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.m;j++)&#123;</span><br><span class="line">	  ret.a[i][j]=<span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a.m;k++)</span><br><span class="line">	  ret.a[i][j]+=a.a[i][k]*b.a[k][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> matrix <span class="title">power</span><span class="params">(matrix A,matrix B,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;m;m&gt;&gt;=<span class="number">1</span>,B=B*B)<span class="keyword">if</span>(m&amp;<span class="number">1</span>)A=A*B;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P1349-广义斐波那契数列"><a href="#P1349-广义斐波那契数列" class="headerlink" title="P1349 广义斐波那契数列"></a><a href="https://www.luogu.org/problemnew/show/P1349">P1349 广义斐波那契数列</a></h3><p>$\ \ \ \ \ \ \,$模板题目，递推式是：</p>
<p>$a_{n}=p\cdot a_{(n-1)}+q\cdot a_{(n-2)}$</p>
<p>$\ \ \ \ \ \ \,$所以我们令：</p>
<p>$f_{i,2}=[a_{i-1},a_{i}]$</p>
<p>$\ \ \ \ \ \ \,$那么有：</p>
<p>$f_{(i,1)}=0\cdot f_{(i-1,1)}+1\cdot f_{(i-1,2)}$</p>
<p>$f_{(i,2)}=p\cdot f_{(i-1,1)}+q\cdot f_{(i-1,2)}$</p>
<p>$\ \ \ \ \ \ \,$所以我们把$A$，$B$矩阵设置为：</p>
<p>$A= \begin{bmatrix} a_{1} &amp; a_{2} \end{bmatrix} $</p>
<p>$B= \begin{bmatrix} 0 &amp; q\\1 &amp;p \end{bmatrix} $</p>
<p>$\ \ \ \ \ \ \,$那么我们的答案就在$A\times B^{n-2}$的第二项。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m;</span><br><span class="line"><span class="type">int</span> p,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;<span class="type">int</span> n,m;<span class="type">long</span> <span class="type">long</span> a[N][N];&#125;A,B;</span><br><span class="line"><span class="keyword">inline</span> matrix <span class="keyword">operator</span> *(<span class="type">const</span> matrix &amp;a,<span class="type">const</span> matrix &amp;b)&#123;</span><br><span class="line">	matrix ret;ret.n=a.n;ret.m=b.m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a.n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.m;j++)&#123;</span><br><span class="line">	  ret.a[i][j]=<span class="number">0ll</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a.m;k++)</span><br><span class="line">	  ret.a[i][j]=(ret.a[i][j]+a.a[i][k]*b.a[k][j]%m)%m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> matrix <span class="title">power</span><span class="params">(matrix A,matrix B,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;m;m&gt;&gt;=<span class="number">1</span>,B=B*B)<span class="keyword">if</span>(m&amp;<span class="number">1</span>)A=A*B;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A.n=<span class="number">1</span>;A.m=B.m=B.n=<span class="number">2</span>;</span><br><span class="line">	p=<span class="built_in">read</span>();q=<span class="built_in">read</span>();</span><br><span class="line">	A.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">read</span>();A.a[<span class="number">1</span>][<span class="number">2</span>]=<span class="built_in">read</span>();</span><br><span class="line">	B.a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;B.a[<span class="number">1</span>][<span class="number">2</span>]=q;</span><br><span class="line">	B.a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;B.a[<span class="number">2</span>][<span class="number">2</span>]=p;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	A=<span class="built_in">power</span>(A,B,n<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,A.a[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>$\ \ \ \ \ \ \,$对于一个dp转移方程式，其中取最小或最大：</p>
<p>$f_{i}={\rm solve}(i,j)[l&lt;j&lt;r]$</p>
<p>$\ \ \ \ \ \ \,$若是可以化成如下形式：</p>
<p>$f_(i)=F(j)+g(i)[l&lt;j&lt;r]$</p>
<p>$\ \ \ \ \ \ \,$既 $j$ 造成的贡献与 $i$ 没有关系，并且 $j$ 造成的贡献我们需要取最大或者最小时，并且范围$[l&lt;j&lt;r]$有单调性时，我们可以利用单调队列来优化dp，从$O(n^2)$优化到$O(n)$。</p>
<p>$\ \ \ \ \ \ \,$核心想法是，建立一个容器，我们把 $F(j)$ 造成的贡献按照单调性加入该容器，若是现在需要新加入一个元素，那么就从队尾开始，把比他造成贡献不优的踢出去（原dp取 $\rm Min$ 的话就是需要 $F(j)$ 比队尾小，反之就是要大）。</p>
<p>$\ \ \ \ \ \ \,$当然这个时候队首将会是最优秀的 $j$，不过我们的范围限制还可能单调变化，于是我们又需要把队首那些范围不对的都踢掉，于是现在队首就是我们要的 $j$ 了，带入原dp即可。</p>
<p>$\ \ \ \ \ \ \,$由于所有元素都最多进入容器一次，又最多被踢一次，所以复杂度是$O(n)$的，模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> q=<span class="number">1</span>,p=<span class="number">0</span>,Q[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i--)&#123;</span><br><span class="line">  <span class="keyword">while</span>(q&lt;=p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">F</span>(i),<span class="built_in">F</span>(Q[p])))p--;</span><br><span class="line">  Q[++p]=i;</span><br><span class="line">  <span class="keyword">while</span>(q&lt;=p&amp;&amp;!<span class="built_in">in_lim</span>(i,Q[q]))q++;</span><br><span class="line">  <span class="keyword">if</span>(q&lt;=p)f[i]=<span class="built_in">F</span>(Q[q])+<span class="built_in">g</span>(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P2569-SCOI2010-股票交易"><a href="#P2569-SCOI2010-股票交易" class="headerlink" title="P2569 [SCOI2010]股票交易"></a><a href="https://www.luogu.org/problemnew/show/P2569">P2569 [SCOI2010]股票交易</a></h3><p>$\ \ \ \ \ \ \,$这题显然会有一个dp方程，$f_{(i,j)}$表示在第$i$天手里有$j$张股票的最大收益：</p>
<ul>
<li><p>直接购买：</p>
<p>$f_{(i,j)}=-aP_i\times j[0\leq j\leq aS_i]$</p>
</li>
<li><p>不行动：</p>
<p>$f_{(i,j)}=f_{(i-1,j)}$</p>
</li>
<li><p>买入：</p>
<p>$f_{(i,j)}={\rm Max}_{k=j-aS_i}^{j-1}\left(f_{(i-w-1,k)}-(j-k)\times aP_i\right)$</p>
</li>
<li><p>卖出：</p>
<p>$f_{(i,j)}={\rm Max}_{k=j+1}^{j+bS_i}\left(f_{(i-w-1,k)}+(k-j)\times bP_i\right)$</p>
</li>
</ul>
<p>$\ \ \ \ \ \ \,$复杂度为$O(n^3)$，主要是后面两个操作花时间了，所幸，后面两个都可以斜率优化，复杂度优化为$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> n,m,w;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> aP[N],bP[N],aS[N],bS[N];</span><br><span class="line"><span class="type">int</span> q,p,Q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	aP[i]=<span class="built_in">read</span>(),bP[i]=<span class="built_in">read</span>(),</span><br><span class="line">	aS[i]=<span class="built_in">read</span>(),bS[i]=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">memset</span>(f,<span class="number">128</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=aS[i];j++)f[i][j]=-j*aP[i];</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j]);</span><br><span class="line">  	<span class="keyword">if</span>(i&lt;=w)<span class="keyword">continue</span>;</span><br><span class="line">    q=<span class="number">1</span>,p=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">while</span>(q&lt;=p&amp;&amp;f[i-w<span class="number">-1</span>][Q[p]]+Q[p]*aP[i]&lt;=f[i-w<span class="number">-1</span>][j]+j*aP[i])p--;</span><br><span class="line">      Q[++p]=j;</span><br><span class="line">      <span class="keyword">while</span>(q&lt;=p&amp;&amp;Q[q]&lt;j-aS[i])q++;</span><br><span class="line">      <span class="keyword">if</span>(q&lt;=p)f[i][j]=<span class="built_in">max</span>(f[i][j],f[i-w<span class="number">-1</span>][Q[q]]+(Q[q]-j)*aP[i]); </span><br><span class="line">    &#125;</span><br><span class="line">	  q=<span class="number">1</span>,p=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">      <span class="keyword">while</span>(q&lt;=p&amp;&amp;f[i-w<span class="number">-1</span>][Q[p]]+Q[p]*bP[i]&lt;=f[i-w<span class="number">-1</span>][j]+j*bP[i])p--;</span><br><span class="line">      Q[++p]=j;</span><br><span class="line">      <span class="keyword">while</span>(q&lt;=p&amp;&amp;Q[q]&gt;j+bS[i])q++;</span><br><span class="line">      <span class="keyword">if</span>(q&lt;=p)f[i][j]=<span class="built_in">max</span>(f[i][j],f[i-w<span class="number">-1</span>][Q[q]]+(Q[q]-j)*bP[i]); </span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)ans=<span class="built_in">max</span>(ans,f[n][i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>$\ \ \ \ \ \ \,$对于一个dp式子，我们尝试将它化成3个部分：</p>
<ul>
<li>只与 $i$ 有关的（$A_i$）；</li>
<li>只与 $j$ 有关的（$D_j$）；</li>
<li>与 $i$ 和 $j$ 同时有关的（$B_i\cdot C_j$）；</li>
</ul>
<p>$\ \ \ \ \ \ \,$所以我们会得到形如这样子的式子：</p>
<p>${B_i}\cdot C_j+{A_i}={D_j}$</p>
<p>$\ \ \ \ \ \ \,$那么这个时候，我们把$B_i$当做斜率，$C_j$是横坐标，$D_j$是纵坐标，我们想要的是$A_i$最大或者是最小，那么答案一定是下面的那一层点里面诞生，需要满足的是：</p>
<ul>
<li><p>两个点之间的斜率必须优于$B_i$，若是取$\rm Max$就是需要大于，否者就是小于。</p>
</li>
<li><p>最优的$j$取值一定是斜率尽量优的。</p>
</li>
</ul>
<p>$\ \ \ \ \ \ \,$那么我们的想法是维护这个斜率组成的凸壳，若是$B_i$单调，我们可以考虑单调队列，若是不单调，那么我们在单调队列的基础上面，就不能从队首踢，就是维护一整个凸壳，每次询问在上面二分。</p>
<p>$\ \ \ \ \ \ \,$下面给出单调队列版的模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Q[N],q,p;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">Slope</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;<span class="comment">//B(i)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">X</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;<span class="comment">//C(j)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> j)</span></span>&#123;&#125;<span class="comment">//D(j)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">X</span>(i)==<span class="built_in">X</span>(j))<span class="keyword">return</span> <span class="number">1.0</span>*inf;<span class="comment">//max_inf,min_-inf;</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span>*(<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j)))/(<span class="number">1.0</span>*(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q=p=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">slope</span>(Q[q],Q[q+<span class="number">1</span>]),Slope))++q;</span><br><span class="line">		f[i]=<span class="built_in">F</span>(Q[q]);<span class="comment">//原dp方程</span></span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">slope</span>(i,Q[p<span class="number">-1</span>]),<span class="built_in">slope</span>(Q[p],Q[p<span class="number">-1</span>])))--p;</span><br><span class="line">		Q[++p]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P3195-HNOI2008-玩具装箱TOY"><a href="#P3195-HNOI2008-玩具装箱TOY" class="headerlink" title="P3195 [HNOI2008]玩具装箱TOY"></a><a href="https://www.luogu.org/problemnew/show/P3195">P3195 [HNOI2008]玩具装箱TOY</a></h3><p>$\ \ \ \ \ \ \,$本题dp方程如下：</p>
<p>$f_i={\rm Min}_{j=1}^{i-1}\left(f_j+(Sum_i-Sum_j+i-j-L-1)^2\right)$</p>
<p>$\ \ \ \ \ \ \,$化成如下形式：</p>
<p>${2\times(Sum_i+i)}(Sum_j+j+L+1)+{\left(f_i-(Sum_i+i)^2\right)}={\left(f_j+(Sum_j+j+L+1)^2\right)}$</p>
<p>$\ \ \ \ \ \ \,$我们发现${2\times(Sum_i+i)}$是单调的，于是我们想用单调队列来维护这个凸壳：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="type">double</span> f[N],sum[N],L;</span><br><span class="line"><span class="type">int</span> q,p,Q[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> sum[i]+(<span class="type">double</span>)i;&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">X</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fn</span>(i)+L;&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> f[i]+(<span class="built_in">fn</span>(i)+L)*(<span class="built_in">fn</span>(i)+L);&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> (<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j))/(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j));&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=(<span class="type">int</span>)<span class="built_in">read</span>();L=(<span class="type">double</span>)<span class="built_in">read</span>()+<span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	sum[i]=(<span class="type">double</span>)<span class="built_in">read</span>(),sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">	q=p=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">slope</span>(Q[q],Q[q+<span class="number">1</span>])&lt;<span class="number">2</span>*<span class="built_in">fn</span>(i))++q;</span><br><span class="line">		f[i]=f[Q[q]]+(<span class="built_in">fn</span>(i)-<span class="built_in">fn</span>(Q[q])-L)*(<span class="built_in">fn</span>(i)-<span class="built_in">fn</span>(Q[q])-L);</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">slope</span>(i,Q[p<span class="number">-1</span>])&lt;<span class="built_in">slope</span>(Q[p<span class="number">-1</span>],Q[p])) --p;</span><br><span class="line">    	Q[++p]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="WQS二分"><a href="#WQS二分" class="headerlink" title="WQS二分"></a>WQS二分</h2><p>$\ \ \ \ \ \ \,$WQS二分和斜率优化很相似，多了一个宽度限制，既需要干好取$m$个。和斜率优化一样，我们需要把式子化成下面的形式：</p>
<p>${B_i}\cdot C_j+{A_i}={D_j}$</p>
<p>$\ \ \ \ \ \ \,$在二分之前，我们二分一个特殊的值 $v$，取$k$个物品时，总贡献会多$kv$，在进行dp的同时，若$v$越大，取的物品越少，那么我们检查在$v$，的时候有多少个物品被选就好了，<strong>注意使用WQS二分需要满足$v$越大，取的物品越少</strong>，既需要满足取$x$个时的总贡献斜率不增，说白了，就是需要满足选的越多越好。</p>
<p>$\ \ \ \ \ \ \,$模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Q[N],q,p;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">Slope</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;<span class="comment">//B(i)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">X</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;<span class="comment">//C(j)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> j)</span></span>&#123;&#125;<span class="comment">//D(j)</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">X</span>(i)==<span class="built_in">X</span>(j))<span class="keyword">return</span> <span class="number">1.0</span>*inf;<span class="comment">//max_inf,min_-inf;</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span>*(<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j)))/(<span class="number">1.0</span>*(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cheak</span><span class="params">(<span class="type">long</span> <span class="type">long</span> v)</span></span>&#123;</span><br><span class="line">	q=p=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">slope</span>(Q[q],Q[q+<span class="number">1</span>]),Slope))++q;</span><br><span class="line">		f[i]=<span class="built_in">F</span>(Q[q])+v;<span class="comment">//原dp方程</span></span><br><span class="line">		tot[i]=tot[Q[q]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">better</span>(<span class="built_in">slope</span>(i,Q[p<span class="number">-1</span>]),<span class="built_in">slope</span>(Q[p],Q[p<span class="number">-1</span>])))--p;</span><br><span class="line">		Q[++q]=i;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> tot[n]&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cheak</span>(mid))r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cheak</span>(l);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]-l*m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4983-忘情"><a href="#P4983-忘情" class="headerlink" title="P4983 忘情"></a><a href="https://www.luogu.org/problemnew/show/P4983">P4983 忘情</a></h3><p>$\ \ \ \ \ \ \,$这个题是我们团队准备的，原式是来恶心人的，化简下来就是这个东西：</p>
<p>$\left(\sum_{i=1}^nx_i+1\right)^2$</p>
<p>$\ \ \ \ \ \ \,$dp方程显然就是这个东西：</p>
<p>$f_i={\rm Min}_{j=1}^{i-1}f_j+\left(Sum_i-Sum_j+1\right)^2$</p>
<p>$\ \ \ \ \ \ \,$化成如下形式：</p>
<p>${2\times Sum_i}\cdot Sum_j+{\left(f_i-(Sum_i+1)^2\right)}={f_j+Sum_j^2-2\times Sum_j}$</p>
<p>$\ \ \ \ \ \ \,$感性思考一下，当$m$越大，答案一定小越小，那么我们就可以使用WQS二分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,tot[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[N],f[N],Q[N];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">X</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> sum[a];&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> f[a]+sum[a]*sum[a]<span class="number">-2ll</span>*sum[a];&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solpe</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> <span class="number">1.0</span>*(<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j))/(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j));&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cheak</span><span class="params">(<span class="type">long</span> <span class="type">long</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> q=<span class="number">1</span>,p=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  	<span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">solpe</span>(Q[q+<span class="number">1</span>],Q[q])&lt;<span class="number">2.0</span>*sum[i])q++;</span><br><span class="line">    f[i]=f[Q[q]]+(sum[i]-sum[Q[q]]+<span class="number">1</span>)*(sum[i]-sum[Q[q]]+<span class="number">1</span>)+v;</span><br><span class="line">		tot[i]=tot[Q[q]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q&lt;p&amp;&amp;<span class="built_in">solpe</span>(i,Q[p])&lt;<span class="built_in">solpe</span>(Q[p<span class="number">-1</span>],Q[p]))p--;</span><br><span class="line">    Q[++p]=i;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> tot[n]&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[i]=sum[i<span class="number">-1</span>]+<span class="number">1ll</span>*<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> l=<span class="number">1</span>,r=(sum[n]*sum[n])/<span class="number">2</span>,mid;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cheak</span>(mid))r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cheak</span>(l);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]-l*m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>动态规划</tag>
        <tag>矩阵乘法</tag>
        <tag>单调队列</tag>
        <tag>斜率优化</tag>
        <tag>WQS二分</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P4883 mzf的考验 简易题解【fhq treap】</title>
    <url>/2019/03/12/%E6%B4%9B%E8%B0%B7-P4883-mzf%E7%9A%84%E8%80%83%E9%AA%8C-%E7%AE%80%E6%98%93%E9%A2%98%E8%A7%A3-fhq-treap/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.org/problemnew/show/P4883">洛谷 P4883 mzf的考验</a></p>
<span id="more"></span>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><hr>
<p>$\ \ \ \ \ \ \,$首先我们看他的操作：</p>
<ul>
<li>$opt==1$：两个正整数：$l$，$r$。请翻转区间$[l,r]$；</li>
<li>$opt==2$：三个正整数：$l$，$r$，$d$。请将区间$[l,r]$中的所有卦象都异或卦象$d$;</li>
<li>$opt==3$：两个正整数：$l$，$r$。请查询区间$[l,r]$的卦象权值和。</li>
</ul>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$\ \ \ \ \ \ \,$显然是一个平衡树可以做的啦，我们试着选择$Fhq_treap$ 做一下：</p>
<p>$\ \ \ \ \ \ \,$对于操作 $1$，$3$ 操作很简单，我们 $pushup$ 一下子树和， $pushdown$ 一下旋转标记，提出区间 $[l,r]$ 进行对应的操作就可以了。</p>
<p>$\ \ \ \ \ \ \,$那么对应的 $2$ 操作似乎没有那么简单操作了，我们先看看我们需要修改的 $pushdown$ 操作是什么：</p>
<ol>
<li>单点权值$(val)$：直接异或上修改的值，在$pushdown$操作的时候同理。</li>
<li>权值懒人标记$(lazy_w)$：直接异或上修改的值，在$pushdown$操作的时候同理。</li>
<li>子树和$(sum)$：？</li>
</ol>
<p>$\ \ \ \ \ \ \,$可以发现子树和的处理特别麻烦，但是对于异或问题，我们通常可以拆位解决，对于每一个节点，我们新开一个数组 $num[i]$ ，表示这个子树内的值，数位 $i$ 上面为 $1$ 的值是多少，这个很显然，我们可以通过 $pushup$ 一并传递上去。</p>
<p>$\ \ \ \ \ \ \,$如何处理子树和呢？因为打了标记的子树都要异或这一个值，所以我们把这个值拆了，如果这一位为 $1$ ，那么子树这一位都会 $1$变$0$，$0$变$1$，所以说有：</p>
<p>$num[i]=size-num[i]$</p>
<p>$\ \ \ \ \ \ \,$其中$size$为子树大小，修改了$num$数组之后，我们就可以重新计算子树和了：</p>
<p>$sum=\sum_{i=0}^{limit}2^i\times num[i]$</p>
<p>$\ \ \ \ \ \ \,$所以 $pushup$ 和 $pushdown$ 差不多应该是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Xor</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	lazy_w[rt]^=x;val[rt]^=x;</span><br><span class="line">    sum[rt]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)tmp[i]=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(tmp[i])num[rt][i]=size[rt]-num[rt][i];</span><br><span class="line">      	sum[rt]+=(<span class="number">1ll</span>&lt;&lt;i)*num[rt][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">	sum[rt]=sum[lson]+sum[rson]+<span class="number">1ll</span>*val[rt];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">	num[rt][i]=num[lson][i]+num[rson][i]+((val[rt]&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lazy[rt])&#123;</span><br><span class="line">		<span class="built_in">swap</span>(lson,rson);</span><br><span class="line">		<span class="keyword">if</span>(lson)lazy[lson]^=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(rson)lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">		lazy[rt]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lazy_w[rt])&#123;</span><br><span class="line">		<span class="type">int</span> x=lazy_w[rt];lazy_w[rt]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(lson)&#123;<span class="built_in">Xor</span>(lson,x);&#125;</span><br><span class="line">		<span class="keyword">if</span>(rson)&#123;<span class="built_in">Xor</span>(rson,x);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$总期望复杂度应该是$O(n\log n\ limit)$，其中$limit=\log val$</p>
<p>$\ \ \ \ \ \ \,$懒得卡常了，吸氧过：</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_treap</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">	<span class="type">int</span> ls[N],rs[N];</span><br><span class="line">	<span class="type">bool</span> lazy[N];</span><br><span class="line">	<span class="type">int</span> lazy_w[N],val[N],key[N],size[N];</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum[N];</span><br><span class="line">	<span class="type">int</span> root,cnt;</span><br><span class="line">	<span class="type">int</span> tmp[<span class="number">25</span>],num[N][<span class="number">25</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Xor</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		lazy_w[rt]^=x;val[rt]^=x;</span><br><span class="line">    	sum[rt]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)tmp[i]=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">  		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line">      		<span class="keyword">if</span>(tmp[i])num[rt][i]=size[rt]-num[rt][i];</span><br><span class="line">      		sum[rt]+=(<span class="number">1ll</span>&lt;&lt;i)*num[rt][i];</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		size[rt]=size[lson]+size[rson]+<span class="number">1</span>;</span><br><span class="line">		sum[rt]=sum[lson]+sum[rson]+<span class="number">1ll</span>*val[rt];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">		num[rt][i]=num[lson][i]+num[rson][i]+((val[rt]&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lazy[rt])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(lson,rson);</span><br><span class="line">			<span class="keyword">if</span>(lson)lazy[lson]^=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(rson)lazy[rson]^=<span class="number">1</span>;</span><br><span class="line">			lazy[rt]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(lazy_w[rt])&#123;</span><br><span class="line">			<span class="type">int</span> x=lazy_w[rt];lazy_w[rt]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(lson)&#123;<span class="built_in">Xor</span>(lson,x);&#125;</span><br><span class="line">			<span class="keyword">if</span>(rson)&#123;<span class="built_in">Xor</span>(rson,x);&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!a||!b)<span class="keyword">return</span> a|b;</span><br><span class="line">		<span class="keyword">if</span>(key[a]&lt;key[b])&#123;<span class="built_in">pushdown</span>(a);rs[a]=<span class="built_in">merge</span>(rs[a],b);<span class="built_in">pushup</span>(a);<span class="keyword">return</span> a;&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="built_in">pushdown</span>(b);ls[b]=<span class="built_in">merge</span>(a,ls[b]);<span class="built_in">pushup</span>(b);<span class="keyword">return</span> b;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!rt)&#123;a=b=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="built_in">pushdown</span>(rt);</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=size[lson])&#123;b=rt;<span class="built_in">split</span>(lson,x,a,lson);&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;a=rt;<span class="built_in">split</span>(rson,x-size[lson]<span class="number">-1</span>,rson,b);&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> rt=++cnt;</span><br><span class="line">		size[rt]=<span class="number">1</span>;val[rt]=x;key[rt]=<span class="built_in">rand</span>();</span><br><span class="line">		lazy[rt]=<span class="number">0</span>;lazy_w[rt]=<span class="number">0</span>;</span><br><span class="line">		lson=rson=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> rt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">		stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">		<span class="type">int</span> rt,last;</span><br><span class="line">	  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">	    rt=<span class="built_in">newnode</span>(a[i]);last=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>()&amp;&amp;key[S.<span class="built_in">top</span>()]&gt;key[rt])</span><br><span class="line">			<span class="built_in">pushup</span>(last=S.<span class="built_in">top</span>()),S.<span class="built_in">pop</span>();</span><br><span class="line">	    	<span class="keyword">if</span>(!S.<span class="built_in">empty</span>())rs[S.<span class="built_in">top</span>()]=rt;</span><br><span class="line">	    	lson=last;S.<span class="built_in">push</span>(rt);</span><br><span class="line">	  	&#125;</span><br><span class="line">	  	<span class="keyword">while</span>(!S.<span class="built_in">empty</span>())<span class="built_in">pushup</span>(last=S.<span class="built_in">top</span>()),S.<span class="built_in">pop</span>();</span><br><span class="line">	  	<span class="keyword">return</span> last; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Revers</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">split</span>(root,r,a,c);</span><br><span class="line">		<span class="built_in">split</span>(a,l<span class="number">-1</span>,a,b);</span><br><span class="line">		lazy[b]^=<span class="number">1</span>;</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">split</span>(root,r,a,c);</span><br><span class="line">		<span class="built_in">split</span>(a,l<span class="number">-1</span>,a,b);</span><br><span class="line">		<span class="built_in">Xor</span>(b,d);</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">split</span>(root,r,a,c);</span><br><span class="line">		<span class="built_in">split</span>(a,l<span class="number">-1</span>,a,b);</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> ret=sum[b];</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Tree;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],op,l,r,d;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">	Tree.root=Tree.<span class="built_in">build</span>(a,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		op=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)Tree.<span class="built_in">Revers</span>(l,r);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>)d=<span class="built_in">read</span>(),Tree.<span class="built_in">Update</span>(l,r,d);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">3</span>)cout&lt;&lt;Tree.<span class="built_in">Query</span>(l,r)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Fhq_Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>树分治</title>
    <url>/2019/01/03/%E6%A0%91%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$关于树分治的复习笔记：</p>
<span id="more"></span>
<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p>$\ \ \ \ \ \ \ \,$树链剖分也叫轻重链剖分，一般会套一个线段树，相当于一个优化过的DFS序，用每次优先遍历重儿子达到优化目的，常用于处理：</p>
<ol>
<li><p>关于两点间路径的询问和修改（$O(n\log^2n)$）</p>
</li>
<li><p>关于某点子树的询问和修改（$O(n\log n)$），这里只用到了DFS序。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree_Chain_Dissection</span>&#123;</span><br><span class="line">	<span class="type">int</span> idx[N],w[N];</span><br><span class="line">	<span class="type">int</span> deep[N],fa[N],son[N],tot[N];</span><br><span class="line">	<span class="type">int</span> cnt,top[N];</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> f,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">	  deep[a]=deep[fa[a]=f]+<span class="number">1</span>;tot[a]=<span class="number">1</span>;</span><br><span class="line">	  <span class="type">int</span> maxson=<span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[a])</span><br><span class="line">	  <span class="keyword">if</span>(v!=f)&#123;</span><br><span class="line">	    tot[a]+=<span class="built_in">dfs1</span>(v,a,dep+<span class="number">1</span>);</span><br><span class="line">	    <span class="keyword">if</span>(tot[v]&gt;maxson) </span><br><span class="line">	    maxson=tot[v],son[a]=v;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> tot[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">	  v[idx[a]=++cnt]=w[a];top[a]=topf;</span><br><span class="line">	  <span class="keyword">if</span>(!son[a])<span class="keyword">return</span>;</span><br><span class="line">	  <span class="built_in">dfs2</span>(son[a],topf);</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[a])</span><br><span class="line">	  <span class="keyword">if</span>(!idx[v])<span class="built_in">dfs2</span>(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 	<span class="built_in">dfs1</span>(rt,<span class="number">0</span>,<span class="number">1</span>);<span class="built_in">dfs2</span>(rt,rt);</span><br><span class="line">	  Seg.<span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Query_Chain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//满足交换律</span></span><br><span class="line">	  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">	    <span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">	    ans=(ans+Seg.<span class="built_in">query</span>(idx[top[x]],idx[x],<span class="number">1</span>,n,<span class="number">1</span>))%mod;</span><br><span class="line">	    x=fa[top[x]];</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span>(deep[x]&gt;deep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">	  ans=(ans+Seg.<span class="built_in">query</span>(idx[x],idx[y],<span class="number">1</span>,n,<span class="number">1</span>))%mod;</span><br><span class="line">	  <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Updata_Chain</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	  <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">	    <span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	    Seg.<span class="built_in">updata</span>(idx[top[x]],idx[x],val,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	    x=fa[top[x]];</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">if</span>(deep[x]&gt;deep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	  Seg.<span class="built_in">updata</span>(idx[x],idx[y],val,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Query_Tree</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;<span class="keyword">return</span> Seg.<span class="built_in">query</span>(idx[x],idx[x]+tot[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Updata_Tree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;Seg.<span class="built_in">updata</span>(idx[x],idx[x]+tot[x]<span class="number">-1</span>,val,<span class="number">1</span>,n,<span class="number">1</span>);&#125;</span><br><span class="line">&#125;TCD;</span><br></pre></td></tr></table></figure>
<h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><p>$\ \ \ \ \ \ \ \,$点分治是一种分治策略，其核心在于寻找树的重心，从重心分治解决，从而优化复杂度，实现的$O(n\log n)$分治复杂度，算上分治的操作可能复杂度会更高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> K,root,sum;</span><br><span class="line"><span class="type">int</span> f[N],size[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  size[u]=<span class="number">1</span>;f[u]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[v]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">getroot</span>(v,u);</span><br><span class="line">    size[u]+=size[v];</span><br><span class="line">    f[u]=<span class="built_in">max</span>(f[u],size[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  f[u]=<span class="built_in">max</span>(f[u],sum-size[u]);</span><br><span class="line">  <span class="keyword">if</span>(f[u]&lt;f[root]) root=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="comment">//something</span></span><br><span class="line">  used[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])</span><br><span class="line">  <span class="keyword">if</span>(!used[v])&#123;</span><br><span class="line">    root=<span class="number">0</span>;sum=size[v];</span><br><span class="line">    <span class="built_in">getroot</span>(v,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getans</span>(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$顺带一提动态点分治（点分树），只需要把重儿子重新连在一个图里，这样子我们会得到一个类似于二叉树的新树，每次修改操作的影响我们可以暴力上传，复杂度为$O(n\log n)$，算上细节的操作可能复杂度会更高。</p>
<h2 id="边分治"><a href="#边分治" class="headerlink" title="边分治"></a>边分治</h2><p>$\ \ \ \ \ \ \ \,$边分治的思想是把一棵树每次找到一个边，使得去掉这个边后，留下的两棵树尽量一样大（重边），分治下去，使得复杂度降至$O(n\log n)$分治复杂度，算上分治的操作可能复杂度会更高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> size[N],ctedge,sum;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getctedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  size[u]=<span class="number">1</span>;f[u]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[G[i].v]||G[i].v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">getctedge</span>(G[i].v,u);</span><br><span class="line">    size[u]+=size[G[i].v];</span><br><span class="line">  	<span class="type">int</span> siz=<span class="built_in">max</span>(size[G[i].v],sum-size[G[i].v]);</span><br><span class="line">    <span class="keyword">if</span>(siz&lt;ctsiz)ctsiz=siz,ctedge=i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="comment">//something</span></span><br><span class="line">  used[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">  <span class="keyword">if</span>(!used[G[i].v])&#123;</span><br><span class="line">    ctedge=<span class="number">0</span>;sum=size[G[i].v];</span><br><span class="line">    <span class="built_in">getroot</span>(G[i].v,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">getans</span>(G[ctedge].v);</span><br><span class="line">	<span class="built_in">getans</span>(G[ctedge].from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>点分治</tag>
        <tag>边分治</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流，费用流和二分图匹配模板</title>
    <url>/2018/12/31/%E7%BD%91%E7%BB%9C%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81%E5%92%8C%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$网络流，费用流相关的复习笔记：</p>
<span id="more"></span>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p=<span class="number">1</span>,S,T,n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last,rl;&#125;G[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	G[++p]=(ss)&#123;b,head[a],c&#125;;head[a]=p;</span><br><span class="line">	G[++p]=(ss)&#123;a,head[b],<span class="number">0</span>&#125;;head[b]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; Q;dis[S]=<span class="number">1</span>;Q.<span class="built_in">push</span>(S);</span><br><span class="line">  <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">    <span class="keyword">if</span>(G[i].rl&gt;<span class="number">0</span>&amp;&amp;dis[G[i].v]==<span class="number">0</span>)&#123;</span><br><span class="line">      dis[G[i].v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">      Q.<span class="built_in">push</span>(G[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dis[T]!=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Augment</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> S,<span class="type">int</span> T,<span class="type">int</span> mi)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a==T)<span class="keyword">return</span> mi;</span><br><span class="line">	<span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[a];i;i=G[i].last)</span><br><span class="line">  <span class="keyword">if</span>((dis[G[i].v]==dis[a]+<span class="number">1</span>)&amp;&amp;(G[i].rl!=<span class="number">0</span>))&#123;</span><br><span class="line">    <span class="type">int</span> ls=<span class="built_in">Augment</span>(G[i].v,S,T,<span class="built_in">min</span>(mi,G[i].rl));</span><br><span class="line">		flow+=ls;mi-=ls;G[i].rl-=ls;G[i^<span class="number">1</span>].rl+=ls;</span><br><span class="line">    <span class="keyword">if</span>(!mi)<span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,ls;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>(S,T))ans+=<span class="built_in">Augment</span>(S,S,T,inf);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p=<span class="number">1</span>,S,T,n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last;<span class="type">int</span> rl;&#125;G[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	G[++p]=(ss)&#123;b,head[a],c&#125;;head[a]=p;</span><br><span class="line">	G[++p]=(ss)&#123;a,head[b],<span class="number">0</span>&#125;;head[b]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N],cur[N],num[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">	++num[dis[T]=<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; Q;Q.<span class="built_in">push</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)<span class="keyword">if</span>(!dis[G[i].v])</span><br><span class="line">		&#123;++num[dis[G[i].v]=dis[u]+<span class="number">1</span>];Q.<span class="built_in">push</span>(G[i].v);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Augment</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> S,<span class="type">int</span> T,<span class="type">int</span> mi)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==T)<span class="keyword">return</span> mi;</span><br><span class="line">	<span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cur[a];i;i=G[i].last)<span class="keyword">if</span>(dis[G[i].v]==dis[a]<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> ls=<span class="built_in">Augment</span>(G[i].v,S,T,<span class="built_in">min</span>(mi,G[i].rl));</span><br><span class="line">		flow+=ls;mi-=ls;G[i].rl-=ls;G[i^<span class="number">1</span>].rl+=ls;</span><br><span class="line">		<span class="keyword">if</span>(!mi)<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!(--num[dis[a]]))dis[S]=n+<span class="number">1</span>;</span><br><span class="line">	++num[++dis[a]];cur[a]=head[a];</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ISAP</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	<span class="built_in">bfs</span>(T);</span><br><span class="line">	<span class="type">int</span> ret=<span class="built_in">Augment</span>(S,S,T,inf);</span><br><span class="line">	<span class="keyword">while</span>(dis[S]&lt;=n)ret+=<span class="built_in">Augment</span>(S,S,T,inf);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="费用流（最小费用最大流）"><a href="#费用流（最小费用最大流）" class="headerlink" title="费用流（最小费用最大流）"></a>费用流（最小费用最大流）</h2><h3 id="ZKW"><a href="#ZKW" class="headerlink" title="ZKW"></a>ZKW</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p=<span class="number">1</span>,S,T,n,m,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last;<span class="type">int</span> rl,w;&#125;G[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	G[++p]=(ss)&#123;b,head[a],c,d&#125;;head[a]=p;</span><br><span class="line">	G[++p]=(ss)&#123;a,head[b],<span class="number">0</span>,-d&#125;;head[b]=p;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">int</span> dis[N],Mincost,Maxflow;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)dis[i]=inf,vis[i]=<span class="number">0</span>;</span><br><span class="line">	dis[T]=<span class="number">0</span>,vis[T]=<span class="number">1</span>;</span><br><span class="line">	Q.<span class="built_in">push</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">		<span class="keyword">if</span>(G[i^<span class="number">1</span>].rl&gt;<span class="number">0</span>&amp;&amp;dis[G[i].v]&gt;dis[u]-G[i].w)&#123;</span><br><span class="line">			dis[G[i].v]=dis[u]-G[i].w;</span><br><span class="line">			<span class="keyword">if</span>(!vis[G[i].v])</span><br><span class="line">			Q.<span class="built_in">push</span>(G[i].v),vis[G[i].v]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[S]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Augment</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> S,<span class="type">int</span> T,<span class="type">int</span> mi)</span></span>&#123;</span><br><span class="line">	used[a]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(a==T)<span class="keyword">return</span> mi;</span><br><span class="line">  <span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[a];i;i=G[i].last)</span><br><span class="line">	<span class="keyword">if</span>(!used[G[i].v]&amp;&amp;G[i].rl&amp;&amp;dis[a]-G[i].w==dis[G[i].v])&#123;</span><br><span class="line">	  <span class="type">int</span> ls=<span class="built_in">Augment</span>(G[i].v,S,T,<span class="built_in">min</span>(G[i].rl,mi));</span><br><span class="line">	  Mincost+=ls*G[i].w,mi-=flow,G[i].rl-=ls,G[i^<span class="number">1</span>].rl+=ls,flow+=ls;</span><br><span class="line">	  <span class="keyword">if</span>(!mi)<span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZKW</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">	Maxflow=Mincost=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">SPFA</span>(S,T))&#123;</span><br><span class="line">		used[T]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(used[T])&#123;</span><br><span class="line">      <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">      Maxflow+=<span class="built_in">Augment</span>(S,S,T,inf);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><h3 id="Hungary"><a href="#Hungary" class="headerlink" title="Hungary"></a>Hungary</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> used[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n,m,e,ans;</span><br><span class="line"><span class="type">int</span> head[N],p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last;&#125;G[N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;G[++p].v=b;G[p].last=head[a];head[a]=p;&#125;</span><br><span class="line"><span class="type">int</span> match[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)<span class="keyword">if</span>(!used[G[i].v])&#123;</span><br><span class="line">		used[G[i].v]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!match[G[i].v]||<span class="built_in">dfs</span>(match[G[i].v]))</span><br><span class="line">		&#123;match[G[i].v]=u;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungary</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">dfs</span>(i))ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kuhn-Munkres（带权）"><a href="#Kuhn-Munkres（带权）" class="headerlink" title="Kuhn Munkres（带权）"></a>Kuhn Munkres（带权）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;<span class="type">int</span> v,last,w;&#125;G[N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;G[++p].v=b;G[p].last=head[a];G[p].w=c;head[a]=p;&#125;</span><br><span class="line"><span class="type">bool</span> usem[N&lt;&lt;<span class="number">1</span>],usen[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> match[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> maxn[N&lt;&lt;<span class="number">1</span>],maxm[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> slack[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  usen[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)&#123;</span><br><span class="line">    <span class="keyword">if</span>(usem[G[i].v])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> gap=maxn[u]+maxm[G[i].v]-G[i].w;</span><br><span class="line">    <span class="keyword">if</span>(gap==<span class="number">0</span>)&#123;</span><br><span class="line">      usem[G[i].v]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(match[G[i].v]==<span class="number">0</span>||<span class="built_in">dfs</span>(match[G[i].v]))</span><br><span class="line">			&#123;match[G[i].v]=u;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    &#125; </span><br><span class="line">		<span class="keyword">else</span> slack[G[i].v]=<span class="built_in">min</span>(slack[G[i].v],gap);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kuhn_Munkres</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="built_in">sizeof</span>(match));</span><br><span class="line">	<span class="built_in">memset</span>(maxm,<span class="number">0</span>,<span class="built_in">sizeof</span>(maxm));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">		maxn[u]=-inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">		maxn[u]=<span class="built_in">max</span>(maxn[u],G[i].w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)slack[j]=inf;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">memset</span>(usem,<span class="number">0</span>,<span class="built_in">sizeof</span>(usem));</span><br><span class="line">			<span class="built_in">memset</span>(usen,<span class="number">0</span>,<span class="built_in">sizeof</span>(usen));</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dfs</span>(i))<span class="keyword">break</span>;</span><br><span class="line">			<span class="type">int</span> a=inf;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">      <span class="keyword">if</span>(!usem[j])a=<span class="built_in">min</span>(a,slack[j]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(usen[j])maxn[j]-=a;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">if</span>(usem[j])maxm[j]+=a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)</span><br><span class="line">		<span class="keyword">if</span>(match[G[i].v]==u)</span><br><span class="line">		res+=G[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1110\BZOJ1058 [ZJOI2007]报表统计</title>
    <url>/2019/03/12/%E6%B4%9B%E8%B0%B7P1110-BZOJ1058-ZJOI2007-%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P1110">洛谷P1110\BZOJ1058 [ZJOI2007]报表统计</a></p>
<span id="more"></span>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>第一次看见这个题：想了一会，woc，三颗平衡树，好麻烦呀，先放一放。</p>
<p>第二次看见这个题：想了一会，woc，平衡树加线段树，好麻烦呀，先放一放。</p>
<p>第三次看见这个题：想了一会，woc，一棵权值平衡树加一棵位置平衡树，好麻烦呀，先放一放。</p>
<p>第四次看见这个题：想了一会，woc，一棵平衡树加堆，好麻烦呀……诶等等，好像可以就开两个差不多的平衡树就行了……</p>
<hr>
<p>写的时候脑袋有点懵，不过还是肝好了呢。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>当他插入的时候，显然可以发现，就是在堆里面删除元素：$abs(head[id+1]-tail[id])$；然后插入两个新元素：$abs(head[id+1]-new)$，$abs(new-tail[id])$。然后新的 $tail[id]$ 再附上 $new$。每次询问 $MIN\_GAP$ 就是询问堆里面的最小值了。</p>
<p>支持删除，插入，查询权值最小，显然可以用平衡树去搞。</p>
<p>对于第二种询问，单独插入一个元素，我们需要在集合里面查找他的前驱和后继，便可以计算最小的差值，显然这个询问的答案是单调的，所以我们开全局变量去记录。</p>
<p>支持插入，查前驱，查后继，显然可以又用平衡树去搞。</p>
<p>这里我用了我喜欢的$Fhq\_Treap$，然后前驱后继是直接查的，其实可以通过$pushup$上传最大最小值，但是不知道为什么会慢一点，然后卡了会儿常，代码有点丑：</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Abs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)<span class="keyword">return</span> -a;<span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)<span class="keyword">return</span> a;<span class="keyword">return</span> b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)<span class="keyword">return</span> a;<span class="keyword">return</span> b;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fhq_treap_val</span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> lson ls[rt]</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rson rs[rt]</span></span><br><span class="line">  <span class="type">int</span> val[N],size[N],key[N];</span><br><span class="line">  <span class="type">int</span> ls[N],rs[N];</span><br><span class="line">  <span class="type">int</span> root,cnt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;size[rt]=size[lson]+size[rson]+<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||!b)<span class="keyword">return</span> a|b;</span><br><span class="line">    <span class="keyword">if</span>(key[a]&lt;key[b])&#123;rs[a]=<span class="built_in">merge</span>(rs[a],b);<span class="built_in">pushup</span>(a);<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ls[b]=<span class="built_in">merge</span>(a,ls[b]);<span class="built_in">pushup</span>(b);<span class="keyword">return</span> b;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt)&#123;a=b=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(val[rt]&lt;=x)&#123;a=rt;<span class="built_in">split</span>(rson,x,rson,b);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;b=rt;<span class="built_in">split</span>(lson,x,a,lson);&#125;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;<span class="keyword">while</span>(rson)rt=rson;<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;<span class="keyword">while</span>(lson)rt=lson;<span class="keyword">return</span> val[rt];&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=++cnt;</span><br><span class="line">    val[rt]=x;</span><br><span class="line">    size[rt]=<span class="number">1</span>;key[rt]=<span class="built_in">rand</span>();</span><br><span class="line">    lson=rson=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">    <span class="type">int</span> rt=<span class="built_in">newnode</span>(x);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,rt),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert_2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,b);</span><br><span class="line">    <span class="keyword">if</span>(size[a])ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(x-<span class="built_in">Max</span>(a)));</span><br><span class="line">    <span class="keyword">if</span>(size[b])ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(<span class="built_in">Min</span>(b)-x));</span><br><span class="line">    <span class="type">int</span> rt=<span class="built_in">newnode</span>(x);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,rt),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">split</span>(root,x,a,c);</span><br><span class="line">    <span class="built_in">split</span>(a,x<span class="number">-1</span>,a,b);</span><br><span class="line">    b=<span class="built_in">merge</span>(ls[b],rs[b]);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(a,b),c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;T1,T2;</span><br><span class="line"><span class="type">int</span> n,m,a[N],b[N],id,g;</span><br><span class="line"><span class="type">char</span> op[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=b[i]=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)T1.<span class="built_in">Insert</span>(<span class="built_in">Abs</span>(a[i+<span class="number">1</span>]-a[i]));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)T2.<span class="built_in">Insert_2</span>(a[i]);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">      id=<span class="built_in">read</span>();g=<span class="built_in">read</span>();</span><br><span class="line">      T2.<span class="built_in">Insert_2</span>(g);</span><br><span class="line">      <span class="keyword">if</span>(id!=n)&#123;</span><br><span class="line">        T1.<span class="built_in">Delete</span>(<span class="built_in">Abs</span>(a[id+<span class="number">1</span>]-b[id]));</span><br><span class="line">        T1.<span class="built_in">Insert</span>(<span class="built_in">Abs</span>(a[id+<span class="number">1</span>]-g));</span><br><span class="line">      &#125;</span><br><span class="line">      T1.<span class="built_in">Insert</span>(<span class="built_in">Abs</span>(b[id]-g));</span><br><span class="line">      b[id]=g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">4</span>]==<span class="string">&#x27;G&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T1.<span class="built_in">Min</span>(T1.root));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Fhq_Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路，生成树和生成树形图相关</title>
    <url>/2018/12/29/%E6%9C%80%E7%9F%AD%E8%B7%AF-%E7%94%9F%E6%88%90%E6%A0%91%E5%92%8C%E7%94%9F%E6%88%90%E6%A0%91%E5%BD%A2%E5%9B%BE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$图论基础复习笔记：</p>
<span id="more"></span>
<h2 id="存图相关"><a href="#存图相关" class="headerlink" title="存图相关"></a>存图相关</h2><h3 id="1-邻接表："><a href="#1-邻接表：" class="headerlink" title="1.邻接表："></a>1.邻接表：</h3><p>$\ \ \ \ \ \ \ \,$在点数特别小的时候，我们可以用邻接表（二维数组）来表示点之间的链接关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> e[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span>&#123;e[a][b]=w;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-链表："><a href="#2-链表：" class="headerlink" title="2. 链表："></a>2. 链表：</h3><p>$\ \ \ \ \ \ \ \,$在点数比较大的时候，我们可以用链式向前星来表示点之间的链接关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head[N],p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> v,w,last;&#125;E[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;E[++p]=(Edge)&#123;b,w,head[a]&#125;;head[a]=p;&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$遍历方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].last)G[i].v,G[i].w;</span><br><span class="line"><span class="comment">//G[i].v就是u的直接连接点，G[i].w是边上信息</span></span><br></pre></td></tr></table></figure>
<h3 id="3-动态数组"><a href="#3-动态数组" class="headerlink" title="3.动态数组"></a>3.动态数组</h3><p>$\ \ \ \ \ \ \ \,$在点数比较大的时候，我们可以用$\tt vector$，会比链表慢一点，但是比较方便，下面默认都是这种存图方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> p,w;&#125;E[N];</span><br><span class="line">vector&lt;Edge&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;e[a].<span class="built_in">push_back</span>((Edge)&#123;b,w&#125;);&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$遍历方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])v.p,v.w;</span><br><span class="line"><span class="comment">//v.p就是u的直接连接点，v.w是边上信息</span></span><br></pre></td></tr></table></figure>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>$\ \ \ \ \ \ \ \,$最短路的核心思想都差不多，用松弛操作来求解，所以只讲算法特点和用法，不讲原理：</p>
<h3 id="1-Floyd"><a href="#1-Floyd" class="headerlink" title="1.Floyd"></a>1.Floyd</h3><p>$\ \ \ \ \ \ \ \,$Floyd可以在$O(n^3)$的时间内，求出任意点对两两之间的距离，支持负边权：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dis[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dis[i][i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:E[i])dis[i][v.p]=v.w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	<span class="keyword">if</span>(dist[i][j]&gt;dist[i][k]+dist[k][j])</span><br><span class="line">	dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="2-SPFA"><a href="#2-SPFA" class="headerlink" title="2.SPFA"></a>2.SPFA</h3><p>$\ \ \ \ \ \ \ \,$SPFA可以在下到$n$上到$(n^2)$的时间内，求出单源对于每个点最短路，支持负边权，但是因为复杂度不平衡，关于SPFA,他死了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  Q.<span class="built_in">push</span>(S);used[S]=<span class="number">1</span>;dis[S]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();used[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])</span><br><span class="line">    <span class="keyword">if</span>(dis[v.p]&gt;dis[u]+v.w)&#123;</span><br><span class="line">      dis[v.p]=dis[u]+v.w;</span><br><span class="line">      <span class="keyword">if</span>(used[v.p]==<span class="number">0</span>)</span><br><span class="line">			&#123;used[v.p]=<span class="number">1</span>;Q.<span class="built_in">push</span>(v.p);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \ \,$或者SPFA加上堆优化后，复杂度会比较好，长得也和Dijkstra很相像了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> v,dis;&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.dis&gt;b.dis;&#125;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line">priority_queue&lt;node&gt; Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_SPFA</span><span class="params">(<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  Q.<span class="built_in">push</span>((node)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	dis[S]=<span class="number">0</span>;used[S]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u=Q.<span class="built_in">top</span>().v;Q.<span class="built_in">pop</span>();used[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])</span><br><span class="line">    <span class="keyword">if</span>(dis[v.p]&gt;dis[u]+v.w)&#123;</span><br><span class="line">      dis[v.p]=dis[u]+v.w;</span><br><span class="line">      <span class="keyword">if</span>(used[v.p]==<span class="number">0</span>)</span><br><span class="line">			&#123;used[v.p]=<span class="number">1</span>;Q.<span class="built_in">push</span>((node)&#123;dis[v.p],v.p&#125;)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Dijkstra"><a href="#3-Dijkstra" class="headerlink" title="3.Dijkstra"></a>3.Dijkstra</h3><p>$\ \ \ \ \ \ \ \,$Dijkstra可以在$O(n\log n)$的时间内，求出单源对于每个点最短路，但是不支持负边权：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> v,dis;&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.dis&gt;b.dis;&#125;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line">priority_queue&lt;node&gt; Q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">  	Q.<span class="built_in">push</span>((node)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);dis[S]=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    	<span class="type">int</span> u=Q.<span class="built_in">top</span>().v;Q.<span class="built_in">pop</span>();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])</span><br><span class="line">    	<span class="keyword">if</span>(dis[v.p]&gt;dis[u]+v.w)&#123;</span><br><span class="line">      		dis[v.p]=dis[u]+v.w;</span><br><span class="line">			Q.<span class="built_in">push</span>((node)&#123;dis[v.p],v.p&#125;);</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>$\ \ \ \ \ \ \ \,$生成树是针对无向图的说法，基本上是基于贪心的操作。</p>
<h3 id="1-最小生成树"><a href="#1-最小生成树" class="headerlink" title="1.最小生成树"></a>1.最小生成树</h3><p>$\ \ \ \ \ \ \ \,$最小生成树最常见的贪心做法是Kruskal，因为一棵树$n-1$条边，我们可以把所有边排序过后，贪心选取能构成树的最小的$n-1$条边，用并查集维护其连通性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> top,fa[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link</span>&#123;<span class="type">int</span> u,v,w;&#125;e[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Link &amp;a,<span class="type">const</span> Link &amp;b)&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> a==fa[a]?a:fa[a]=<span class="built_in">find</span>(fa[a]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span>&#123;e[++top]=(Link)&#123;a,b,w&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+top+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,A,B;i&lt;=m;i++)</span><br><span class="line">  <span class="keyword">if</span>((A=<span class="built_in">find</span>(e[i].u))!=(B=<span class="built_in">find</span>(e[i].v)))&#123;</span><br><span class="line">		<span class="built_in">add</span>(e[i].u,e[i].v,e[i].w);</span><br><span class="line">		<span class="built_in">add</span>(e[i].v,e[i].u,e[i].w);</span><br><span class="line">		fa[A]=B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-次小生成树-k小生成树-严格次小生成树"><a href="#2-次小生成树-k小生成树-严格次小生成树" class="headerlink" title="2.次小生成树\k小生成树\严格次小生成树"></a>2.次小生成树\k小生成树\严格次小生成树</h3><p>$\ \ \ \ \ \ \ \,$次小生成树，我们就是做如下操作：</p>
<ol>
<li><p>做一次最小生成树；</p>
</li>
<li><p>在没有加入树边的边中选一个最小的，假设为u与v之间的边；</p>
</li>
<li><p>在最小生成树上面$u$到$v$的路径上，删除一条最长的边；</p>
</li>
<li><p>然后把2步中选择的边加入树边。</p>
</li>
</ol>
<p>$\ \ \ \ \ \ \ \,$复杂度是$O(m\log m+n\log n)$，操作比较繁琐，虽然有些时候不需要真实建树，但是还是很繁琐，就不单独贴模板了。</p>
<p>$\ \ \ \ \ \ \ \,$对于k小生成树，我们做k次就好了啊，复杂度$O(m\log m+kn\log n)$。</p>
<p>$\ \ \ \ \ \ \ \,$对于严格次小生成树，我们做最多$m$次，检查直到严格大于最小生成树就停止，复杂度$O(m\log m+mn\log n)$。</p>
<h3 id="P4180-【模板】严格次小生成树-BJWC2010"><a href="#P4180-【模板】严格次小生成树-BJWC2010" class="headerlink" title="P4180 【模板】严格次小生成树[BJWC2010]"></a><a href="https://www.luogu.org/problemnew/show/P4180">P4180 【模板】严格次小生成树[BJWC2010]</a></h3><p>$\ \ \ \ \ \ \ \,$代码很长，引起不适：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> inf=<span class="number">2147483647000000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">900010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Cnt;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> p,w;&#125;E[N];</span><br><span class="line">vector&lt;Edge&gt; G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;G[a].<span class="built_in">push_back</span>((Edge)&#123;b,w&#125;);&#125;</span><br><span class="line"><span class="type">int</span> top,Fa[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link</span>&#123;<span class="type">int</span> u,v,w;&#125;e[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Link &amp;a,<span class="type">const</span> Link &amp;b)&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> a==Fa[a]?a:Fa[a]=<span class="built_in">find</span>(Fa[a]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span>&#123;e[++top]=(Link)&#123;a,b,w&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+top+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)Fa[i]=i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,A,B;i&lt;=m;i++)</span><br><span class="line">  <span class="keyword">if</span>((A=<span class="built_in">find</span>(e[i].u))!=(B=<span class="built_in">find</span>(e[i].v)))&#123;</span><br><span class="line">		<span class="built_in">add</span>(e[i].u,e[i].v,e[i].w);</span><br><span class="line">		<span class="built_in">add</span>(e[i].v,e[i].u,e[i].w);</span><br><span class="line">		Cnt+=<span class="number">1ll</span>*e[i].w;</span><br><span class="line">		used[i]=<span class="number">1</span>;</span><br><span class="line">		Fa[A]=B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">19</span>],deep[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Max[N][<span class="number">19</span>],Min[N][<span class="number">19</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  fa[u][<span class="number">0</span>]=f;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.p==f)<span class="keyword">continue</span>;</span><br><span class="line">    deep[v.p]=deep[u]+<span class="number">1</span>;</span><br><span class="line">    Max[v.p][<span class="number">0</span>]=v.w;</span><br><span class="line">    Min[v.p][<span class="number">0</span>]=-inf;</span><br><span class="line">    <span class="built_in">dfs</span>(v.p,u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;++i)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">    fa[j][i]=fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    Max[j][i]=<span class="built_in">max</span>(Max[j][i<span class="number">-1</span>],Max[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    Min[j][i]=<span class="built_in">max</span>(Min[j][i<span class="number">-1</span>],Min[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(Max[j][i<span class="number">-1</span>]&gt;Max[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>])</span><br><span class="line">		Min[j][i]=<span class="built_in">max</span>(Min[j][i],Max[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Max[j][i<span class="number">-1</span>]&lt;Max[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>])</span><br><span class="line">		Min[j][i]=<span class="built_in">max</span>(Min[j][i],Max[j][i<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(deep[x]&lt;deep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">  <span class="keyword">if</span>(deep[fa[x][i]]&gt;=deep[y])x=fa[x][i];</span><br><span class="line">  <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">  <span class="keyword">if</span>(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];</span><br><span class="line">  <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qmax</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> maxx)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> Ans=-inf;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">  <span class="keyword">if</span>(deep[fa[u][i]]&gt;=deep[v])&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxx!=Max[u][i])Ans=<span class="built_in">max</span>(Ans,Max[u][i]);</span><br><span class="line">    <span class="keyword">else</span> Ans=<span class="built_in">max</span>(Ans,Min[u][i]);</span><br><span class="line">    u=fa[u][i];</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b,c;i&lt;=m;i++)</span><br><span class="line">	a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>(),</span><br><span class="line">	<span class="built_in">add_edge</span>(a,b,c);</span><br><span class="line">	<span class="built_in">Kruskal</span>();</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> Ans=inf;</span><br><span class="line">  Min[<span class="number">1</span>][<span class="number">0</span>]=-inf;</span><br><span class="line">  deep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="built_in">cal</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">    <span class="type">int</span> u=e[i].u,v=e[i].v,lca=<span class="built_in">LCA</span>(u,v);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d=e[i].w;</span><br><span class="line">    Ans=<span class="built_in">min</span>(Ans,Cnt-<span class="built_in">max</span>(<span class="built_in">qmax</span>(u,lca,d),<span class="built_in">qmax</span>(v,lca,d))+d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,Ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-斯坦纳树"><a href="#3-斯坦纳树" class="headerlink" title="3.斯坦纳树"></a>3.斯坦纳树</h3><p>$\ \ \ \ \ \ \ \,$当只要求图的一部分点连接的时候，求最小的生成树，就是斯坦纳树，做法比较繁琐，大数据也不能优秀地处理。具体看这里<a href="https://blog.csdn.net/VictoryCzt/article/details/82972857">【斯坦纳树学习笔记(VictoryCzt Orz)】</a>。</p>
<h2 id="生成树形图"><a href="#生成树形图" class="headerlink" title="生成树形图"></a>生成树形图</h2><p>$\ \ \ \ \ \ \ \,$树形图不是一个有很好求法的东西，朱刘算法可以做到复杂度$O(nm)$求出最小树形图，过程大概如下：</p>
<ol>
<li><p>找到除了$root$以为其他点的权值最小的入边，如果出现除了$root$以外存在其他孤立的点，则不存在最小树形图。</p>
</li>
<li><p>找到图中所有的环，并对环进行缩点，重新编号，更新其他点到环上的点的距离。</p>
</li>
<li><p>以环数为下一次查找的点数，继续执行上述操作，直到没有环或者判定出不存在最小树形图为止。</p>
</li>
</ol>
<p>$\ \ \ \ \ \ \ \,$大概就是这个图的意思：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b5fbfbb3e6872794a624ca4947d868ae.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,root;  </span><br><span class="line"><span class="type">int</span> k[N],idx[N],x,tim;</span><br><span class="line"><span class="type">int</span> cost[N],fa[N],f[N];</span><br><span class="line"><span class="type">int</span> mincost[N],ans,top;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link</span>&#123;<span class="type">int</span> u,v,w;&#125;e[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Link &amp;a,<span class="type">const</span> Link &amp;b)&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span>&#123;e[++top]=(Link)&#123;a,b,w&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Zhu_Liu</span><span class="params">(<span class="type">int</span> root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mincost,<span class="number">63</span>,<span class="built_in">sizeof</span>(mincost));</span><br><span class="line">    <span class="built_in">memset</span>(idx,<span class="number">-1</span>,<span class="built_in">sizeof</span>(idx));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="keyword">if</span>(e[i].w&lt;mincost[e[i].v]&amp;&amp;e[i].u!=e[i].v)</span><br><span class="line">		&#123;mincost[e[i].v]=e[i].w;fa[e[i].v]=e[i].u;&#125;</span><br><span class="line">    mincost[root]=<span class="number">0</span>;tim=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(mincost[i]==mincost[<span class="number">0</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      ans+=mincost[i];x=i;</span><br><span class="line">      <span class="keyword">while</span>(f[x]!=i&amp;&amp;x!=root)f[x]=i,x=fa[x];</span><br><span class="line">      <span class="keyword">if</span>(x!=root&amp;&amp;idx[x]==<span class="number">-1</span>)&#123;</span><br><span class="line">        tim++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=fa[x];j!=x;j=fa[j])idx[j]=tim;</span><br><span class="line">        idx[x]=tim;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tim==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(idx[i]==<span class="number">-1</span>)idx[i]=++tim;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">      x=e[i].v;e[i].u=idx[e[i].u];e[i].v=idx[e[i].v];</span><br><span class="line">      <span class="keyword">if</span>(e[i].u!=e[i].v)e[i].w-=mincost[x];</span><br><span class="line">    &#125;</span><br><span class="line">    n=tim;root=idx[root];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成树和生成树形图计数"><a href="#生成树和生成树形图计数" class="headerlink" title="生成树和生成树形图计数"></a>生成树和生成树形图计数</h2><p>$\ \ \ \ \ \ \ \,$计数的话，需要用到矩阵树定理：</p>
<p>$\ \ \ \ \ \ \ \,$<strong>图基尔霍夫矩阵的行列式值就是图的生成树个数</strong></p>
<p>$\ \ \ \ \ \ \ \,$对于生成树形图同样适用，把双向边和入度改为单向即可，通过线性代数技巧优化求行列式的复杂度，可以做到$O(n^3+nm)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> A[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	A[a][a]++;A[b][b]++;</span><br><span class="line">	A[a][b]--;A[b][a]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">		<span class="keyword">while</span>(A[j][i])&#123;</span><br><span class="line">			<span class="type">int</span> t=A[i][i]/A[j][i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;n;k++)</span><br><span class="line">			A[i][k]-=t*A[j][k];</span><br><span class="line">			<span class="built_in">swap</span>(A[j],A[i]);</span><br><span class="line">			ans=-ans;</span><br><span class="line">		&#125;</span><br><span class="line">		ans*=A[i][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>生成树形图</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量字符串算法——KMP（AC自动机模板）和Manachar</title>
    <url>/2018/12/29/%E8%BD%BB%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95-KMP-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A8%A1%E6%9D%BF-%E5%92%8CManachar/</url>
    <content><![CDATA[<p>$\ \ \ \ \ \ \ \,$一些简单字符串相关算法的复习笔记：</p>
<span id="more"></span>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>$\ \ \ \ \ \ \,$kmp是用来处理字符串匹配的常见简单算法，网上可以找到很多讲解，这里就不细讲了，一笔带过。</p>
<p>$\ \ \ \ \ \ \,$我们知道，暴力匹配两个字符串的复杂度是$O(n^2)$的，很多时候我们都不能接受这个复杂度，考虑如何减小复杂度，我们发现在暴力匹配的过程中，会重复匹配很多地方，所以我们从这里下手，进行优化。</p>
<p>$\ \ \ \ \ \ \,$引入kmp算法最核心的东西—— $ next$ 数组：</p>
<p>$\ \ \ \ \ \ \,$代表当前字符之前的字符串中，有多大长度的相同前缀。例如如果 $next [j] = k$，代表位置 $j$ 之前的字符串中有最大长度为 $k $ 的相同前缀。</p>
<p>$\ \ \ \ \ \ \,$意味着在某个字符失配时，告诉你下一步匹配中，模式串应该跳到哪个位置（$next [j]$ ）。如果 $next [j]$ 等于$-1$，则跳到模式串的开头字符，若 $next [j] = k$ 且 $k &gt; 0$，代表下次匹配跳到 $j$ 之前的某个字符，而不是跳到开头，跳过了 $k$ 个曾经匹配过的字符。</p>
<p>$\ \ \ \ \ \ \,$为什么这 $k$ 个字符就这样逃过了？我们可以这样感性地理解：</p>
<p>$\ \ \ \ \ \ \,$若是在 $j$ 这个位置失配，那么说明在这个位置之前，模式串和文本串是可以匹配的，也就是一样的，那么我们要是可以预处理下次跳到的地方就好了，这个就是我们预处理的结果：$ next$ 数组。</p>
<p>$\ \ \ \ \ \ \,$这样我们的匹配复杂度就降为$O(n)$：</p>
<p>$\ \ \ \ \ \ \,$假设现在文本串$S$匹配到 $i$ 位置，模式串$P$匹配到 $j$ 位置</p>
<ul>
<li><p>如果$j = -1$，或者当前字符匹配成功（即$S[i] = P[j]$），$i$，$j$都加一，继续匹配下一个字符；</p>
</li>
<li><p>如果$j \neq -1$，且当前字符匹配失败（即$S[i] \neq P[j]$），则令 $i$ 不变，$j = next[j]$。此举意味着失配时，模式串P相对于文本串S向右移动了$j - next [j]$ 位。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;slen&amp;&amp;j&lt;plen)&#123;</span><br><span class="line">  <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==p[j])i++,j++;</span><br><span class="line">  <span class="keyword">else</span> j=Next[j];</span><br><span class="line">  <span class="keyword">if</span>(j==plen)j=Next[j];<span class="comment">//到这里就匹配到了一个模式串了。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$那么我们如何快速地求出$ next$ 数组？</p>
<p>$\ \ \ \ \ \ \,$这个过程相当于自己与自己匹配，假设现在对于字符串$p$，已经处理到了 $k$ 位置，和自己匹配到了 $j$ 位置（显然$k&gt;j$）：</p>
<ul>
<li><p>如果$j&gt;0$，并且$p[k]\neq p[j]$，那么就是和自己失配了，$j = next[j]$；</p>
</li>
<li><p>如果$p[k]= p[j]$，那么就是是适配了，$k$，$j$都加一，同时如果下次匹配的时候在 $k+1$ 处失配了，那么我们就跳过枚举前面 $k$ 个元素，直接匹配 $j+1$，所以 $next[k+1]=j+1$。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">  <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;(p[k]!=p[j])) j=next[j];</span><br><span class="line">  j+=(p[k]==p[j]);next[k+<span class="number">1</span>]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$复杂度$O(n)$。</p>
<p>$\ \ \ \ \ \ \,$单字符串匹配的话，就是模板题不说了，kmp最重要的，还是对$ next$ 数组的运用。<del>（多字符串匹配我还是信仰Sam，XD）</del>，还是贴一个AC自动机的模板XD：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AC_Automata</span>&#123;</span><br><span class="line">	<span class="type">int</span> son[<span class="number">26</span>][N],fail[N],appear[N];</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Get_trie</span><span class="params">(<span class="type">char</span> s[],<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!son[s[i]-<span class="string">&#x27;a&#x27;</span>][now])son[s[i]-<span class="string">&#x27;a&#x27;</span>][now]=++size;</span><br><span class="line">			now=son[s[i]-<span class="string">&#x27;a&#x27;</span>][now]; </span><br><span class="line">		&#125;</span><br><span class="line">		appear[now]=id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)<span class="keyword">if</span>(son[i][<span class="number">0</span>]!=<span class="number">0</span>)</span><br><span class="line">		fail[son[i][<span class="number">0</span>]]=<span class="number">0</span>,Q.<span class="built_in">push</span>(son[i][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="type">int</span> u=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">			<span class="keyword">if</span>(son[i][u])fail[son[i][u]]=son[i][fail[u]],Q.<span class="built_in">push</span>(son[i][u]);</span><br><span class="line">			<span class="keyword">else</span> son[i][u]=son[i][fail[u]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">      now=son[s[i]-<span class="string">&#x27;a&#x27;</span>][now];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> t=now;t;t=fail[t])</span><br><span class="line">			<span class="comment">//something about appear[t];</span></span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="P3193-HNOI2008-GT考试"><a href="#P3193-HNOI2008-GT考试" class="headerlink" title="P3193 [HNOI2008]GT考试"></a><a href="https://www.luogu.org/problemnew/show/P3193">P3193 [HNOI2008]GT考试</a></h3><p>$\ \ \ \ \ \ \,$很明显的，我们会得到一个DP方程式：</p>
<p>$\ \ \ \ \ \ \,$我们令$f(i,j)$表示我们$X$已经处理到了$i$，其中出现了长度为$j$的连续不吉利数字。</p>
<p>$\ \ \ \ \ \ \,$答案显然就是$\sum_{i=0}^{m-1}f(n,i)$，现在考虑如何转移。</p>
<p>$\ \ \ \ \ \ \,$令$g(i,j)$表示，在长度为$j$的连续不吉利数字后，跟上数字$j$后，不吉利数字的长度。</p>
<p>$\ \ \ \ \ \ \,$那么就有：</p>
<p>$f(i,j)=\sum_{b=0}^{9} f(i,a)[j=g(a,b)]$</p>
<p>$\ \ \ \ \ \ \,$其中$g(a,b)$就可以用kmp的$ next$ 数组找到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> j,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;a[j]!=k)j=next[j];</span><br><span class="line">  <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$我们可以花$O(10\cdot m^2)$的时间把$g$预处理出来，如何$O(nm)$来dp，但是$n$特别大，于是我们用矩阵来优化，完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n,m,mod;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;<span class="type">int</span> n,m;<span class="type">int</span> a[N][N];&#125;A,B;</span><br><span class="line"><span class="keyword">inline</span> Matrix <span class="keyword">operator</span> *(<span class="type">const</span> Matrix &amp;a,<span class="type">const</span> Matrix &amp;b)&#123;</span><br><span class="line">  Matrix ret;</span><br><span class="line">  ret.n=a.n;ret.m=b.m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=b.m;j++)&#123;</span><br><span class="line">    ret.a[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=a.m;k++)</span><br><span class="line">    ret.a[i][j]=(ret.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> next[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> j,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;a[j+<span class="number">1</span>]!=k)j=next[j];</span><br><span class="line">  <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();mod=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">-1</span>,i=<span class="number">1</span>;i&lt;=m;next[i++]=++j)</span><br><span class="line">  <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;a[i]!=a[j+<span class="number">1</span>])j=next[j];</span><br><span class="line">  A.n=<span class="number">0</span>;A.m=m<span class="number">-1</span>;</span><br><span class="line">  B.m=B.n=m<span class="number">-1</span>;</span><br><span class="line">  A.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">  B.a[i][<span class="built_in">g</span>(i,j)]++;</span><br><span class="line">  <span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,B=B*B)<span class="keyword">if</span>(n&amp;<span class="number">1</span>)A=A*B;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) ans=(ans+A.a[<span class="number">0</span>][i])%mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Manachar"><a href="#Manachar" class="headerlink" title="Manachar"></a>Manachar</h2><p>$\ \ \ \ \ \ \,$manachar算法特别单一，就是求回文串用的，题一般也特别裸，比较套路。</p>
<p>$\ \ \ \ \ \ \,$首先，我们知道的，回文串分奇偶，但是如果我们在这个串中每一个字符之间都插入一个特殊字符，那么偶回文串就变成奇回文串了，这样我们就可以只处理奇回文串就行了。</p>
<p>$\ \ \ \ \ \ \,$然后就是$RL$数组，表示以这个字符为中点，回文串的最大半径是多少，manachar算法就是$O(n)$求$RL$数组的算法。下面直接将做法，不讲原理了：</p>
<p>$\ \ \ \ \ \ \,$记我们已经处理的回文串已经处理到的最右端为$MR$，他的对称轴为$pos$，现在要处理的位置为$i$，显然$pos&lt;i$。</p>
<p>$\ \ \ \ \ \ \,$如果$MR&gt;i$，那么我们可以确定，已$i$为中点，回文串的最大半径至少是${\rm min}(RL[2\cdot pos-i],MR-i)$。</p>
<p>$\ \ \ \ \ \ \,$剩下的就是暴力扩展，记得到时候更新一下$MR$和$pos$，模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> RL[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manacher</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> MR=<span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(RL,<span class="number">0</span>,<span class="built_in">sizeof</span>(RL));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(MR&gt;i)RL[i]=<span class="built_in">min</span>(RL[<span class="number">2</span>*pos-i],MR-i);</span><br><span class="line">	<span class="keyword">else</span> RL[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i+RL[i]]==s[i-RL[i]])RL[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i+RL[i]&gt;MR)MR=i+RL[i],pos=i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  len=<span class="built_in">strlen</span>(s);P[<span class="number">0</span>]=<span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len*<span class="number">2</span>+<span class="number">1</span>;i+=<span class="number">2</span>) P[i]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) P[i*<span class="number">2</span>+<span class="number">2</span>]=s[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P4555-国家集训队-最长双回文串"><a href="#P4555-国家集训队-最长双回文串" class="headerlink" title="P4555 [国家集训队]最长双回文串"></a><a href="https://www.luogu.org/problemnew/show/P4555">P4555 [国家集训队]最长双回文串</a></h3><p>$\ \ \ \ \ \ \,$在我们求好$RL$后，很明显的有一个dp，我们把对称轴上的信息移动到起始点和终点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">  L[i+RL[i]<span class="number">-1</span>]=<span class="built_in">max</span>(L[i+RL[i]<span class="number">-1</span>],RL[i]<span class="number">-1</span>);</span><br><span class="line">  R[i-RL[i]+<span class="number">1</span>]=<span class="built_in">max</span>(R[i-RL[i]+<span class="number">1</span>],RL[i]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\ \ \ \ \ \ \,$那么，显然的，答案等于：<br>${\rm Max}_{i=0}^{n-1}L_i+R_i[L_i\neq0,R_i\neq0]$</p>
<p>$\ \ \ \ \ \ \,$代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="comment">//char buf[1&lt;&lt;15],*S=buf,*T=buf;</span></span><br><span class="line"><span class="comment">//char getch()&#123;return S==T&amp;&amp;(T=(S=buf)+fread(buf,1,1&lt;&lt;15,stdin),S==T)?0:*S++;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch;ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">0</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch&amp;<span class="number">15</span>);ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">if</span>(f)<span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> RL[N&lt;&lt;<span class="number">1</span>],n;</span><br><span class="line"><span class="type">char</span> s[N],P[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> L[N&lt;&lt;<span class="number">1</span>],R[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manacher</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> MR=<span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(MR&gt;i)RL[i]=<span class="built_in">min</span>(RL[<span class="number">2</span>*pos-i],MR-i);</span><br><span class="line">    <span class="keyword">else</span> RL[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i+RL[i]]==s[i-RL[i]])RL[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i+RL[i]&gt;MR)MR=i+RL[i],pos=i;</span><br><span class="line">    L[i+RL[i]<span class="number">-1</span>]=<span class="built_in">max</span>(L[i+RL[i]<span class="number">-1</span>],RL[i]<span class="number">-1</span>);</span><br><span class="line">  	R[i-RL[i]+<span class="number">1</span>]=<span class="built_in">max</span>(R[i-RL[i]+<span class="number">1</span>],RL[i]<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">  len=<span class="built_in">strlen</span>(s);P[<span class="number">0</span>]=<span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len*<span class="number">2</span>+<span class="number">1</span>;i+=<span class="number">2</span>) P[i]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) P[i*<span class="number">2</span>+<span class="number">2</span>]=s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);n=<span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="built_in">insert</span>(s,n);</span><br><span class="line">  <span class="built_in">Manacher</span>(P,n*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>+<span class="number">1</span>;i+=<span class="number">2</span>)R[i]=<span class="built_in">max</span>(R[i],R[i<span class="number">-2</span>]<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n*<span class="number">2</span>+<span class="number">1</span>;i&gt;=<span class="number">1</span>;i-=<span class="number">2</span>)L[i]=<span class="built_in">max</span>(L[i],L[i+<span class="number">2</span>]<span class="number">-2</span>);</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n+<span class="number">1</span>;i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span>(R[i]&amp;&amp;L[i])ans=<span class="built_in">max</span>(ans,L[i]+R[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>KMP</tag>
        <tag>AC自动机</tag>
        <tag>Manachar</tag>
      </tags>
  </entry>
</search>
